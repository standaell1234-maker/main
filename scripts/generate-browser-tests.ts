/**
 * Generates Vitest browser test files for all compliance tests.
 *
 * This script scans the tests/tests directory and generates a single
 * test file that imports and runs all compliance tests in the browser.
 */

import * as fs from 'fs'
import * as path from 'path'

const testsDir = path.resolve(import.meta.dirname, '../tests/tests')
const outputFile = path.resolve(
  import.meta.dirname,
  '../tests/tests/tests.browser.test.ts',
)

interface TestInfo {
  name: string
  dir: string
  hasGsTs: boolean
  hasExpectedLog: boolean
  expectedOutput: string
  hasExternalImports: boolean
}

// Check if a .gs.ts file has imports outside @goscript/builtin
function hasExternalImports(gstsPath: string): boolean {
  const content = fs.readFileSync(gstsPath, 'utf-8')
  const importRegex = /import\s+.*\s+from\s+["']([^"']+)["']/g
  let match
  while ((match = importRegex.exec(content)) !== null) {
    const importPath = match[1]
    // Allow @goscript/builtin imports
    if (importPath.startsWith('@goscript/builtin')) continue
    // Allow relative imports within the same test directory
    if (importPath.startsWith('./') || importPath.startsWith('../')) continue
    // Any other @goscript import is external (e.g., @goscript/encoding/json)
    if (importPath.startsWith('@goscript/')) return true
  }
  return false
}

function getTestDirs(): TestInfo[] {
  const dirs = fs.readdirSync(testsDir, { withFileTypes: true })
  const tests: TestInfo[] = []

  for (const dir of dirs) {
    if (!dir.isDirectory()) continue

    const testDir = path.join(testsDir, dir.name)
    const gstsFile = path.join(testDir, `${dir.name}.gs.ts`)
    const expectedLogFile = path.join(testDir, 'expected.log')

    const hasGsTs = fs.existsSync(gstsFile)
    const hasExpectedLog = fs.existsSync(expectedLogFile)

    if (!hasGsTs) continue

    let expectedOutput = ''
    if (hasExpectedLog) {
      expectedOutput = fs.readFileSync(expectedLogFile, 'utf-8')
    }

    const hasExternal = hasExternalImports(gstsFile)

    tests.push({
      name: dir.name,
      dir: testDir,
      hasGsTs,
      hasExpectedLog,
      expectedOutput,
      hasExternalImports: hasExternal,
    })
  }

  return tests.sort((a, b) => a.name.localeCompare(b.name))
}

function generateTestFile(tests: TestInfo[]): string {
  const imports: string[] = []
  const testCases: string[] = []

  // Filter out tests with external imports for now
  const runnableTests = tests.filter((t) => !t.hasExternalImports)
  const skippedTests = tests.filter((t) => t.hasExternalImports)

  console.log(
    `  Runnable: ${runnableTests.length}, Skipped (external imports): ${skippedTests.length}`,
  )

  for (const test of runnableTests) {
    const importName = test.name.replace(/[^a-zA-Z0-9_]/g, '_')
    imports.push(
      `import { main as ${importName} } from './${test.name}/${test.name}.gs.ts'`,
    )

    const expectedOutput = JSON.stringify(test.expectedOutput.trimEnd())

    testCases.push(`
  it('${test.name}', async () => {
    const output = await captureOutput(${importName})
    expect(output).toBe(${expectedOutput})
  })`)
  }

  // Add skipped tests
  for (const test of skippedTests) {
    testCases.push(`
  it.skip('${test.name}', () => {
    // Skipped: has external imports not available in browser
  })`)
  }

  return `// Auto-generated file - DO NOT EDIT
// Generated by scripts/generate-browser-tests.ts

import { describe, it, expect } from 'vitest'

${imports.join('\n')}

// Capture console.log output from a main function
async function captureOutput(mainFn: () => Promise<void>): Promise<string> {
  const lines: string[] = []
  const originalLog = console.log

  // Override console.log to capture output
  console.log = (...args: any[]) => {
    if (args.length === 0) {
      lines.push('')
    } else {
      lines.push(args.map(formatValue).join(' '))
    }
  }

  try {
    await mainFn()
  } finally {
    console.log = originalLog
  }

  return lines.join('\\n')
}

function formatValue(v: any): string {
  if (v === null || v === undefined) return '<nil>'
  if (typeof v === 'object') {
    if (Array.isArray(v)) return '[' + v.map(formatValue).join(' ') + ']'
    if (v instanceof Map) {
      const entries = [...v.entries()].map(
        ([k, val]) => \`\${formatValue(k)}:\${formatValue(val)}\`,
      )
      return 'map[' + entries.join(' ') + ']'
    }
    return JSON.stringify(v)
  }
  return String(v)
}

describe('Compliance Tests', () => {
${testCases.join('\n')}
})
`
}

function main() {
  const tests = getTestDirs()
  console.log(`Found ${tests.length} compliance tests`)

  const content = generateTestFile(tests)
  fs.writeFileSync(outputFile, content)
  console.log(`Generated ${outputFile}`)
}

main()
