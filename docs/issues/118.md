# Issue 118: Goroutine loops can starve other goroutines

GitHub: https://github.com/aperturerobotics/goscript/issues/118

## Original Issue

Loops within goroutines can lock up threading, preventing other goroutines from executing. This is a known limitation shared with GopherJS due to how async/await works in JavaScript.

## Example

A tight loop in a goroutine will starve out other threads since JavaScript is single-threaded and async/await only yields at await points.

## Context

Reported by @grantnelson-wf:

> The threading using async and await is very good. It does lead to the same problem that GopherJS has where a loop in a thread (goroutine) could lock up threading. Here's some example code that starves out threads in both goscript and GopherJS.

## Possible Solutions

- Insert yield points in loops (performance tradeoff)
- Document as a known limitation
- Provide a runtime helper for explicit yielding

cc @grantnelson-wf

---

## Current Implementation Analysis

GoScript transpiles goroutines using `queueMicrotask(async () => { ... })`:

```typescript
// go worker(i) becomes:
queueMicrotask(async () => {
  await worker(i)
})
```

The concurrency model is **cooperative multitasking** via async/await. Execution only yields at `await` points (channel operations, select statements, etc.). A tight loop without await points blocks the JavaScript event loop entirely.

### Problem Demonstration

```go
func main() {
    go func() {
        for {
            // CPU-bound work, no channel ops
            doWork()
        }
    }()

    go func() {
        // This goroutine will NEVER run
        println("I'm starved!")
    }()

    time.Sleep(time.Second)
}
```

Transpiles to:

```typescript
queueMicrotask(async () => {
  for (;;) {
    doWork()  // Never yields!
  }
})

queueMicrotask(async () => {
  $.println("I'm starved!")  // Never executes
})
```

---

## Solution Ideas

### Idea 1: Insert yield points in all loops

**Description:** Automatically insert `await $.yield()` at the start or end of every loop body.

**Implementation:**
```typescript
// Before
for (;;) {
  doWork()
}

// After
for (;;) {
  await $.yield()
  doWork()
}
```

The `$.yield()` function would be:
```typescript
export function yield(): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, 0))
}
```

**Plusses:**
- Guarantees fairness between goroutines
- No user intervention required
- Matches Go's preemptive scheduling semantics more closely

**Minuses:**
- Significant performance overhead on ALL loops, even tight CPU-bound loops where starvation isn't a concern
- Every loop iteration incurs Promise creation + setTimeout overhead
- Breaks performance-critical code patterns
- May cause unexpected timing behavior

**Tradeoffs:**
- Correctness vs Performance: Guarantees correctness but at major performance cost
- Could use `queueMicrotask` instead of `setTimeout(0)` for lower overhead, but still significant

**Open Questions:**
- Is the performance overhead acceptable for the target use cases?
- Should this be opt-in vs opt-out?

---

### Idea 2: Insert yield points only in loops within async functions

**Description:** Since the compiler already performs "function coloring" to determine which functions are async, only insert yields in loops that are inside async-colored functions.

**Implementation:**
- During AST traversal, track whether we're inside an async function
- Only emit `await $.yield()` for loops inside async contexts

**Plusses:**
- Reduced overhead compared to Idea 1 - sync functions unaffected
- Leverages existing analysis infrastructure
- Non-async code paths remain fast

**Minuses:**
- Still significant overhead in async functions
- May not catch all starvation cases (sync helper functions called from async)
- Incomplete solution

**Tradeoffs:**
- Less overhead than universal insertion
- Still impacts async hot paths

**Open Questions:**
- Is the async context sufficient to identify starvation-prone loops?
- What about sync functions that do heavy work before an async call?

---

### Idea 3: User-controlled yielding with runtime.Gosched()

**Description:** Implement `runtime.Gosched()` as `await $.yield()` and document the limitation. Users must explicitly yield in long-running loops.

**Implementation:**
```go
// Go code
import "runtime"

for {
    doWork()
    runtime.Gosched()  // Explicit yield point
}
```

```typescript
// Generated TypeScript
for (;;) {
  doWork()
  await $.Gosched()
}
```

**Plusses:**
- No automatic overhead
- Explicit control for developers
- Matches existing Go API
- Users can optimize placement of yields
- Zero cost when not used

**Minuses:**
- Requires user awareness of the limitation
- Existing Go code may not have Gosched calls
- Easy to forget, leading to subtle bugs
- Doesn't "just work"

**Tradeoffs:**
- Puts burden on developer but gives control
- Documentation-heavy approach

**Open Questions:**
- How prominently should this limitation be documented?
- Should the compiler emit warnings for suspicious loops?

---

### Idea 4: Heuristic-based yield insertion

**Description:** Analyze loops to determine if they already have yield points (await expressions, channel operations). Only insert yields in loops that don't have any.

**Implementation:**
```go
// This loop has a yield point (channel receive)
for msg := range ch {
    process(msg)
}
// No additional yield needed

// This loop has no yield points
for i := 0; i < n; i++ {
    compute(i)
}
// Insert: await $.yield()
```

**Plusses:**
- Smart about when to yield
- Minimal overhead for well-written code
- Targets only problematic patterns

**Minuses:**
- Complex analysis required
- May miss cases (yield hidden in called function)
- Could be overly aggressive or conservative
- Harder to reason about behavior

**Tradeoffs:**
- Complexity vs correctness
- May need interprocedural analysis

**Open Questions:**
- How deep should the analysis go? Just the loop body or called functions too?
- What about loops with conditional yields?

---

### Idea 5: Web Workers for true parallelism

**Description:** Use Web Workers to run goroutines in separate threads, achieving true parallelism.

**Implementation:**
- Each goroutine runs in its own Web Worker
- Channel communication via `postMessage`
- Shared state via `SharedArrayBuffer` + `Atomics`

**Plusses:**
- True parallelism, no starvation possible
- Matches Go's threading model more closely
- Can utilize multiple CPU cores

**Minuses:**
- Major architectural change
- Web Workers can't share memory easily (no closures over variables)
- `postMessage` serialization overhead for channel ops
- `SharedArrayBuffer` has security restrictions (requires specific headers)
- Not available in all environments (older browsers, some Node.js configs)
- Significant complexity increase

**Tradeoffs:**
- Most correct solution but highest implementation cost
- Would require significant runtime redesign

**Open Questions:**
- Is the complexity worth it for the target use cases?
- How to handle closure captures across workers?
- What about environments without Web Worker support?

---

### Idea 6: Batched execution with periodic yields

**Description:** Execute N loop iterations, then yield. Amortizes yield overhead.

**Implementation:**
```typescript
let _yieldCounter = 0
for (;;) {
  if (++_yieldCounter % 1000 === 0) {
    await $.yield()
  }
  doWork()
}
```

**Plusses:**
- Amortizes yield overhead (1 yield per 1000 iterations vs every iteration)
- Prevents infinite starvation
- Reasonable performance/fairness tradeoff

**Minuses:**
- Magic number (1000) is arbitrary
- Still some overhead
- Doesn't guarantee timely yields (1000 iterations could be 1ms or 10 seconds)
- Counter variable adds complexity

**Tradeoffs:**
- Configurable N allows tuning
- Balance between overhead and responsiveness

**Open Questions:**
- What should N be? Configurable? Fixed?
- Should N be based on iteration count or elapsed time?

---

### Idea 7: Document as known limitation

**Description:** Clearly document that GoScript uses cooperative multitasking and loops must yield explicitly.

**Implementation:**
- Add prominent documentation about the limitation
- Provide examples of how to avoid starvation
- Recommend `runtime.Gosched()` for long-running loops

**Plusses:**
- No implementation complexity
- No runtime overhead
- Honest about the tradeoffs

**Minuses:**
- Doesn't fix the problem
- Users may not read documentation
- Existing Go code silently breaks

**Tradeoffs:**
- Simple but pushes burden to users

**Open Questions:**
- Is this acceptable for an experimental project?
- Should there be a linter/compiler warning?

---

## Recommended Approach

**Hybrid: Idea 3 (runtime.Gosched) + Idea 4 (heuristics) + Idea 7 (documentation)**

1. **Implement `runtime.Gosched()`** as `await $.yield()` for explicit control
2. **Add heuristic yield insertion** for loops in async functions that have no await expressions in their body
3. **Document the limitation** prominently with examples

This provides:
- Explicit control via Gosched for power users
- Automatic safety net for common cases
- Clear documentation for understanding

### Implementation Steps

1. Add `$.yield()` / `$.Gosched()` to builtin runtime
2. Modify loop code generation to detect "await-free" loops in async contexts
3. Insert `await $.yield()` at loop boundaries for such loops
4. Implement `runtime.Gosched()` support in the compiler
5. Add documentation to DESIGN.md and README
6. Add compliance tests for yielding behavior

### Open Questions for Implementation

1. Should yield insertion be configurable (compiler flag)?
2. What's the performance impact of the heuristic approach?
3. Should we emit warnings for suspicious infinite loops?
