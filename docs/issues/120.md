# Issue 120: Generic constraints have incorrect zero value

GitHub: https://github.com/aperturerobotics/goscript/issues/120

## Original Issue

Type constraints on generics that include methods are handled as interfaces, which leads to incorrect behavior when the underlying type is a primitive. The zero value becomes `null` instead of the correct zero value for the type (e.g., `0` for `int`).

## Example

https://go.dev/play/p/6FOwQVytHkH

```go
type Stringer interface {
    String() string
}

type IntVal int

func (i IntVal) String() string {
    return fmt.Sprintf("%d", i)
}

func Sum[T Stringer](vals ...T) T {
    var sum T  // Zero value - should be 0 for IntVal, but becomes null
    // ... operations on sum
    return sum
}

func main() {
    result := Sum[IntVal](1, 2, 3)
    fmt.Println(result.String())  // null dereference because sum is null, not 0
}
```

## Observed Behavior

1. The zero value `var sum T` becomes `null` instead of `0` when `T` is `IntVal`
2. Additionally, if the nil dereference is avoided, there's an error: `"Error: sum.String is not a function"`

## Expected Behavior

- Zero value should respect the underlying type (`0` for `IntVal`)
- Method resolution should work correctly on the instantiated type

## Context

Reported by @grantnelson-wf:

> The constraint has a method so it is handled as an interface but since its underlying value is an int in the instantiation with IntVal, the zero value is 0. But using interfaces, this results in a null dereference. The way Go handles this in its stenciling is using a dictionary while creating the instantiations at compile time.

> Also, I'm not sure if this is related but if the first print is removed to skip over the null dereference, I get "Error: sum.String is not a function"

cc @grantnelson-wf

---

## Current Implementation Analysis

GoScript currently handles type parameter zero values with:

```go
case *types.TypeParam:
    // For type parameters, use null with type assertion to work around TypeScript's strict checking
    c.tsw.WriteLiterally("null as any")
```

This generates:

```typescript
function Sum<T extends Stringer>(...vals: T[]): T {
  let sum: T = null as any  // WRONG for IntVal
  return sum
}
```

### The Core Problem

TypeScript generics are **erased at runtime**. There's no way to know at runtime what `T` is, so we can't determine its zero value. Go solves this with:

1. **Stenciling (Monomorphization):** Generate separate code for each instantiation (`Sum_IntVal`, `Sum_StringVal`)
2. **Dictionaries:** Pass type information at runtime that includes zero values and method implementations

Additionally, methods on primitive types don't exist in JavaScript:

```typescript
let sum: IntVal = 0  // IntVal is just number at runtime
sum.String()  // ERROR: number has no String method
```

In Go, `IntVal` is a distinct type with methods. In TypeScript, it's just `number`.

---

## Solution Ideas

### Idea 1: Full Monomorphization (Stenciling)

**Description:** Generate a separate function for each instantiation of a generic.

**Implementation:**

```go
// Go
result := Sum[IntVal](1, 2, 3)
```

Compiler detects all instantiations and generates:

```typescript
// Generated specialized version
function Sum_IntVal(...vals: IntVal[]): IntVal {
  let sum: IntVal = 0  // Correct zero value!
  for (const v of vals) {
    sum = sum + v as IntVal
  }
  return sum
}

// Call site
let result = Sum_IntVal(1, 2, 3)
```

**Plusses:**
- Correct zero values for every type
- Method dispatch works correctly
- Can optimize for specific types
- No runtime overhead

**Minuses:**
- Code bloat (N instantiations = N copies)
- Loses TypeScript generic benefits
- Complex implementation (need to track all instantiations)
- Can't handle truly polymorphic code (generics in libraries)

**Tradeoffs:**
- Correctness at cost of code size
- Essentially what Go does internally

**Open Questions:**
- How to handle generics across package boundaries?
- What about recursive/mutual generic instantiations?
- Can we share common code between instantiations?

---

### Idea 2: Runtime type dictionary parameter

**Description:** Pass a type dictionary to generic functions that provides zero values and method implementations.

**Implementation:**

```typescript
// Type dictionary interface
interface TypeDict<T> {
  zero(): T
  methods: Record<string, (receiver: T, ...args: any[]) => any>
}

// IntVal dictionary
const IntValDict: TypeDict<number> = {
  zero: () => 0,
  methods: {
    String: (i: number) => i.toString()
  }
}

// Generic function with dict parameter
function Sum<T>($T: TypeDict<T>, ...vals: T[]): T {
  let sum: T = $T.zero()  // Correct zero value!
  for (const v of vals) {
    // sum += v would need dict support too
  }
  return sum
}

// Call site
let result = Sum(IntValDict, 1, 2, 3)
```

**Method calls via dictionary:**

```typescript
// Before: result.String()
// After:
$T.methods.String(result)
```

**Plusses:**
- Correct zero values
- Method dispatch works
- Single generic implementation
- Flexible and extensible

**Minuses:**
- Changes calling convention (extra parameter)
- Overhead of dictionary creation and lookup
- All generic call sites need dictionaries
- Dictionaries must be passed through call chains

**Tradeoffs:**
- Runtime cost vs correctness
- API changes for all generic functions

**Open Questions:**
- How to auto-generate dictionaries at call sites?
- Dictionary passing through higher-order functions?
- Generic types (not just functions)?

---

### Idea 3: Zero value factory parameter

**Description:** Simpler version of Idea 2 - just pass a zero value factory.

**Implementation:**

```typescript
function Sum<T>(_zeroT: () => T, ...vals: T[]): T {
  let sum: T = _zeroT()
  // ...
  return sum
}

// Call site
let result = Sum(() => 0 as IntVal, 1, 2, 3)
```

**Plusses:**
- Simpler than full dictionary
- Solves zero value problem
- Minimal runtime overhead

**Minuses:**
- Doesn't solve method dispatch problem
- Still changes calling convention
- Extra parameter clutter

**Tradeoffs:**
- Partial solution
- Simpler but incomplete

**Open Questions:**
- How to combine with method dispatch solution?
- Generate factory automatically at call sites?

---

### Idea 4: Wrapper types for primitives with methods

**Description:** When a type alias adds methods to a primitive, generate a wrapper class.

**Implementation:**

```typescript
// type IntVal int with String() method
class IntVal {
  constructor(public $value: number = 0) {}

  String(): string {
    return this.$value.toString()
  }

  // Arithmetic operations
  static add(a: IntVal, b: IntVal): IntVal {
    return new IntVal(a.$value + b.$value)
  }
}

// Zero value
let sum: IntVal = new IntVal()  // $value = 0

// Method works!
sum.String()
```

**Plusses:**
- Methods work correctly
- Zero values correct
- Type safety preserved
- Matches Go's type semantics

**Minuses:**
- Boxing overhead for all values
- Need to wrap/unwrap at boundaries
- Arithmetic needs special handling
- Comparison needs special handling

**Tradeoffs:**
- More correct but more overhead
- Changes how primitive-based types work

**Open Questions:**
- When to wrap vs unwrap?
- Interop with plain JavaScript numbers?
- Performance impact of boxing?

---

### Idea 5: Hybrid - Wrapper types + Type dictionary

**Description:** Combine wrapper types for defined types with dictionaries for generic dispatch.

**Implementation:**

```typescript
// IntVal as wrapper class
class IntVal {
  static $typeInfo: TypeDict<IntVal> = {
    zero: () => new IntVal(0),
    methods: {
      String: (i: IntVal) => i.String()
    }
  }

  constructor(public $value: number = 0) {}
  String(): string { return this.$value.toString() }
}

// Generic function
function Sum<T>($T: TypeDict<T>, ...vals: T[]): T {
  let sum: T = $T.zero()
  // ...
  return sum
}

// Call site - compiler generates dict reference
let result = Sum(IntVal.$typeInfo, new IntVal(1), new IntVal(2))
```

**Plusses:**
- Complete solution
- Clean separation of concerns
- Types carry their own info
- Scalable to complex cases

**Minuses:**
- Wrapper overhead
- Dictionary passing overhead
- Complex implementation
- Significant code changes

**Tradeoffs:**
- Most complete but most complex

**Open Questions:**
- Can we optimize away wrappers in some cases?
- How to handle built-in types?

---

### Idea 6: Constraint-based zero value inference

**Description:** At compile time, analyze the constraint to determine possible zero values and generate conditional code.

**Implementation:**

If constraint is interface-only:
```typescript
function Sum<T extends Stringer>(...vals: T[]): T {
  // At call site, compiler knows T = IntVal, so generates:
  let sum: T = 0 as unknown as T  // Inferred from instantiation
  return sum
}
```

For each call site, specialize the zero value:
```typescript
// Sum[IntVal](1, 2, 3) generates:
let result = ((function Sum<T extends Stringer>(...vals: T[]): T {
  let sum: T = 0 as unknown as T  // Specialized!
  return sum
})<IntVal>)(1, 2, 3)
```

**Plusses:**
- No calling convention changes
- Can optimize based on known types
- Compile-time analysis

**Minuses:**
- Only works when instantiation is known at compile time
- Doesn't help with generic libraries
- Complex analysis required
- Doesn't solve method dispatch

**Tradeoffs:**
- Limited but non-invasive

**Open Questions:**
- What about cross-package generics?
- Runtime-determined type parameters?

---

### Idea 7: Interface-based method dispatch for all method-having types

**Description:** Treat all types with methods as implementing interfaces, and use interface dispatch.

**Implementation:**

Building on Issue 119's interface wrapper:

```typescript
// IntVal with methods is treated like an interface implementer
let intVal = $.makeTypedValue('main.IntVal', 42)

// Method call goes through dispatch
$.callMethod(intVal, 'String')  // Looks up IntVal.String, calls with 42
```

For generics:
```typescript
function Sum<T extends Stringer>(...vals: GoTypedValue<T>[]): GoTypedValue<T> {
  let sum = $.zeroValueForType<T>()  // Runtime lookup
  // ...
  return sum
}
```

**Plusses:**
- Unified approach with interfaces
- Runtime type info available
- Methods work correctly

**Minuses:**
- Requires boxing all values
- Performance overhead
- Big architectural change

**Tradeoffs:**
- Consistent but costly

**Open Questions:**
- Too much boxing overhead?
- Can we share infrastructure with Issue 119?

---

## Recommended Approach

**Idea 5 (Hybrid: Wrapper types + Type dictionary) with optimization passes**

This provides complete correctness while allowing optimization.

### Core Design

#### 1. Named types with methods become classes

```go
type IntVal int

func (i IntVal) String() string {
    return fmt.Sprintf("%d", i)
}
```

Becomes:

```typescript
class IntVal {
  static readonly $typeName = 'main.IntVal'
  static readonly $underlying = 'int'
  static readonly $zeroValue = () => new IntVal(0)

  constructor(public $value: number = 0) {}

  String(): string {
    return this.$value.toString()
  }

  // Enable arithmetic: IntVal + IntVal
  static $add(a: IntVal, b: IntVal): IntVal {
    return new IntVal(a.$value + b.$value)
  }

  // Conversion from number
  static from(n: number): IntVal {
    return new IntVal(n)
  }

  // Conversion to number
  valueOf(): number {
    return this.$value
  }
}
```

#### 2. Type dictionary for generic dispatch

```typescript
interface TypeInfo<T> {
  typeName: string
  zeroValue: () => T
  // For types with methods:
  methods?: Record<string, Function>
  // For operations:
  add?: (a: T, b: T) => T
  compare?: (a: T, b: T) => number
}

// Auto-generated for IntVal
const IntVal$info: TypeInfo<IntVal> = {
  typeName: 'main.IntVal',
  zeroValue: () => new IntVal(0),
  methods: {
    String: (i: IntVal) => i.String()
  },
  add: IntVal.$add
}
```

#### 3. Generic functions receive type info

```go
func Sum[T Stringer](vals ...T) T {
    var sum T
    // ...
    return sum
}
```

Becomes:

```typescript
function Sum<T extends Stringer>($T: TypeInfo<T>, ...vals: T[]): T {
  let sum: T = $T.zeroValue()
  // ...
  return sum
}
```

#### 4. Call sites pass type info

```go
result := Sum[IntVal](1, 2, 3)
```

Becomes:

```typescript
let result = Sum(IntVal$info, IntVal.from(1), IntVal.from(2), IntVal.from(3))
```

### Optimization Opportunities

1. **Inline for known types:** If instantiation is known, inline the type info
2. **Skip boxing for no-method types:** Plain type aliases don't need wrapper classes
3. **Primitive fast paths:** For `comparable` constraint with primitives, use `===`
4. **DCE for unused methods:** Dead code eliminate unused method wrappers

### Implementation Steps

1. **Phase 1: Wrapper types for types with methods**
   - Detect type definitions that add methods to primitives
   - Generate class wrappers with `$value` field
   - Generate static operations (`$add`, `$sub`, etc.)
   - Update type conversion handling

2. **Phase 2: Type info generation**
   - Generate `TypeInfo` objects for all named types
   - Include zero value factories
   - Include method tables for types with methods

3. **Phase 3: Generic function transformation**
   - Add `$T: TypeInfo<T>` parameter to generic functions
   - Replace `null as any` zero values with `$T.zeroValue()`
   - Replace method calls with `$T.methods.X()` or direct calls

4. **Phase 4: Call site transformation**
   - At each generic instantiation, pass appropriate `TypeInfo`
   - Handle nested generics (type info propagation)

5. **Phase 5: Testing and optimization**
   - Add compliance tests
   - Benchmark performance
   - Add optimization passes

### Method Call Resolution

For `sum.String()` where `sum: T`:

**Option A: Direct call if we know it's a class**
```typescript
sum.String()  // Works if sum is IntVal instance
```

**Option B: Dictionary dispatch**
```typescript
$T.methods!.String(sum)
```

**Option C: Conditional**
```typescript
typeof sum.String === 'function' ? sum.String() : $T.methods!.String(sum)
```

### Open Questions for Implementation

1. **Arithmetic on generic types:** How to handle `sum += v` where `T` is `IntVal`?
   - Need operator overloading or dictionary-based operations

2. **Comparisons:** How to handle `==` and `<` for generic types?
   - Dictionary-based or interface-based comparison

3. **Conversion at boundaries:** When to wrap/unwrap primitives?
   - Need clear rules for function parameters and returns

4. **Package boundaries:** How to access `TypeInfo` for external types?
   - Export from defining package, import where needed

5. **Recursive generics:** `type List[T any] struct { val T; next *List[T] }`
   - Type info needs to handle recursive types

6. **Generic methods:** `func (l List[T]) Map[U any](f func(T) U) List[U]`
   - Multiple type parameters with different dictionaries

7. **Interaction with Issue 119:** How do interfaces and generics interact?
   - Interface with generic type parameter
   - Generic function returning interface
