# Issue 119: Non-nil interface with nil value not handled

GitHub: https://github.com/aperturerobotics/goscript/issues/119

## Original Issue

GoScript treats Go interfaces like TypeScript interfaces, but in Go, interfaces are actually objects with both a type and a value. This means it's possible to have a non-nil interface that points to a nil value.

Go allows a nil value to be used as a nil receiver in a method call - the type determines which method implementation to call, then the receiver (nil or not) is passed in.

## Example

https://go.dev/play/p/QgBenURyzlF

```go
type Animal interface {
    Name() string
}

type Dog struct{}
type Cat struct{}

func (d *Dog) Name() string {
    if d == nil {
        return "unknown dog"
    }
    return "Fido"
}

func (c *Cat) Name() string {
    if c == nil {
        return "unknown cat"
    }
    return "Whiskers"
}

func FindDog() *Dog { return nil }
func FindCat() *Cat { return &Cat{} }

func FindAnimal() Animal {
    if dog := Animal(FindDog()); dog != nil {
        // BUG: This branch is ALWAYS taken!
        // The interface is non-nil (has type *Dog) even though the value is nil
        return dog
    }
    return FindCat()
}
```

In this example, `Animal(FindDog())` creates a non-nil interface (it has type `*Dog`) even though the underlying value is nil. The `if dog != nil` check passes, and `FindCat()` is never called.

## Expected Behavior

GoScript should track both the type and value of interfaces, allowing:
1. Correct nil checks on interfaces (nil interface vs non-nil interface with nil value)
2. Method calls on nil receivers to work correctly

## Context

Reported by @grantnelson-wf:

> GoScript treats Go interfaces like TS interfaces, but in Go interfaces are actually objects with a type and value. So it is possible to have a non-nil interface that points to a nil value (It's annoying but possible).

cc @grantnelson-wf

---

## Current Implementation Analysis

GoScript currently transpiles interfaces as TypeScript union types:

```typescript
// Go: type Animal interface { Name() string }
export type Animal = null | {
  Name(): string
}
```

Interface values are either `null` (nil interface) or an object with the required methods.

### The Problem

In Go, an interface is a "fat pointer" containing two components:
1. **Type** - A pointer to the concrete type's method table
2. **Value** - A pointer to the actual data

An interface is nil **only if both components are nil**. If you assign a typed nil pointer to an interface, the interface is NOT nil - it has a type but a nil value.

```go
var dog *Dog = nil
var animal Animal = dog
// animal != nil is TRUE in Go!
// animal has type=*Dog, value=nil
```

Currently GoScript would make `animal = null` because the underlying value is nil, which is incorrect.

### Method Calls on Nil Receivers

Go allows method calls on nil receivers:

```go
func (d *Dog) Name() string {
    if d == nil {
        return "unknown dog"  // This works!
    }
    return d.name
}

var dog *Dog = nil
dog.Name()  // Returns "unknown dog"
```

This works because Go knows the type (`*Dog`) so it can find the method. The nil pointer is passed as the receiver.

In TypeScript, calling `null.Name()` would crash. We need to know the type to dispatch the method.

---

## Solution Ideas

### Idea 1: Interface wrapper class

**Description:** Represent interfaces as wrapper objects that carry both type and value.

**Implementation:**

```typescript
// Runtime type
class GoInterface<T = any> {
  constructor(
    public readonly typeName: string | null,  // null = nil interface
    public readonly value: T | null
  ) {}

  isNil(): boolean {
    return this.typeName === null
  }

  // Get method implementation for dispatch
  getMethod(name: string): Function | null {
    if (this.typeName === null) return null
    return $.getMethodForType(this.typeName, name)
  }
}

// Usage
let animal: GoInterface<Animal> = new GoInterface('*Dog', null)
if (!animal.isNil()) {  // true - interface is not nil
  // Dispatch method via type, passing value as receiver
  animal.getMethod('Name')?.call(animal.value)
}
```

**Interface assignment:**
```typescript
// var animal Animal = dog
let animal = new GoInterface('*Dog', dog)

// var animal Animal = nil
let animal = new GoInterface(null, null)
```

**Plusses:**
- Correctly models Go's interface semantics
- Clear separation of type and value
- Enables method dispatch on nil receivers
- Single source of truth for interface behavior

**Minuses:**
- Performance overhead (object allocation for every interface value)
- Changes all interface handling throughout the compiler
- More complex generated code
- Breaks existing type assertions

**Tradeoffs:**
- Correctness vs performance
- Major refactor vs living with the bug

**Open Questions:**
- How significant is the performance impact?
- Can we optimize common cases (non-nil values)?
- How does this interact with type assertions?

---

### Idea 2: Boxed interface with type tag

**Description:** Use a simpler boxing approach with just a type tag.

**Implementation:**

```typescript
// Runtime helper
interface BoxedInterface<T = any> {
  $type: string | null  // null = nil interface
  $value: T | null
}

function boxInterface<T>(typeName: string | null, value: T | null): BoxedInterface<T> {
  return { $type: typeName, $value: value }
}

function isNilInterface(i: BoxedInterface<any>): boolean {
  return i.$type === null
}
```

**Generated code:**
```typescript
// var animal Animal = dog
let animal = $.boxInterface('*Dog', dog)

// if animal != nil
if (!$.isNilInterface(animal)) { ... }

// animal.Name()
$.callInterfaceMethod(animal, 'Name')
```

**Plusses:**
- Simpler than full class approach
- Plain objects (may be faster than class instances)
- Clear type/value separation

**Minuses:**
- Still requires object allocation
- All interface operations need runtime helpers
- Changes all interface code paths

**Tradeoffs:**
- Slightly simpler than Idea 1
- Similar trade-offs otherwise

**Open Questions:**
- Object literal vs class instance performance?
- How to handle interface embedding?

---

### Idea 3: Type-tagged values with method tables

**Description:** Store method implementations with the interface value for dispatch.

**Implementation:**

```typescript
interface InterfaceValue<T = any> {
  $methods: Record<string, Function>  // Method table
  $value: T | null
}

function makeInterfaceValue<T>(
  methods: Record<string, Function>,
  value: T | null
): InterfaceValue<T> {
  return { $methods: methods, $value: value }
}

// Method call
function callMethod<T, R>(
  iface: InterfaceValue<T> | null,
  method: string,
  ...args: any[]
): R {
  if (iface === null) {
    throw new Error("nil interface")
  }
  return iface.$methods[method].call(iface.$value, ...args)
}
```

**Plusses:**
- Method dispatch doesn't need global lookup
- Self-contained interface values
- Fast method access

**Minuses:**
- Larger memory footprint (method table per value)
- Method tables need to be built at assignment time
- Complex for interfaces with many methods

**Tradeoffs:**
- Faster dispatch vs higher memory usage
- More work at interface assignment time

**Open Questions:**
- Share method tables between values of same type?
- How to handle interface composition?

---

### Idea 4: Tuple representation [type, value]

**Description:** Represent interfaces as tuples for minimal overhead.

**Implementation:**

```typescript
type InterfaceValue<T = any> = [string | null, T | null]

// var animal Animal = dog
let animal: InterfaceValue<Dog> = ['*Dog', dog]

// nil interface
let nilAnimal: InterfaceValue<any> = [null, null]

// nil check
if (animal[0] !== null) { ... }

// method call
$.dispatchMethod(animal[0], animal[1], 'Name')
```

**Plusses:**
- Minimal memory overhead (just array)
- Fast access (index vs property)
- Simple to understand

**Minuses:**
- Less readable generated code
- Still needs method dispatch infrastructure
- Array destructuring everywhere

**Tradeoffs:**
- Compact but less ergonomic
- Performance may not differ much from object

**Open Questions:**
- Is tuple notation confusing in generated code?
- TypeScript tuple type inference challenges?

---

### Idea 5: Nil-receiver-safe method wrappers

**Description:** Instead of changing interface representation, generate method wrappers that handle nil receivers.

**Implementation:**

For each method that might be called on a nil receiver, generate a wrapper:

```typescript
// Original method
Dog.prototype.Name = function(this: Dog | null): string {
  if (this === null) {
    return "unknown dog"
  }
  return this.name
}

// Wrapper for nil-safe dispatch
function Dog_Name(receiver: Dog | null): string {
  // Can be called even when receiver is null
  return Dog.prototype.Name.call(receiver)
}
```

**Interface values carry type info:**
```typescript
// When assigning to interface, wrap with type
let animal = $.wrapInterface('*Dog', dogValue)  // { $type: '*Dog', $value: dogValue }
```

**Plusses:**
- Methods themselves handle nil
- Can optimize for non-nil cases
- Gradual migration possible

**Minuses:**
- Need to generate wrappers for all methods
- Still need type info for dispatch
- Doesn't solve the nil interface check problem alone

**Tradeoffs:**
- Partial solution, needs combination with type tracking

**Open Questions:**
- Which methods need nil-safe wrappers?
- Performance of `Function.prototype.call`?

---

### Idea 6: Differentiated nil types

**Description:** Use different representations for nil interface vs non-nil interface with nil value.

**Implementation:**

```typescript
// Nil interface
const NIL_INTERFACE = Symbol('nil_interface')
type NilInterface = typeof NIL_INTERFACE

// Non-nil interface with nil value
interface TypedNil {
  $type: string
  $value: null
}

// Regular interface value
interface InterfaceValue<T> {
  $type: string
  $value: T
}

type Interface<T> = NilInterface | TypedNil | InterfaceValue<T>

function isNilInterface(i: Interface<any>): boolean {
  return i === NIL_INTERFACE
}
```

**Plusses:**
- Clear distinction between nil states
- Symbol comparison is fast
- Can optimize common cases

**Minuses:**
- Still need boxing for non-nil cases
- Three-way type checking
- Complex type unions

**Tradeoffs:**
- Explicit about the different nil states
- Symbol makes nil interface check fast

**Open Questions:**
- Is Symbol compatible across all target environments?
- How does this affect type assertions?

---

## Recommended Approach

**Idea 2 (Boxed interface with type tag) with optimizations**

The boxed interface approach provides the right semantics while being relatively simple to implement.

### Core Design

```typescript
// Runtime types in builtin
interface GoInterface<T = any> {
  $type: string | null  // Fully qualified type name, null = nil interface
  $value: T | null
}

// Nil interface constant
const NIL_INTERFACE: GoInterface<never> = { $type: null, $value: null }

// Create interface value
function makeInterface<T>(typeName: string, value: T | null): GoInterface<T> {
  return { $type: typeName, $value: value }
}

// Check if interface is nil (type is null)
function isNilInterface(i: GoInterface<any> | null): boolean {
  return i === null || i.$type === null
}

// Call method on interface value
function callInterfaceMethod<R>(
  iface: GoInterface<any>,
  methodName: string,
  ...args: any[]
): R {
  if (iface.$type === null) {
    panic("nil interface method call")
  }
  const method = getMethodForType(iface.$type, methodName)
  return method.call(iface.$value, ...args)
}
```

### Compiler Changes

1. **Interface type representation:**
   - Change from `null | { methods }` to `GoInterface<{ methods }>`
   - Or keep structural type but use `GoInterface` wrapper at runtime

2. **Interface assignment:**
   ```go
   var animal Animal = dog
   ```
   Becomes:
   ```typescript
   let animal = $.makeInterface('*main.Dog', dog)
   ```

3. **Nil interface:**
   ```go
   var animal Animal = nil
   ```
   Becomes:
   ```typescript
   let animal = $.NIL_INTERFACE
   ```

4. **Nil check on interface:**
   ```go
   if animal != nil { ... }
   ```
   Becomes:
   ```typescript
   if (!$.isNilInterface(animal)) { ... }
   ```

5. **Method call on interface:**
   ```go
   animal.Name()
   ```
   Becomes:
   ```typescript
   $.callInterfaceMethod(animal, 'Name')
   ```

6. **Type assertion:**
   ```go
   dog, ok := animal.(*Dog)
   ```
   Becomes:
   ```typescript
   let { value: dog, ok } = $.typeAssertInterface(animal, '*main.Dog')
   ```

### Optimization Opportunities

1. **Fast path for concrete types:** When assigning a known non-nil value, skip the full boxing
2. **Inline nil checks:** `!$.isNilInterface(x)` could inline to `x.$type !== null`
3. **Method caching:** Cache method lookups by type name
4. **Avoid boxing for local variables:** If an interface never escapes and is always non-nil, skip boxing

### Implementation Steps

1. Add `GoInterface` type and helpers to `gs/builtin/type.ts`
2. Modify `WriteTypeExpr` for interface types
3. Modify interface assignment code generation
4. Modify nil comparison for interface types
5. Modify interface method call generation
6. Update type assertion handling
7. Add compliance tests for nil interface semantics
8. Update existing tests for new interface representation

### Open Questions for Implementation

1. How to handle embedded interfaces in structs?
2. Should interface fields in structs also be boxed?
3. Performance benchmarking needed to validate approach
4. How does this interact with generic type parameters?
5. What about interfaces stored in maps/slices?
