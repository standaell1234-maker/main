[
  {
    "name": "array_literal",
    "goCode": "package main\n\nfunc main() {\n\t// Test basic array literal\n\tvar a [3]int = [3]int{1, 2, 3} //nolint:staticcheck\n\tprintln(a[0], a[1], a[2])\n\n\t// Test array literal with inferred length\n\tb := [...]string{\"hello\", \"world\"}\n\tprintln(b[0], b[1])\n\n\t// Test array literal with specific element initialization\n\tc := [5]int{1: 10, 3: 30}\n\tprintln(c[0], c[1], c[2], c[3], c[4])\n}\n",
    "tsCode": "// Generated file based on array_literal.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test basic array literal\n\t//nolint:staticcheck\n\tlet a = $.arrayToSlice<number>([1, 2, 3])\n\t$.println(a![0], a![1], a![2])\n\n\t// Test array literal with inferred length\n\tlet b = $.arrayToSlice<string>([\"hello\", \"world\"])\n\t$.println(b![0], b![1])\n\n\t// Test array literal with specific element initialization\n\tlet c = $.arrayToSlice<number>([0, 10, 0, 30, 0])\n\t$.println(c![0], c![1], c![2], c![3], c![4])\n}\n\n",
    "expectedOutput": "1 2 3\nhello world\n0 10 0 30 0"
  },
  {
    "name": "assign_op",
    "goCode": "package main\n\nfunc main() {\n\tvar a int = 5\n\ta += 3\n\tprintln(a) // Expected output: 8\n\n\tvar b int = 10\n\tb -= 2\n\tprintln(b) // Expected output: 8\n\n\tvar c int = 16\n\tc /= 4\n\tprintln(c) // Expected output: 4\n\n\tvar d int = 3\n\td *= 5\n\tprintln(d) // Expected output: 15\n\n\tvar e int = 10\n\te %= 3\n\tprintln(e) // Expected output: 1\n\n\tvar f int = 5\n\tf &= 3     // 101 & 011 = 001\n\tprintln(f) // Expected output: 1\n\n\tvar g int = 5\n\tg |= 3     // 101 | 011 = 111\n\tprintln(g) // Expected output: 7\n\n\tvar h int = 5\n\th ^= 3     // 101 ^ 011 = 110\n\tprintln(h) // Expected output: 6\n\n\t// This operation is not yet supported.\n\t// var i int = 5\n\t// i &^= 3    // 101 &^ 011 = 101 & (~011) = 101 & 100 = 100\n\t// println(i) // Expected output: 4\n\n\tvar j int = 5\n\tj <<= 1    // 101 << 1 = 1010\n\tprintln(j) // Expected output: 10\n\n\tvar k int = 5\n\tk >>= 1    // 101 >> 1 = 010\n\tprintln(k) // Expected output: 2\n}\n",
    "tsCode": "// Generated file based on assign_op.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet a: number = 5\n\ta += 3\n\t$.println(a) // Expected output: 8\n\n\tlet b: number = 10\n\tb -= 2\n\t$.println(b) // Expected output: 8\n\n\tlet c: number = 16\n\tc = Math.trunc(c / 4)\n\t$.println(c) // Expected output: 4\n\n\tlet d: number = 3\n\td *= 5\n\t$.println(d) // Expected output: 15\n\n\tlet e: number = 10\n\te %= 3\n\t$.println(e) // Expected output: 1\n\n\tlet f: number = 5\n\tf &= 3 // 101 & 011 = 001\n\t$.println(f) // Expected output: 1\n\n\tlet g: number = 5\n\tg |= 3 // 101 | 011 = 111\n\t$.println(g) // Expected output: 7\n\n\tlet h: number = 5\n\th ^= 3 // 101 ^ 011 = 110\n\t$.println(h) // Expected output: 6\n\n\t// This operation is not yet supported.\n\t// var i int = 5\n\t// i &^= 3    // 101 &^ 011 = 101 & (~011) = 101 & 100 = 100\n\t// println(i) // Expected output: 4\n\n\tlet j: number = 5\n\tj <<= 1 // 101 << 1 = 1010\n\t$.println(j) // Expected output: 10\n\n\tlet k: number = 5\n\tk >>= 1 // 101 >> 1 = 010\n\t$.println(k) // Expected output: 2\n}\n\n",
    "expectedOutput": "8\n8\n4\n15\n1\n1\n7\n6\n10\n2"
  },
  {
    "name": "async_basic",
    "goCode": "package main\n\n// This function receives from a channel, making it async.\nfunc receiveFromChan(ch chan int) int {\n\tval := <-ch // This operation makes the function async\n\treturn val\n}\n\n// This function calls an async function, making it async too.\nfunc caller(ch chan int) int {\n\t// We expect this call to be awaited in TypeScript\n\tresult := receiveFromChan(ch)\n\treturn result + 1\n}\n\nfunc main() {\n\t// Create a buffered channel\n\tmyChan := make(chan int, 1)\n\tmyChan <- 10 // Send a value\n\n\t// Call the async caller function\n\tfinalResult := caller(myChan)\n\tprintln(finalResult) // Expected output: 11\n\n\tclose(myChan)\n}\n",
    "tsCode": "// Generated file based on async_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\n// This function receives from a channel, making it async.\nexport async function receiveFromChan(ch: $.Channel<number> | null): Promise<number> {\n\tlet val = await $.chanRecv(ch) // This operation makes the function async\n\treturn val\n}\n\n// This function calls an async function, making it async too.\nexport async function caller(ch: $.Channel<number> | null): Promise<number> {\n\t// We expect this call to be awaited in TypeScript\n\tlet result = await receiveFromChan(ch)\n\treturn result + 1\n}\n\nexport async function main(): Promise<void> {\n\t// Create a buffered channel\n\tlet myChan = $.makeChannel<number>(1, 0, 'both')\n\tawait $.chanSend(myChan, 10)\n\n\t// Call the async caller function\n\tlet finalResult = await caller(myChan)\n\t$.println(finalResult) // Expected output: 11\n\n\tmyChan.close()\n}\n\n",
    "expectedOutput": "11"
  },
  {
    "name": "async_call_in_return",
    "goCode": "package main\n\nimport (\n\t\"sync\"\n)\n\nvar cache sync.Map\n\nfunc getFromCache(key string) (interface{}, bool) {\n\tval, ok := cache.Load(key)\n\treturn val, ok\n}\n\nfunc getFromCacheInline(key string) (interface{}, bool) {\n\treturn cache.Load(key)\n}\n\nfunc main() {\n\tcache.Store(\"test\", 42)\n\n\tval1, ok1 := getFromCache(\"test\")\n\tif ok1 {\n\t\tprintln(\"getFromCache found:\", val1.(int))\n\t}\n\n\tval2, ok2 := getFromCacheInline(\"test\")\n\tif ok2 {\n\t\tprintln(\"getFromCacheInline found:\", val2.(int))\n\t}\n\n\t_, ok3 := getFromCache(\"missing\")\n\tif !ok3 {\n\t\tprintln(\"Not found as expected\")\n\t}\n}\n",
    "tsCode": "// Generated file based on async_call_in_return.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as sync from \"@goscript/sync/index.js\"\n\nexport let cache: $.VarRef<sync.Map> = $.varRef(new sync.Map())\n\nexport async function getFromCache(key: string): Promise<[null | any, boolean]> {\n\tlet [val, ok] = await cache!.value.Load(key)\n\treturn [val, ok]\n}\n\nexport async function getFromCacheInline(key: string): Promise<[null | any, boolean]> {\n\treturn await cache!.value.Load(key)\n}\n\nexport async function main(): Promise<void> {\n\tawait cache!.value.Store(\"test\", 42)\n\n\tlet [val1, ok1] = await getFromCache(\"test\")\n\tif (ok1) {\n\t\t$.println(\"getFromCache found:\", $.mustTypeAssert<number>(val1, {kind: $.TypeKind.Basic, name: 'number'}))\n\t}\n\n\tlet [val2, ok2] = await getFromCacheInline(\"test\")\n\tif (ok2) {\n\t\t$.println(\"getFromCacheInline found:\", $.mustTypeAssert<number>(val2, {kind: $.TypeKind.Basic, name: 'number'}))\n\t}\n\n\tlet [, ok3] = await getFromCache(\"missing\")\n\tif (!ok3) {\n\t\t$.println(\"Not found as expected\")\n\t}\n}\n\n",
    "expectedOutput": "getFromCache found: 42\ngetFromCacheInline found: 42\nNot found as expected\n"
  },
  {
    "name": "async_defer_statement",
    "goCode": "package main\n\nfunc main() {\n\tch := make(chan bool, 1)\n\n\tdefer func() {\n\t\tprintln(\"deferred start\")\n\t\t<-ch // Wait for signal from main\n\t\tprintln(\"deferred end\")\n\t}()\n\n\tprintln(\"main start\")\n\tprintln(\"main signaling defer\")\n\tch <- true // Signal the deferred function\n\tprintln(\"main end\")\n}\n",
    "tsCode": "// Generated file based on async_defer_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tawait using __defer = new $.AsyncDisposableStack();\n\tlet ch = $.makeChannel<boolean>(1, false, 'both')\n\n\t// Wait for signal from main\n\t__defer.defer(async () => {\n\t\t$.println(\"deferred start\")\n\t\tawait $.chanRecv(ch)\n\t\t$.println(\"deferred end\")\n\t});\n\n\t$.println(\"main start\")\n\t$.println(\"main signaling defer\")\n\tawait $.chanSend(ch, true)\n\t$.println(\"main end\")\n}\n\n",
    "expectedOutput": "main start\nmain signaling defer\nmain end\ndeferred start\ndeferred end"
  },
  {
    "name": "atomic_struct_field_init",
    "goCode": "package main\n\nimport \"sync/atomic\"\n\ntype MyStruct struct {\n\tclosed atomic.Bool\n\tcount  atomic.Int32\n\tflag   atomic.Uint32\n}\n\nfunc main() {\n\t// Test struct initialization with atomic fields\n\ts := MyStruct{}\n\n\t// Test that the atomic fields work correctly\n\ts.closed.Store(true)\n\ts.count.Store(42)\n\ts.flag.Store(100)\n\n\tprintln(\"closed:\", s.closed.Load())\n\tprintln(\"count:\", s.count.Load())\n\tprintln(\"flag:\", s.flag.Load())\n\n\t// Test struct initialization with init values\n\ts2 := MyStruct{\n\t\tclosed: atomic.Bool{},\n\t\tcount:  atomic.Int32{},\n\t\tflag:   atomic.Uint32{},\n\t}\n\n\ts2.closed.Store(false)\n\ts2.count.Store(24)\n\ts2.flag.Store(50)\n\n\tprintln(\"s2 closed:\", s2.closed.Load())\n\tprintln(\"s2 count:\", s2.count.Load())\n\tprintln(\"s2 flag:\", s2.flag.Load())\n\n\tprintln(\"atomic struct field test finished\")\n}\n",
    "tsCode": "// Generated file based on atomic_struct_field_init.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as atomic from \"@goscript/sync/atomic/index.js\"\n\nexport class MyStruct {\n\tpublic get closed(): atomic.Bool {\n\t\treturn this._fields.closed.value\n\t}\n\tpublic set closed(value: atomic.Bool) {\n\t\tthis._fields.closed.value = value\n\t}\n\n\tpublic get count(): atomic.Int32 {\n\t\treturn this._fields.count.value\n\t}\n\tpublic set count(value: atomic.Int32) {\n\t\tthis._fields.count.value = value\n\t}\n\n\tpublic get flag(): atomic.Uint32 {\n\t\treturn this._fields.flag.value\n\t}\n\tpublic set flag(value: atomic.Uint32) {\n\t\tthis._fields.flag.value = value\n\t}\n\n\tpublic _fields: {\n\t\tclosed: $.VarRef<atomic.Bool>;\n\t\tcount: $.VarRef<atomic.Int32>;\n\t\tflag: $.VarRef<atomic.Uint32>;\n\t}\n\n\tconstructor(init?: Partial<{closed?: atomic.Bool, count?: atomic.Int32, flag?: atomic.Uint32}>) {\n\t\tthis._fields = {\n\t\t\tclosed: $.varRef(init?.closed ? $.markAsStructValue(init.closed.clone()) : new atomic.Bool()),\n\t\t\tcount: $.varRef(init?.count ? $.markAsStructValue(init.count.clone()) : new atomic.Int32()),\n\t\t\tflag: $.varRef(init?.flag ? $.markAsStructValue(init.flag.clone()) : new atomic.Uint32())\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tclosed: $.varRef($.markAsStructValue(this._fields.closed.value.clone())),\n\t\t\tcount: $.varRef($.markAsStructValue(this._fields.count.value.clone())),\n\t\t\tflag: $.varRef($.markAsStructValue(this._fields.flag.value.clone()))\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"closed\": \"Bool\", \"count\": \"Int32\", \"flag\": \"Uint32\"}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Test struct initialization with atomic fields\n\tlet s = $.markAsStructValue(new MyStruct({}))\n\n\t// Test that the atomic fields work correctly\n\ts.closed.Store(true)\n\ts.count.Store(42)\n\ts.flag.Store(100)\n\n\t$.println(\"closed:\", s.closed.Load())\n\t$.println(\"count:\", s.count.Load())\n\t$.println(\"flag:\", s.flag.Load())\n\n\t// Test struct initialization with init values\n\tlet s2 = $.markAsStructValue(new MyStruct({closed: $.markAsStructValue(new atomic.Bool({})), count: $.markAsStructValue(new atomic.Int32({})), flag: $.markAsStructValue(new atomic.Uint32({}))}))\n\n\ts2.closed.Store(false)\n\ts2.count.Store(24)\n\ts2.flag.Store(50)\n\n\t$.println(\"s2 closed:\", s2.closed.Load())\n\t$.println(\"s2 count:\", s2.count.Load())\n\t$.println(\"s2 flag:\", s2.flag.Load())\n\n\t$.println(\"atomic struct field test finished\")\n}\n\n",
    "expectedOutput": "closed: true\ncount: 42\nflag: 100\ns2 closed: false\ns2 count: 24\ns2 flag: 50\natomic struct field test finished\n"
  },
  {
    "name": "basic_arithmetic",
    "goCode": "package main\n\nfunc main() {\n\t// === Basic Arithmetic ===\n\tadd := 2 + 3\n\tsub := 10 - 4\n\tmul := 6 * 7\n\tdiv := 20 / 5\n\tmod := 17 % 3\n\tprintln(\"Addition: Expected: 5, Actual:\", add)\n\tprintln(\"Subtraction: Expected: 6, Actual:\", sub)\n\tprintln(\"Multiplication: Expected: 42, Actual:\", mul)\n\tprintln(\"Division: Expected: 4, Actual:\", div)\n\tprintln(\"Modulus: Expected: 2, Actual:\", mod)\n}\n",
    "tsCode": "// Generated file based on basic_arithmetic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// === Basic Arithmetic ===\n\tlet add = 2 + 3\n\tlet sub = 10 - 4\n\tlet mul = 6 * 7\n\tlet div = Math.trunc(20 / 5)\n\tlet mod = 17 % 3\n\t$.println(\"Addition: Expected: 5, Actual:\", add)\n\t$.println(\"Subtraction: Expected: 6, Actual:\", sub)\n\t$.println(\"Multiplication: Expected: 42, Actual:\", mul)\n\t$.println(\"Division: Expected: 4, Actual:\", div)\n\t$.println(\"Modulus: Expected: 2, Actual:\", mod)\n}\n\n",
    "expectedOutput": "Addition: Expected: 5, Actual: 5\nSubtraction: Expected: 6, Actual: 6\nMultiplication: Expected: 42, Actual: 42\nDivision: Expected: 4, Actual: 4\nModulus: Expected: 2, Actual: 2"
  },
  {
    "name": "bitwise_and_not_assignment",
    "goCode": "package main\n\nfunc main() {\n\t// Test the &^= operator (bit clear assignment)\n\tx := uint64(0x7FF0000000000000) // Some bits set\n\tmask := uint64(2047 << 52)      // Mask to clear\n\n\tprintln(\"Before:\", x)\n\tx &^= mask // This should generate valid TypeScript\n\tprintln(\"After:\", x)\n\n\t// Also test regular &^ operator\n\ty := uint64(0x7FF0000000000000)\n\tresult := y &^ mask\n\tprintln(\"Result:\", result)\n}\n",
    "tsCode": "// Generated file based on bitwise_and_not_assignment.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test the &^= operator (bit clear assignment)\n\tlet x = (0x7FF0000000000000 as number) // Some bits set\n\tlet mask = ((2047 << 52) as number) // Mask to clear\n\n\t$.println(\"Before:\", x)\n\tx &= ~(mask) // This should generate valid TypeScript\n\t$.println(\"After:\", x)\n\n\t// Also test regular &^ operator\n\tlet y = (0x7FF0000000000000 as number)\n\tlet result = (y & ~ mask)\n\t$.println(\"Result:\", result)\n}\n\n",
    "expectedOutput": "Before: 9218868437227405000\nAfter: 0\nResult: 0\n"
  },
  {
    "name": "block_comments",
    "goCode": "package main\n\n/* This is a single-line block comment */\n\n/*\nThis is a multi-line\nblock comment that spans\nseveral lines\n*/\n\nfunc main() {\n\t/* Another single-line block comment */\n\tprintln(\"testing block comments\")\n\n\t/*\n\t\tMulti-line comment\n\t\tin the middle of code\n\t*/\n\n\tx := 42 /* inline block comment */\n\tprintln(\"x =\", x)\n}\n",
    "tsCode": "// Generated file based on block_comments.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t/* Another single-line block comment */\n\t$.println(\"testing block comments\")\n\n\t/*\n\t *\n\t *\t\tMulti-line comment\n\t *\t\tin the middle of code\n\t *\t\n\t */\n\n\tlet x = 42 // inline block comment\n\t$.println(\"x =\", x)\n}\n\n",
    "expectedOutput": "testing block comments\nx = 42\n"
  },
  {
    "name": "boolean_logic",
    "goCode": "package main\n\nfunc main() {\n\t// === Boolean Logic ===\n\ta := true\n\tb := false\n\tand := a && b\n\tor := a || b\n\tnotA := !a\n\tprintln(\"AND: Expected: false, Actual:\", and)\n\tprintln(\"OR: Expected: true, Actual:\", or)\n\tprintln(\"NOT: Expected: false, Actual:\", notA)\n}\n",
    "tsCode": "// Generated file based on boolean_logic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// === Boolean Logic ===\n\tlet a = true\n\tlet b = false\n\tlet and = a && b\n\tlet or = a || b\n\tlet notA = !a\n\t$.println(\"AND: Expected: false, Actual:\", and)\n\t$.println(\"OR: Expected: true, Actual:\", or)\n\t$.println(\"NOT: Expected: false, Actual:\", notA)\n}\n\n",
    "expectedOutput": "AND: Expected: false, Actual: false\nOR: Expected: true, Actual: true\nNOT: Expected: false, Actual: false"
  },
  {
    "name": "buffer_value_field_error",
    "goCode": "package main\n\n// Test case that replicates the buffer value field error\n// The issue: b!.value = $.append(b!.value, c) should be this._value = $.append(this._value, c)\n\ntype buffer struct {\n\tdata []byte\n}\n\nfunc (b *buffer) write(p []byte) {\n\t// This should generate: this._value = $.append(this._value, p)\n\t// But incorrectly generates: b!.value = $.append(b!.value, p)\n\tb.data = append(b.data, p...)\n}\n\nfunc (b *buffer) writeString(s string) {\n\t// This should generate: this._value = $.append(this._value, s)\n\t// But incorrectly generates: b!.value = $.append(b!.value, s)\n\tb.data = append(b.data, s...)\n}\n\nfunc (b *buffer) writeByte(c byte) {\n\t// This should generate: this._value = $.append(this._value, c)\n\t// But incorrectly generates: b!.value = $.append(b!.value, c)\n\tb.data = append(b.data, c)\n}\n\nfunc main() {\n\tbuf := &buffer{}\n\n\t// Test write\n\tbuf.write([]byte(\"hello\"))\n\tprintln(\"After write:\", string(buf.data))\n\n\t// Test writeString\n\tbuf.writeString(\" world\")\n\tprintln(\"After writeString:\", string(buf.data))\n\n\t// Test writeByte\n\tbuf.writeByte('!')\n\tprintln(\"After writeByte:\", string(buf.data))\n}\n",
    "tsCode": "// Generated file based on buffer_value_field_error.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class buffer {\n\tpublic get data(): $.Bytes {\n\t\treturn this._fields.data.value\n\t}\n\tpublic set data(value: $.Bytes) {\n\t\tthis._fields.data.value = value\n\t}\n\n\tpublic _fields: {\n\t\tdata: $.VarRef<$.Bytes>;\n\t}\n\n\tconstructor(init?: Partial<{data?: $.Bytes}>) {\n\t\tthis._fields = {\n\t\t\tdata: $.varRef(init?.data ?? new Uint8Array(0))\n\t\t}\n\t}\n\n\tpublic clone(): buffer {\n\t\tconst cloned = new buffer()\n\t\tcloned._fields = {\n\t\t\tdata: $.varRef(this._fields.data.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic write(p: $.Bytes): void {\n\t\tconst b = this\n\t\tb.data = $.append(b.data, ...(p || []))\n\t}\n\n\tpublic writeString(s: string): void {\n\t\tconst b = this\n\t\tb.data = $.append(b.data, ...$.stringToBytes(s))\n\t}\n\n\tpublic writeByte(c: number): void {\n\t\tconst b = this\n\t\tb.data = $.append(b.data, c)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.buffer',\n\t  new buffer(),\n\t  [{ name: \"write\", args: [{ name: \"p\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }], returns: [] }, { name: \"writeString\", args: [{ name: \"s\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [] }, { name: \"writeByte\", args: [{ name: \"c\", type: { kind: $.TypeKind.Basic, name: \"byte\" } }], returns: [] }],\n\t  buffer,\n\t  {\"data\": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet buf = new buffer({})\n\n\t// Test write\n\tbuf!.write($.stringToBytes(\"hello\"))\n\t$.println(\"After write:\", $.bytesToString(buf!.data))\n\n\t// Test writeString\n\tbuf!.writeString(\" world\")\n\t$.println(\"After writeString:\", $.bytesToString(buf!.data))\n\n\t// Test writeByte\n\tbuf!.writeByte(33)\n\t$.println(\"After writeByte:\", $.bytesToString(buf!.data))\n}\n\n",
    "expectedOutput": "After write: hello\nAfter writeString: hello world\nAfter writeByte: hello world!\n"
  },
  {
    "name": "build_tags",
    "goCode": "package main\n\nfunc main() {\n\tprintln(\"=== Build Tags Test ===\")\n\n\t// Test that platform-specific files are handled correctly\n\t// This should only compile files with js/wasm build tags\n\t// and exclude files with other platform tags\n\n\ttestJSWasm()\n\ttestGeneric()\n\n\tprintln(\"=== End Build Tags Test ===\")\n}\n",
    "tsCode": "// Generated file based on build_tags.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\nimport { testGeneric } from \"./build_tags_generic.gs.js\";\nimport { testJSWasm } from \"./build_tags_js.gs.js\";\n\nexport async function main(): Promise<void> {\n\t$.println(\"=== Build Tags Test ===\")\n\n\t// Test that platform-specific files are handled correctly\n\t// This should only compile files with js/wasm build tags\n\t// and exclude files with other platform tags\n\n\ttestJSWasm()\n\ttestGeneric()\n\n\t$.println(\"=== End Build Tags Test ===\")\n}\n\n",
    "expectedOutput": "=== Build Tags Test ===\nJS/WASM specific code compiled - CORRECT\nGeneric code compiled - CORRECT\n=== End Build Tags Test === "
  },
  {
    "name": "bytes",
    "goCode": "package main\n\nfunc main() {\n\t// Test 1: Declaration and initialization of []byte\n\tvar b1 []byte\n\tprintln(\"b1:\", b1)\n\n\tb2 := []byte{72, 101, 108, 108, 111} // \"Hello\"\n\tprintln(\"b2:\", b2)\n\n\tb3 := []byte(\"World\") // Conversion from string literal\n\tprintln(\"b3:\", b3)\n\n\t// Test 2: Assignment\n\tb1 = b2\n\tprintln(\"b1 after assignment:\", b1)\n\n\t// Test 3: Conversion from string to []byte\n\ts := \"GoScript\"\n\tb4 := []byte(s)\n\tprintln(\"b4 from string:\", b4)\n\n\t// Test 4: Conversion from []byte to string\n\ts2 := string(b2)\n\tprintln(\"s2 from bytes:\", s2)\n\n\t// Test 5: Accessing elements\n\tprintln(\"b2[0]:\", b2[0])\n\tb2[0] = 87 // Change 'H' to 'W'\n\tprintln(\"b2 after modification:\", b2)\n\tprintln(\"s2 after b2 modification (should be 'Hello'):\", s2) // Should not change s2\n\n\t// Test 6: len and cap\n\tprintln(\"len(b2):\", len(b2), \"cap(b2):\", cap(b2))\n\tprintln(\"len(b3):\", len(b3), \"cap(b3):\", cap(b3))\n\n\t// Test 7: append\n\tb5 := append(b2, 33, 33) // Append \"!!\"\n\tprintln(\"b5 after append:\", b5)\n\tprintln(\"len(b5):\", len(b5), \"cap(b5):\", cap(b5))\n\n\tb6 := append(b5, []byte(\" GoScript\")...)\n\tprintln(\"b6 after append slice:\", b6)\n\tprintln(\"len(b6):\", len(b6), \"cap(b6):\", cap(b6))\n}\n",
    "tsCode": "// Generated file based on bytes.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test 1: Declaration and initialization of []byte\n\tlet b1: $.Bytes = new Uint8Array(0)\n\t$.println(\"b1:\", b1)\n\n\tlet b2 = new Uint8Array([72, 101, 108, 108, 111]) // \"Hello\"\n\t$.println(\"b2:\", b2)\n\n\tlet b3 = $.stringToBytes(\"World\") // Conversion from string literal\n\t$.println(\"b3:\", b3)\n\n\t// Test 2: Assignment\n\tb1 = b2\n\t$.println(\"b1 after assignment:\", b1)\n\n\t// Test 3: Conversion from string to []byte\n\tlet s = \"GoScript\"\n\tlet b4 = $.stringToBytes(s)\n\t$.println(\"b4 from string:\", b4)\n\n\t// Test 4: Conversion from []byte to string\n\tlet s2 = $.bytesToString(b2)\n\t$.println(\"s2 from bytes:\", s2)\n\n\t// Test 5: Accessing elements\n\t$.println(\"b2[0]:\", b2![0])\n\tb2![0] = 87 // Change 'H' to 'W'\n\t$.println(\"b2 after modification:\", b2)\n\t$.println(\"s2 after b2 modification (should be 'Hello'):\", s2) // Should not change s2\n\n\t// Test 6: len and cap\n\t$.println(\"len(b2):\", $.len(b2), \"cap(b2):\", $.cap(b2))\n\t$.println(\"len(b3):\", $.len(b3), \"cap(b3):\", $.cap(b3))\n\n\t// Test 7: append\n\tlet b5 = $.append(b2, 33, 33) // Append \"!!\"\n\t$.println(\"b5 after append:\", b5)\n\t$.println(\"len(b5):\", $.len(b5), \"cap(b5):\", $.cap(b5))\n\n\tlet b6 = $.append(b5, ...($.stringToBytes(\" GoScript\") || []))\n\t$.println(\"b6 after append slice:\", b6)\n\t$.println(\"len(b6):\", $.len(b6), \"cap(b6):\", $.cap(b6))\n}\n\n",
    "expectedOutput": "b1: Uint8Array(0) []\nb2: Uint8Array(5) [ 72, 101, 108, 108, 111 ]\nb3: Uint8Array(5) [ 87, 111, 114, 108, 100 ]\nb1 after assignment: Uint8Array(5) [ 72, 101, 108, 108, 111 ]\nb4 from string: Uint8Array(8) [ 71, 111, 83, 99, 114, 105, 112, 116 ]\ns2 from bytes: Hello\nb2[0]: 72\nb2 after modification: Uint8Array(5) [ 87, 101, 108, 108, 111 ]\ns2 after b2 modification (should be 'Hello'): Hello\nlen(b2): 5 cap(b2): 5\nlen(b3): 5 cap(b3): 5\nb5 after append: Uint8Array(7) [ 87, 101, 108, 108, 111, 33, 33 ]\nlen(b5): 7 cap(b5): 7\nb6 after append slice: Uint8Array(16) [ 87, 101, 108, 108, 111, 33, 33, 32, 71, 111, 83, 99, 114, 105, 112, 116 ]\nlen(b6): 16 cap(b6): 16\n"
  },
  {
    "name": "call_async_returned_function",
    "goCode": "package main\n\nimport \"sync\"\n\nvar cache sync.Map\n\n// Async function that returns a function\nfunc getCallback() func(string) {\n\tcache.Load(1)\n\treturn func(msg string) {\n\t\tprintln(\"Callback:\", msg)\n\t}\n}\n\nfunc main() {\n\t// Call the function returned by an async function\n\t// This should generate: (await getCallback())!(\"hello\")\n\t// NOT: await getCallback()!(\"hello\")\n\tgetCallback()(\"hello\")\n}\n",
    "tsCode": "// Generated file based on call_async_returned_function.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as sync from \"@goscript/sync/index.js\"\n\nexport let cache: $.VarRef<sync.Map> = $.varRef(new sync.Map())\n\n// Async function that returns a function\nexport async function getCallback(): Promise<((p0: string) => void) | null> {\n\tawait cache!.value.Load(1)\n\treturn (msg: string): void => {\n\t\t$.println(\"Callback:\", msg)\n\t}\n}\n\nexport async function main(): Promise<void> {\n\t// Call the function returned by an async function\n\t// This should generate: (await getCallback())!(\"hello\")\n\t// NOT: await getCallback()!(\"hello\")\n\t;(await getCallback())!(\"hello\")\n}\n\n",
    "expectedOutput": "Callback: hello\n"
  },
  {
    "name": "call_returned_function_async",
    "goCode": "package main\n\nfunc getAdder(x int) func(int) int {\n\treturn func(y int) int {\n\t\treturn x + y\n\t}\n}\n\nfunc asyncAdd(a, b int) int {\n\treturn a + b\n}\n\nfunc getAsyncAdder(x int) func(int) int {\n\treturn func(y int) int {\n\t\treturn asyncAdd(x, y)\n\t}\n}\n\nfunc main() {\n\t// Direct call of returned function - not async\n\tresult1 := getAdder(5)(3)\n\tprintln(\"Result 1:\", result1)\n\n\t// Direct call of returned function - with async call inside\n\tresult2 := getAsyncAdder(10)(7)\n\tprintln(\"Result 2:\", result2)\n}\n",
    "tsCode": "// Generated file based on call_returned_function_async.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function getAdder(x: number): ((p0: number) => number) | null {\n\treturn (y: number): number => {\n\t\treturn x + y\n\t}\n}\n\nexport function asyncAdd(a: number, b: number): number {\n\treturn a + b\n}\n\nexport function getAsyncAdder(x: number): ((p0: number) => number) | null {\n\treturn (y: number): number => {\n\t\treturn asyncAdd(x, y)\n\t}\n}\n\nexport async function main(): Promise<void> {\n\t// Direct call of returned function - not async\n\tlet result1 = getAdder(5)!(3)\n\t$.println(\"Result 1:\", result1)\n\n\t// Direct call of returned function - with async call inside\n\tlet result2 = getAsyncAdder(10)!(7)\n\t$.println(\"Result 2:\", result2)\n}\n\n",
    "expectedOutput": "Result 1: 8\nResult 2: 17\n"
  },
  {
    "name": "chan_type_assertion",
    "goCode": "package main\n\nfunc main() {\n\tch1 := make(chan int)       // bidirectional int channel\n\tch2 := make(chan<- string)  // send-only string channel\n\tch3 := make(<-chan float64) // receive-only float64 channel\n\tch4 := make(chan struct{})  // bidirectional struct{} channel\n\n\tvar i interface{} = ch1\n\tif _, ok := i.(chan int); ok {\n\t\tprintln(\"i is chan int: ok\")\n\t} else {\n\t\tprintln(\"i is chan int: failed\")\n\t}\n\n\tvar s interface{} = ch2\n\tif _, ok := s.(chan<- string); ok {\n\t\tprintln(\"s is chan<- string: ok\")\n\t} else {\n\t\tprintln(\"s is chan<- string: failed\")\n\t}\n\n\tvar r interface{} = ch3\n\tif _, ok := r.((<-chan float64)); ok {\n\t\tprintln(\"r is <-chan float64: ok\")\n\t} else {\n\t\tprintln(\"r is <-chan float64: failed\")\n\t}\n\n\tvar e interface{} = ch4\n\tif _, ok := e.(chan struct{}); ok {\n\t\tprintln(\"e is chan struct{}: ok\")\n\t} else {\n\t\tprintln(\"e is chan struct{}: failed\")\n\t}\n\n\tif _, ok := i.(chan string); ok {\n\t\tprintln(\"i is chan string: incorrect\")\n\t} else {\n\t\tprintln(\"i is chan string: correctly failed\")\n\t}\n\n\tif _, ok := i.(chan<- int); ok {\n\t\tprintln(\"i is chan<- int: incorrect\")\n\t} else {\n\t\tprintln(\"i is chan<- int: correctly failed\")\n\t}\n\n\tif _, ok := i.(<-chan int); ok {\n\t\tprintln(\"i is <-chan int: incorrect\")\n\t} else {\n\t\tprintln(\"i is <-chan int: correctly failed\")\n\t}\n\n\tif _, ok := i.(chan<- int); ok {\n\t\tprintln(\"bidirectional can be used as send-only: ok\")\n\t} else {\n\t\tprintln(\"bidirectional can be used as send-only: failed\")\n\t}\n\n\tif _, ok := i.(<-chan int); ok {\n\t\tprintln(\"bidirectional can be used as receive-only: ok\")\n\t} else {\n\t\tprintln(\"bidirectional can be used as receive-only: failed\")\n\t}\n}\n",
    "tsCode": "// Generated file based on chan_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet ch1 = $.makeChannel<number>(0, 0, 'both') // bidirectional int channel\n\tlet ch2 = $.makeChannel<string>(0, \"\", 'send') // send-only string channel\n\tlet ch3 = $.makeChannel<number>(0, 0, 'receive') // receive-only float64 channel\n\tlet ch4 = $.makeChannel<{  }>(0, {}, 'both') // bidirectional struct{} channel\n\n\tlet i: null | any = ch1\n\t{\n\t\tlet { ok: ok } = $.typeAssert<$.Channel<number> | null>(i, {kind: $.TypeKind.Channel, elemType: 'number', direction: 'both'})\n\t\tif (ok) {\n\t\t\t$.println(\"i is chan int: ok\")\n\t\t} else {\n\t\t\t$.println(\"i is chan int: failed\")\n\t\t}\n\t}\n\n\tlet s: null | any = ch2\n\t{\n\t\tlet { ok: ok } = $.typeAssert<$.Channel<string> | null>(s, {kind: $.TypeKind.Channel, elemType: 'string', direction: 'send'})\n\t\tif (ok) {\n\t\t\t$.println(\"s is chan<- string: ok\")\n\t\t} else {\n\t\t\t$.println(\"s is chan<- string: failed\")\n\t\t}\n\t}\n\n\tlet r: null | any = ch3\n\t{\n\t\tlet { ok: ok } = $.typeAssert<$.Channel<number> | null>(r, {kind: $.TypeKind.Channel, elemType: 'number', direction: 'receive'})\n\t\tif (ok) {\n\t\t\t$.println(\"r is <-chan float64: ok\")\n\t\t} else {\n\t\t\t$.println(\"r is <-chan float64: failed\")\n\t\t}\n\t}\n\n\tlet e: null | any = ch4\n\t{\n\t\tlet { ok: ok } = $.typeAssert<$.Channel<{  }> | null>(e, {kind: $.TypeKind.Channel, elemType: {kind: $.TypeKind.Struct, fields: {}, methods: []}, direction: 'both'})\n\t\tif (ok) {\n\t\t\t$.println(\"e is chan struct{}: ok\")\n\t\t} else {\n\t\t\t$.println(\"e is chan struct{}: failed\")\n\t\t}\n\t}\n\n\t{\n\t\tlet { ok: ok } = $.typeAssert<$.Channel<string> | null>(i, {kind: $.TypeKind.Channel, elemType: 'string', direction: 'both'})\n\t\tif (ok) {\n\t\t\t$.println(\"i is chan string: incorrect\")\n\t\t} else {\n\t\t\t$.println(\"i is chan string: correctly failed\")\n\t\t}\n\t}\n\n\t{\n\t\tlet { ok: ok } = $.typeAssert<$.Channel<number> | null>(i, {kind: $.TypeKind.Channel, elemType: 'number', direction: 'send'})\n\t\tif (ok) {\n\t\t\t$.println(\"i is chan<- int: incorrect\")\n\t\t} else {\n\t\t\t$.println(\"i is chan<- int: correctly failed\")\n\t\t}\n\t}\n\n\t{\n\t\tlet { ok: ok } = $.typeAssert<$.Channel<number> | null>(i, {kind: $.TypeKind.Channel, elemType: 'number', direction: 'receive'})\n\t\tif (ok) {\n\t\t\t$.println(\"i is <-chan int: incorrect\")\n\t\t} else {\n\t\t\t$.println(\"i is <-chan int: correctly failed\")\n\t\t}\n\t}\n\n\t{\n\t\tlet { ok: ok } = $.typeAssert<$.Channel<number> | null>(i, {kind: $.TypeKind.Channel, elemType: 'number', direction: 'send'})\n\t\tif (ok) {\n\t\t\t$.println(\"bidirectional can be used as send-only: ok\")\n\t\t} else {\n\t\t\t$.println(\"bidirectional can be used as send-only: failed\")\n\t\t}\n\t}\n\n\t{\n\t\tlet { ok: ok } = $.typeAssert<$.Channel<number> | null>(i, {kind: $.TypeKind.Channel, elemType: 'number', direction: 'receive'})\n\t\tif (ok) {\n\t\t\t$.println(\"bidirectional can be used as receive-only: ok\")\n\t\t} else {\n\t\t\t$.println(\"bidirectional can be used as receive-only: failed\")\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "i is chan int: ok\ns is chan<- string: ok\nr is <-chan float64: ok\ne is chan struct{}: ok\ni is chan string: correctly failed\ni is chan<- int: correctly failed\ni is <-chan int: correctly failed\nbidirectional can be used as send-only: failed\nbidirectional can be used as receive-only: failed"
  },
  {
    "name": "channel_basic",
    "goCode": "package main\n\nfunc main() {\n\tmessages := make(chan string)\n\n\tgo func() {\n\t\tmessages <- \"ping\"\n\t}()\n\n\tmsg := <-messages\n\tprintln(msg)\n}\n",
    "tsCode": "// Generated file based on channel_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet messages = $.makeChannel<string>(0, \"\", 'both')\n\n\tqueueMicrotask(async () => {\n\t\tawait $.chanSend(messages, \"ping\")\n\t})\n\n\tlet msg = await $.chanRecv(messages)\n\t$.println(msg)\n}\n\n",
    "expectedOutput": "ping"
  },
  {
    "name": "channel_receive_both_blank",
    "goCode": "package main\n\nfunc main() {\n\tch := make(chan int, 1)\n\n\t// Send a value to the channel\n\tch <- 42\n\n\t// Receive with both value and ok discarded\n\t_, _ = <-ch\n\n\tprintln(\"received and discarded value and ok\")\n\n\t// Close the channel\n\tclose(ch)\n\n\t// Receive from closed channel with both discarded\n\t_, _ = <-ch\n\n\tprintln(\"received from closed channel, both discarded\")\n}\n",
    "tsCode": "// Generated file based on channel_receive_both_blank.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet ch = $.makeChannel<number>(1, 0, 'both')\n\n\t// Send a value to the channel\n\tawait $.chanSend(ch, 42)\n\n\t// Receive with both value and ok discarded\n\tawait $.chanRecvWithOk(ch)\n\n\t$.println(\"received and discarded value and ok\")\n\n\t// Close the channel\n\tch.close()\n\n\t// Receive from closed channel with both discarded\n\tawait $.chanRecvWithOk(ch)\n\n\t$.println(\"received from closed channel, both discarded\")\n}\n\n",
    "expectedOutput": "received and discarded value and ok\nreceived from closed channel, both discarded\n"
  },
  {
    "name": "comments_struct",
    "goCode": "package main\n\n// TestStruct is a struct with commented fields.\ntype TestStruct struct {\n\t// IntField is a commented integer field.\n\tIntField int\n\t// StringField is a commented string field.\n\tStringField string\n}\n\nfunc main() {\n\ts := TestStruct{\n\t\tIntField:    42,\n\t\tStringField: \"hello\",\n\t}\n\tprintln(\"IntField:\", s.IntField)\n\tprintln(\"StringField:\", s.StringField)\n}\n",
    "tsCode": "// Generated file based on comments_struct.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class TestStruct {\n\t// IntField is a commented integer field.\n\tpublic get IntField(): number {\n\t\treturn this._fields.IntField.value\n\t}\n\tpublic set IntField(value: number) {\n\t\tthis._fields.IntField.value = value\n\t}\n\n\t// StringField is a commented string field.\n\tpublic get StringField(): string {\n\t\treturn this._fields.StringField.value\n\t}\n\tpublic set StringField(value: string) {\n\t\tthis._fields.StringField.value = value\n\t}\n\n\tpublic _fields: {\n\t\tIntField: $.VarRef<number>;\n\t\tStringField: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{IntField?: number, StringField?: string}>) {\n\t\tthis._fields = {\n\t\t\tIntField: $.varRef(init?.IntField ?? 0),\n\t\t\tStringField: $.varRef(init?.StringField ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): TestStruct {\n\t\tconst cloned = new TestStruct()\n\t\tcloned._fields = {\n\t\t\tIntField: $.varRef(this._fields.IntField.value),\n\t\t\tStringField: $.varRef(this._fields.StringField.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.TestStruct',\n\t  new TestStruct(),\n\t  [],\n\t  TestStruct,\n\t  {\"IntField\": { kind: $.TypeKind.Basic, name: \"int\" }, \"StringField\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet s = $.markAsStructValue(new TestStruct({IntField: 42, StringField: \"hello\"}))\n\t$.println(\"IntField:\", s.IntField)\n\t$.println(\"StringField:\", s.StringField)\n}\n\n",
    "expectedOutput": "IntField: 42\nStringField: hello"
  },
  {
    "name": "composite_literal_assignment",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n\tmyBool   bool //nolint:unused\n}\n\nfunc main() {\n\t// === Composite Literal Assignment (Value Copy) ===\n\t// Creating a struct directly using a composite literal.\n\tstructLiteral := MyStruct{MyString: \"composite literal\"}\n\t// Assigning it creates another independent copy.\n\tstructLiteralCopy := structLiteral\n\tstructLiteralCopy.MyString = \"modified composite literal copy\"\n\t// Expected: \"composite literal\"\n\tprintln(\"Original struct literal: Expected: composite literal, Actual: \" + structLiteral.MyString)\n\t// Expected: \"modified composite literal copy\"\n\tprintln(\"Modified struct literal copy: Expected: modified composite literal copy, Actual: \" + structLiteralCopy.MyString)\n}\n",
    "tsCode": "// Generated file based on composite_literal_assignment.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get myBool(): boolean {\n\t\treturn this._fields.myBool.value\n\t}\n\tpublic set myBool(value: boolean) {\n\t\tthis._fields.myBool.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t\tmyBool: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string, myBool?: boolean}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\"),\n\t\t\tmyBool: $.varRef(init?.myBool ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value),\n\t\t\tmyBool: $.varRef(this._fields.myBool.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }, \"myBool\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// === Composite Literal Assignment (Value Copy) ===\n\t// Creating a struct directly using a composite literal.\n\tlet structLiteral = $.markAsStructValue(new MyStruct({MyString: \"composite literal\"}))\n\t// Assigning it creates another independent copy.\n\tlet structLiteralCopy = $.markAsStructValue(structLiteral.clone())\n\tstructLiteralCopy.MyString = \"modified composite literal copy\"\n\t// Expected: \"composite literal\"\n\t$.println(\"Original struct literal: Expected: composite literal, Actual: \" + structLiteral.MyString)\n\t// Expected: \"modified composite literal copy\"\n\t$.println(\"Modified struct literal copy: Expected: modified composite literal copy, Actual: \" + structLiteralCopy.MyString)\n}\n\n",
    "expectedOutput": "Original struct literal: Expected: composite literal, Actual: composite literal\nModified struct literal copy: Expected: modified composite literal copy, Actual: modified composite literal copy"
  },
  {
    "name": "constants",
    "goCode": "package main\n\nconst (\n\tPi    = 3.14\n\tTruth = false\n\t// TODO: Handle large integer constants and bit shifts exceeding JS number limits.\n\t// Big      = 1 << 60\n\t// Small    = Big >> 59 // Commented out as it depends on Big\n\tGreeting = \"Hello, Constants!\"\n)\n\n// Nothing has untyped null\nvar Nothing = interface{}(nil)\n\nfunc main() {\n\tprintln(Pi)\n\tprintln(Truth)\n\t// println(Big) // Commented out until large integer handling is implemented\n\t// println(Small) // Commented out as it depends on Big\n\tprintln(Greeting)\n\tprintln(byte(4))\n}\n",
    "tsCode": "// Generated file based on constants.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport let Pi: number = 3.14\n\nexport let Truth: boolean = false\n\n// TODO: Handle large integer constants and bit shifts exceeding JS number limits.\n// Big      = 1 << 60\n// Small    = Big >> 59 // Commented out as it depends on Big\nexport let Greeting: string = \"Hello, Constants!\"\n\nexport let Nothing: null | any = null\n\nexport async function main(): Promise<void> {\n\t$.println(3.14)\n\t$.println(false)\n\t// println(Big) // Commented out until large integer handling is implemented\n\t// println(Small) // Commented out as it depends on Big\n\t$.println(\"Hello, Constants!\")\n\t$.println($.byte(4))\n}\n\n",
    "expectedOutput": "3.14\nfalse\nHello, Constants!\n4"
  },
  {
    "name": "constants_iota",
    "goCode": "package main\n\ntype ByteSize int\n\nconst (\n\t_           = iota // ignore first value by assigning to blank identifier\n\tKB ByteSize = 1 << (10 * iota)\n\tMB\n\tGB\n\tTB\n)\n\ntype Direction int\n\nconst (\n\tNorth Direction = iota\n\tEast\n\tSouth\n\tWest\n)\n\nconst (\n\tRed = iota\n\tGreen\n\tBlue\n)\n\nconst (\n\tSunday = iota\n\tMonday\n\tTuesday\n\tWednesday\n\tThursday\n\tFriday\n\tSaturday\n)\n\nconst (\n\tFirst  = iota + 1\n\tSecond = iota + 1\n\tThird  = iota + 1\n)\n\nconst (\n\tA = iota * 2\n\tB\n\tC\n)\n\nfunc main() {\n\tprintln(\"ByteSize constants:\")\n\tprintln(\"KB:\", int(KB))\n\tprintln(\"MB:\", int(MB))\n\tprintln(\"GB:\", int(GB))\n\tprintln(\"TB:\", int(TB))\n\n\tprintln(\"Direction constants:\")\n\tprintln(\"North:\", int(North))\n\tprintln(\"East:\", int(East))\n\tprintln(\"South:\", int(South))\n\tprintln(\"West:\", int(West))\n\n\tprintln(\"Color constants:\")\n\tprintln(\"Red:\", Red)\n\tprintln(\"Green:\", Green)\n\tprintln(\"Blue:\", Blue)\n\n\tprintln(\"Day constants:\")\n\tprintln(\"Sunday:\", Sunday)\n\tprintln(\"Monday:\", Monday)\n\tprintln(\"Tuesday:\", Tuesday)\n\tprintln(\"Wednesday:\", Wednesday)\n\tprintln(\"Thursday:\", Thursday)\n\tprintln(\"Friday:\", Friday)\n\tprintln(\"Saturday:\", Saturday)\n\n\tprintln(\"Arithmetic constants:\")\n\tprintln(\"First:\", First)\n\tprintln(\"Second:\", Second)\n\tprintln(\"Third:\", Third)\n\n\tprintln(\"Multiplication constants:\")\n\tprintln(\"A:\", A)\n\tprintln(\"B:\", B)\n\tprintln(\"C:\", C)\n}\n",
    "tsCode": "// Generated file based on constants_iota.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\n// ignore first value by assigning to blank identifier\n\nexport let KB: ByteSize = (1 << (10 * 0))\n\nexport let MB: ByteSize = 0\n\nexport let GB: ByteSize = 0\n\nexport let TB: ByteSize = 0\n\nexport let North: Direction = 0\n\nexport let East: Direction = 0\n\nexport let South: Direction = 0\n\nexport let West: Direction = 0\n\nexport let Red: number = 0\n\nexport let Green: number = 0\n\nexport let Blue: number = 0\n\nexport let Sunday: number = 0\n\nexport let Monday: number = 0\n\nexport let Tuesday: number = 0\n\nexport let Wednesday: number = 0\n\nexport let Thursday: number = 0\n\nexport let Friday: number = 0\n\nexport let Saturday: number = 0\n\nexport let First: number = 0 + 1\n\nexport let Second: number = 0 + 1\n\nexport let Third: number = 0 + 1\n\nexport let A: number = 0 * 2\n\nexport let B: number = 0\n\nexport let C: number = 0\n\nexport type ByteSize = number;\n\nexport type Direction = number;\n\nexport async function main(): Promise<void> {\n\t$.println(\"ByteSize constants:\")\n\t$.println(\"KB:\", 1024)\n\t$.println(\"MB:\", 1048576)\n\t$.println(\"GB:\", 1073741824)\n\t$.println(\"TB:\", 1099511627776)\n\n\t$.println(\"Direction constants:\")\n\t$.println(\"North:\", 0)\n\t$.println(\"East:\", 1)\n\t$.println(\"South:\", 2)\n\t$.println(\"West:\", 3)\n\n\t$.println(\"Color constants:\")\n\t$.println(\"Red:\", 0)\n\t$.println(\"Green:\", 1)\n\t$.println(\"Blue:\", 2)\n\n\t$.println(\"Day constants:\")\n\t$.println(\"Sunday:\", 0)\n\t$.println(\"Monday:\", 1)\n\t$.println(\"Tuesday:\", 2)\n\t$.println(\"Wednesday:\", 3)\n\t$.println(\"Thursday:\", 4)\n\t$.println(\"Friday:\", 5)\n\t$.println(\"Saturday:\", 6)\n\n\t$.println(\"Arithmetic constants:\")\n\t$.println(\"First:\", 1)\n\t$.println(\"Second:\", 2)\n\t$.println(\"Third:\", 3)\n\n\t$.println(\"Multiplication constants:\")\n\t$.println(\"A:\", 0)\n\t$.println(\"B:\", 2)\n\t$.println(\"C:\", 4)\n}\n\n",
    "expectedOutput": "ByteSize constants:\nKB: 1024\nMB: 1048576\nGB: 1073741824\nTB: 1099511627776\nDirection constants:\nNorth: 0\nEast: 1\nSouth: 2\nWest: 3\nColor constants:\nRed: 0\nGreen: 1\nBlue: 2\nDay constants:\nSunday: 0\nMonday: 1\nTuesday: 2\nWednesday: 3\nThursday: 4\nFriday: 5\nSaturday: 6\nArithmetic constants:\nFirst: 1\nSecond: 2\nThird: 3\nMultiplication constants:\nA: 0\nB: 2\nC: 4\n"
  },
  {
    "name": "copy_independence",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\nfunc main() {\n\tstructPointer := &MyStruct{MyInt: 4, MyString: \"hello world\"}\n\tdereferencedStructCopy := *structPointer\n\tdereferencedStructCopy.MyString = \"original dereferenced copy modified\"\n\tvalueCopy1 := dereferencedStructCopy\n\tvalueCopy1.MyString = \"value copy 1\"\n\tvalueCopy2 := dereferencedStructCopy\n\tvalueCopy2.MyString = \"value copy 2\"\n\tpointerCopy := structPointer\n\n\t// === Verifying Copy Independence ===\n\t// Expected: \"hello world\"\n\tprintln(\"pointerCopy (points to original structPointer): Expected: hello world, Actual: \" + pointerCopy.MyString)\n\t// Expected: \"original dereferenced copy modified\"\n\tprintln(\"dereferencedStructCopy (modified after copies were made): Expected: original dereferenced copy modified, Actual: \" + dereferencedStructCopy.MyString)\n\t// Expected: \"value copy 1\"\n\tprintln(\"valueCopy1: Expected: value copy 1, Actual: \" + valueCopy1.MyString)\n\t// Expected: \"value copy 2\"\n\tprintln(\"valueCopy2: Expected: value copy 2, Actual: \" + valueCopy2.MyString)\n}\n",
    "tsCode": "// Generated file based on copy_independence.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet structPointer = new MyStruct({MyInt: 4, MyString: \"hello world\"})\n\tlet dereferencedStructCopy = $.markAsStructValue(structPointer!.clone())\n\tdereferencedStructCopy.MyString = \"original dereferenced copy modified\"\n\tlet valueCopy1 = $.markAsStructValue(dereferencedStructCopy.clone())\n\tvalueCopy1.MyString = \"value copy 1\"\n\tlet valueCopy2 = $.markAsStructValue(dereferencedStructCopy.clone())\n\tvalueCopy2.MyString = \"value copy 2\"\n\tlet pointerCopy = structPointer\n\n\t// === Verifying Copy Independence ===\n\t// Expected: \"hello world\"\n\t$.println(\"pointerCopy (points to original structPointer): Expected: hello world, Actual: \" + pointerCopy!.MyString)\n\t// Expected: \"original dereferenced copy modified\"\n\t$.println(\"dereferencedStructCopy (modified after copies were made): Expected: original dereferenced copy modified, Actual: \" + dereferencedStructCopy.MyString)\n\t// Expected: \"value copy 1\"\n\t$.println(\"valueCopy1: Expected: value copy 1, Actual: \" + valueCopy1.MyString)\n\t// Expected: \"value copy 2\"\n\t$.println(\"valueCopy2: Expected: value copy 2, Actual: \" + valueCopy2.MyString)\n}\n\n",
    "expectedOutput": "pointerCopy (points to original structPointer): Expected: hello world, Actual: hello world\ndereferencedStructCopy (modified after copies were made): Expected: original dereferenced copy modified, Actual: original dereferenced copy modified\nvalueCopy1: Expected: value copy 1, Actual: value copy 1\nvalueCopy2: Expected: value copy 2, Actual: value copy 2"
  },
  {
    "name": "debug_marshal",
    "goCode": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\nfunc main() {\n\tp := Person{Name: \"Alice\", Age: 30, Active: true}\n\tb, err := json.Marshal(p)\n\tif err != nil {\n\t\tfmt.Println(\"Marshal error:\", err)\n\t} else {\n\t\tfmt.Printf(\"Marshal result: %q (len=%d)\\n\", string(b), len(b))\n\t\tfor i, c := range b {\n\t\t\tfmt.Printf(\"byte[%d]: %d (%c)\\n\", i, c, c)\n\t\t}\n\t}\n}\n",
    "tsCode": "// Generated file based on debug_marshal.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as json from \"@goscript/encoding/json/index.js\"\n\nimport * as fmt from \"@goscript/fmt/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p = $.markAsStructValue(new Person({Active: true, Age: 30, Name: \"Alice\"}))\n\tlet [b, err] = await json.Marshal(p)\n\tif (err != null) {\n\t\tfmt.Println(\"Marshal error:\", err)\n\t} else {\n\t\tfmt.Printf(\"Marshal result: %q (len=%d)\\n\", $.bytesToString(b), $.len(b))\n\t\tfor (let i = 0; i < $.len(b); i++) {\n\t\t\tlet c = b![i]\n\t\t\t{\n\t\t\t\tfmt.Printf(\"byte[%d]: %d (%c)\\n\", i, c, c)\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Marshal result: \"{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":30,\\\"active\\\":true}\" (len=39)\nbyte[0]: 123 ({)\nbyte[1]: 34 (\")\nbyte[2]: 110 (n)\nbyte[3]: 97 (a)\nbyte[4]: 109 (m)\nbyte[5]: 101 (e)\nbyte[6]: 34 (\")\nbyte[7]: 58 (:)\nbyte[8]: 34 (\")\nbyte[9]: 65 (A)\nbyte[10]: 108 (l)\nbyte[11]: 105 (i)\nbyte[12]: 99 (c)\nbyte[13]: 101 (e)\nbyte[14]: 34 (\")\nbyte[15]: 44 (,)\nbyte[16]: 34 (\")\nbyte[17]: 97 (a)\nbyte[18]: 103 (g)\nbyte[19]: 101 (e)\nbyte[20]: 34 (\")\nbyte[21]: 58 (:)\nbyte[22]: 51 (3)\nbyte[23]: 48 (0)\nbyte[24]: 44 (,)\nbyte[25]: 34 (\")\nbyte[26]: 97 (a)\nbyte[27]: 99 (c)\nbyte[28]: 116 (t)\nbyte[29]: 105 (i)\nbyte[30]: 118 (v)\nbyte[31]: 101 (e)\nbyte[32]: 34 (\")\nbyte[33]: 58 (:)\nbyte[34]: 116 (t)\nbyte[35]: 114 (r)\nbyte[36]: 117 (u)\nbyte[37]: 101 (e)\nbyte[38]: 125 (})\n"
  },
  {
    "name": "debug_simple",
    "goCode": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t// Test basic types\n\ts := \"hello\"\n\tb1, err1 := json.Marshal(s)\n\tif err1 != nil {\n\t\tfmt.Println(\"String marshal error:\", err1)\n\t} else {\n\t\tfmt.Printf(\"String marshal: %q\\n\", string(b1))\n\t}\n\n\tn := 42\n\tb2, err2 := json.Marshal(n)\n\tif err2 != nil {\n\t\tfmt.Println(\"Int marshal error:\", err2)\n\t} else {\n\t\tfmt.Printf(\"Int marshal: %q\\n\", string(b2))\n\t}\n}\n",
    "tsCode": "// Generated file based on debug_simple.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as json from \"@goscript/encoding/json/index.js\"\n\nimport * as fmt from \"@goscript/fmt/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test basic types\n\tlet s = \"hello\"\n\tlet [b1, err1] = await json.Marshal(s)\n\tif (err1 != null) {\n\t\tfmt.Println(\"String marshal error:\", err1)\n\t} else {\n\t\tfmt.Printf(\"String marshal: %q\\n\", $.bytesToString(b1))\n\t}\n\n\tlet n = 42\n\tlet [b2, err2] = await json.Marshal(n)\n\tif (err2 != null) {\n\t\tfmt.Println(\"Int marshal error:\", err2)\n\t} else {\n\t\tfmt.Printf(\"Int marshal: %q\\n\", $.bytesToString(b2))\n\t}\n}\n\n",
    "expectedOutput": "String marshal: \"\\\"hello\\\"\"\nInt marshal: \"42\"\n"
  },
  {
    "name": "defer_async_method",
    "goCode": "package main\n\n// AsyncResource represents a resource that needs async cleanup\ntype AsyncResource struct {\n\tname string\n}\n\n// Release is an async method that contains channel operations\nfunc (r *AsyncResource) Release() {\n\tch := make(chan bool, 1)\n\tgo func() {\n\t\tch <- true\n\t}()\n\t<-ch // This will generate await in TypeScript\n\tprintln(\"Released\", r.name)\n}\n\nfunc main() {\n\tres := &AsyncResource{name: \"test\"}\n\tdefer res.Release() // This should use async defer\n\tprintln(\"main function\")\n}\n",
    "tsCode": "// Generated file based on defer_async_method.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class AsyncResource {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic _fields: {\n\t\tname: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{name?: string}>) {\n\t\tthis._fields = {\n\t\t\tname: $.varRef(init?.name ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): AsyncResource {\n\t\tconst cloned = new AsyncResource()\n\t\tcloned._fields = {\n\t\t\tname: $.varRef(this._fields.name.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Release is an async method that contains channel operations\n\tpublic async Release(): Promise<void> {\n\t\tconst r = this\n\t\tlet ch = $.makeChannel<boolean>(1, false, 'both')\n\t\tqueueMicrotask(async () => {\n\t\t\tawait $.chanSend(ch, true)\n\t\t})\n\t\tawait $.chanRecv(ch)\n\t\t$.println(\"Released\", r.name)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.AsyncResource',\n\t  new AsyncResource(),\n\t  [{ name: \"Release\", args: [], returns: [] }],\n\t  AsyncResource,\n\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tawait using __defer = new $.AsyncDisposableStack();\n\tlet res = new AsyncResource({name: \"test\"})\n\t__defer.defer(async () => {\n\t\tawait res!.Release()\n\t});\n\t$.println(\"main function\")\n}\n\n",
    "expectedOutput": "main function\nReleased test "
  },
  {
    "name": "defer_statement",
    "goCode": "package main\n\nfunc main() {\n\tdefer println(\"deferred\")\n\tprintln(\"main\")\n}\n",
    "tsCode": "// Generated file based on defer_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tusing __defer = new $.DisposableStack();\n\t__defer.defer(() => {\n\t\t$.println(\"deferred\")\n\t});\n\t$.println(\"main\")\n}\n\n",
    "expectedOutput": "main\ndeferred"
  },
  {
    "name": "destructure_trailing_comma",
    "goCode": "package main\n\nfunc returnTwoValues() (int, error) {\n\treturn 42, nil\n}\n\nfunc main() {\n\t// Test destructuring assignment with trailing comma issue\n\t// This should generate: [nref] = returnTwoValues()\n\t// Not: [nref, ] = returnTwoValues()\n\tvar nref int\n\tnref, _ = returnTwoValues()\n\n\tprintln(\"nref:\", nref)\n}\n",
    "tsCode": "// Generated file based on destructure_trailing_comma.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function returnTwoValues(): [number, $.GoError] {\n\treturn [42, null]\n}\n\nexport async function main(): Promise<void> {\n\t// Test destructuring assignment with trailing comma issue\n\t// This should generate: [nref] = returnTwoValues()\n\t// Not: [nref, ] = returnTwoValues()\n\tlet nref: number = 0\n\t;[nref] = returnTwoValues()\n\n\t$.println(\"nref:\", nref)\n}\n\n",
    "expectedOutput": "nref: 42 "
  },
  {
    "name": "destructuring_assignment",
    "goCode": "package main\n\nimport \"fmt\"\n\nfunc multiReturn() (int, int) {\n\treturn 10, 20\n}\n\nfunc multiReturnThree() (string, int, int) {\n\treturn \"test\", 100, 200\n}\n\nfunc main() {\n\t// Test simple destructuring that should work\n\tx, y := multiReturn()\n\tfmt.Printf(\"x=%d, y=%d\\n\", x, y)\n\n\t// Test three-value destructuring\n\tname, line, col := multiReturnThree()\n\tfmt.Printf(\"name=%s, line=%d, col=%d\\n\", name, line, col)\n\n\t// Test reassignment to existing variables\n\tvar a, b int\n\ta, b = multiReturn()\n\tfmt.Printf(\"a=%d, b=%d\\n\", a, b)\n}\n",
    "tsCode": "// Generated file based on destructuring_assignment.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as fmt from \"@goscript/fmt/index.js\"\n\nexport function multiReturn(): [number, number] {\n\treturn [10, 20]\n}\n\nexport function multiReturnThree(): [string, number, number] {\n\treturn [\"test\", 100, 200]\n}\n\nexport async function main(): Promise<void> {\n\t// Test simple destructuring that should work\n\tlet [x, y] = multiReturn()\n\tfmt.Printf(\"x=%d, y=%d\\n\", x, y)\n\n\t// Test three-value destructuring\n\tlet [name, line, col] = multiReturnThree()\n\tfmt.Printf(\"name=%s, line=%d, col=%d\\n\", name, line, col)\n\n\t// Test reassignment to existing variables\n\tlet a: number = 0\n\tlet b: number = 0\n\t;[a, b] = multiReturn()\n\tfmt.Printf(\"a=%d, b=%d\\n\", a, b)\n}\n\n",
    "expectedOutput": "x=10, y=20\nname=test, line=100, col=200\na=10, b=20\n"
  },
  {
    "name": "discarded_channel_receive",
    "goCode": "package main\n\nfunc main() {\n\tch := make(chan int)\n\tgo func() {\n\t\tch <- 1\n\t\tclose(ch) // Close the channel to allow the main goroutine to exit\n\t}()\n\t<-ch            // Discard the value received from the channel\n\tprintln(\"done\") // Add a print statement to verify execution\n}\n",
    "tsCode": "// Generated file based on discarded_channel_receive.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet ch = $.makeChannel<number>(0, 0, 'both')\n\n\t// Close the channel to allow the main goroutine to exit\n\tqueueMicrotask(async () => {\n\t\tawait $.chanSend(ch, 1)\n\t\tch.close() // Close the channel to allow the main goroutine to exit\n\t})\n\tawait $.chanRecv(ch)\n\t$.println(\"done\") // Add a print statement to verify execution\n}\n\n",
    "expectedOutput": "done"
  },
  {
    "name": "embedded_interface_assertion",
    "goCode": "package main\n\ntype Reader interface {\n\t// Read reads data from the reader.\n\tRead([]byte) (int, error)\n}\n\ntype Closer interface {\n\tClose() error\n}\n\ntype ReadCloser interface {\n\tReader\n\tCloser\n}\n\ntype MyStruct struct {\n\t// Implements Reader and Closer\n}\n\nfunc (m MyStruct) Read(p []byte) (int, error) {\n\t// Dummy implementation\n\treturn 0, nil\n}\n\nfunc (m MyStruct) Close() error {\n\t// Dummy implementation\n\treturn nil\n}\n\nfunc main() {\n\tvar rwc ReadCloser\n\ts := MyStruct{}\n\trwc = s\n\n\t_, ok := rwc.(ReadCloser)\n\tif ok {\n\t\tprintln(\"Embedded interface assertion successful\")\n\t} else {\n\t\tprintln(\"Embedded interface assertion failed\")\n\t}\n}\n",
    "tsCode": "// Generated file based on embedded_interface_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type Closer = null | {\n\tClose(): $.GoError\n}\n\n$.registerInterfaceType(\n  'main.Closer',\n  null, // Zero value for interface is null\n  [{ name: \"Close\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class MyStruct {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Read(p: $.Bytes): [number, $.GoError] {\n\t\treturn [0, null]\n\t}\n\n\tpublic Close(): $.GoError {\n\t\treturn null\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"Read\", args: [{ name: \"p\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Close\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  MyStruct,\n\t  {}\n\t);\n}\n\nexport type ReadCloser = null | Reader & Closer\n\n$.registerInterfaceType(\n  'main.ReadCloser',\n  null, // Zero value for interface is null\n  []\n);\n\nexport type Reader = null | {\n\t// Read reads data from the reader.\n\tRead(_p0: $.Bytes): [number, $.GoError]\n}\n\n$.registerInterfaceType(\n  'main.Reader',\n  null, // Zero value for interface is null\n  [{ name: \"Read\", args: [{ name: \"\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport async function main(): Promise<void> {\n\tlet rwc: ReadCloser = null\n\tlet s = $.markAsStructValue(new MyStruct({}))\n\trwc = $.markAsStructValue(s.clone())\n\n\tlet { ok: ok } = $.typeAssert<ReadCloser>(rwc, 'main.ReadCloser')\n\tif (ok) {\n\t\t$.println(\"Embedded interface assertion successful\")\n\t} else {\n\t\t$.println(\"Embedded interface assertion failed\")\n\t}\n}\n\n",
    "expectedOutput": "Embedded interface assertion successful"
  },
  {
    "name": "embedded_interface_null_assertion",
    "goCode": "package main\n\ntype Reader interface {\n\tRead(p []byte) (int, error)\n}\n\ntype MyReader struct {\n\tReader\n\tname string\n}\n\ntype StringReader struct {\n\tdata string\n\tpos  int\n}\n\nfunc (s *StringReader) Read(p []byte) (int, error) {\n\tif s.pos >= len(s.data) {\n\t\treturn 0, nil\n\t}\n\tn := copy(p, []byte(s.data[s.pos:]))\n\ts.pos += n\n\treturn n, nil\n}\n\nfunc main() {\n\tmr1 := &MyReader{name: \"test1\"}\n\tprintln(mr1.Reader == nil)\n\n\tsr := &StringReader{data: \"hello\", pos: 0}\n\tmr2 := &MyReader{Reader: sr, name: \"test2\"}\n\tprintln(mr2.Reader != nil)\n\n\tbuf := make([]byte, 5)\n\tn, _ := mr2.Read(buf)\n\tprintln(n == 5)\n\n\tprintln(10)\n\tprintln(15)\n\tprintln(true)\n}\n",
    "tsCode": "// Generated file based on embedded_interface_null_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type Reader = null | {\n\tRead(p: $.Bytes): [number, $.GoError]\n}\n\n$.registerInterfaceType(\n  'main.Reader',\n  null, // Zero value for interface is null\n  [{ name: \"Read\", args: [{ name: \"p\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class StringReader {\n\tpublic get data(): string {\n\t\treturn this._fields.data.value\n\t}\n\tpublic set data(value: string) {\n\t\tthis._fields.data.value = value\n\t}\n\n\tpublic get pos(): number {\n\t\treturn this._fields.pos.value\n\t}\n\tpublic set pos(value: number) {\n\t\tthis._fields.pos.value = value\n\t}\n\n\tpublic _fields: {\n\t\tdata: $.VarRef<string>;\n\t\tpos: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{data?: string, pos?: number}>) {\n\t\tthis._fields = {\n\t\t\tdata: $.varRef(init?.data ?? \"\"),\n\t\t\tpos: $.varRef(init?.pos ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): StringReader {\n\t\tconst cloned = new StringReader()\n\t\tcloned._fields = {\n\t\t\tdata: $.varRef(this._fields.data.value),\n\t\t\tpos: $.varRef(this._fields.pos.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Read(p: $.Bytes): [number, $.GoError] {\n\t\tconst s = this\n\t\tif (s.pos >= $.len(s.data)) {\n\t\t\treturn [0, null]\n\t\t}\n\t\tlet n = $.copy(p, $.stringToBytes($.sliceString(s.data, s.pos, undefined)))\n\t\ts.pos += n\n\t\treturn [n, null]\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.StringReader',\n\t  new StringReader(),\n\t  [{ name: \"Read\", args: [{ name: \"p\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  StringReader,\n\t  {\"data\": { kind: $.TypeKind.Basic, name: \"string\" }, \"pos\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport class MyReader {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic get Reader(): Reader {\n\t\treturn this._fields.Reader.value\n\t}\n\tpublic set Reader(value: Reader) {\n\t\tthis._fields.Reader.value = value\n\t}\n\n\tpublic _fields: {\n\t\tReader: $.VarRef<Reader>;\n\t\tname: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{Reader?: Reader, name?: string}>) {\n\t\tthis._fields = {\n\t\t\tReader: $.varRef(init?.Reader ?? null),\n\t\t\tname: $.varRef(init?.name ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyReader {\n\t\tconst cloned = new MyReader()\n\t\tcloned._fields = {\n\t\t\tReader: $.varRef(this._fields.Reader.value),\n\t\t\tname: $.varRef(this._fields.name.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Read(p: $.Bytes): [number, $.GoError] {\n\t\treturn this.Reader!.Read(p)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyReader',\n\t  new MyReader(),\n\t  [],\n\t  MyReader,\n\t  {\"Reader\": \"Reader\", \"name\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet mr1 = new MyReader({name: \"test1\"})\n\t$.println(mr1!.Reader == null)\n\n\tlet sr = new StringReader({data: \"hello\", pos: 0})\n\tlet mr2 = new MyReader({name: \"test2\", Reader: sr})\n\t$.println(mr2!.Reader != null)\n\n\tlet buf = new Uint8Array(5)\n\tlet [n, ] = mr2!.Read(buf)\n\t$.println(n == 5)\n\n\t$.println(10)\n\t$.println(15)\n\t$.println(true)\n}\n\n",
    "expectedOutput": "true\ntrue\ntrue\n10\n15\ntrue\n"
  },
  {
    "name": "filepath_walkfunc_call",
    "goCode": "package main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\n// Simulate billy.Filesystem interface\ntype Filesystem interface {\n\tReadDir(path string) ([]os.FileInfo, error)\n}\n\n// MockFileInfo implements os.FileInfo for testing\ntype MockFileInfo struct {\n\tname string\n\tsize int64\n\tdir  bool\n}\n\nfunc (m MockFileInfo) Name() string       { return m.name }\nfunc (m MockFileInfo) Size() int64        { return m.size }\nfunc (m MockFileInfo) Mode() os.FileMode  { return 0o644 }\nfunc (m MockFileInfo) ModTime() time.Time { return time.Time{} }\nfunc (m MockFileInfo) IsDir() bool        { return m.dir }\nfunc (m MockFileInfo) Sys() interface{}   { return nil }\n\n// MockFilesystem for testing\ntype MockFilesystem struct{}\n\nfunc (fs MockFilesystem) ReadDir(path string) ([]os.FileInfo, error) {\n\treturn []os.FileInfo{\n\t\tMockFileInfo{name: \"file1.txt\", size: 100, dir: false},\n\t\tMockFileInfo{name: \"subdir\", size: 0, dir: true},\n\t}, nil\n}\n\n// This is the exact function signature from the user's example\n// walkFn is filepath.WalkFunc which should be nullable and need ! operator\nfunc walk(fs Filesystem, path string, info os.FileInfo, walkFn filepath.WalkFunc) error {\n\tfilename := path + \"/\" + info.Name()\n\tfileInfo := info\n\n\t// This is the exact call that should generate walkFn!(filename, fileInfo, err)\n\t// but currently generates walkFn(filename, fileInfo, err) - missing !\n\tif err := walkFn(filename, fileInfo, nil); err != nil && err != filepath.SkipDir {\n\t\treturn err\n\t}\n\n\t// Additional test case with error variable\n\tvar walkErr error = nil\n\tif err := walkFn(filename, fileInfo, walkErr); err != nil && err != filepath.SkipDir {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Additional test with direct filepath.WalkFunc usage\nfunc walkFiles(rootPath string, walkFn filepath.WalkFunc) error {\n\t// Test case: direct call to filepath.WalkFunc parameter\n\t// Should generate: walkFn!(rootPath, nil, nil)\n\t// Currently generates: walkFn(rootPath, nil, nil) - missing !\n\treturn walkFn(rootPath, nil, nil)\n}\n\n// Test with filepath.WalkFunc in different contexts\nfunc processPath(walkFn filepath.WalkFunc) {\n\t// Test case: function call in standalone statement\n\t// Should generate: walkFn!(\"test\", nil, nil)\n\twalkFn(\"test\", nil, nil)\n\n\t// Test case: function call in if condition\n\t// Should generate: if walkFn!(\"test\", nil, nil) != nil\n\tif walkFn(\"test\", nil, nil) != nil {\n\t\tprintln(\"Error occurred\")\n\t}\n}\n\nfunc main() {\n\tfs := MockFilesystem{}\n\tfileInfo := MockFileInfo{name: \"test.txt\", size: 50, dir: false}\n\n\t// Test with actual filepath.WalkFunc\n\twalkFunc := func(path string, info os.FileInfo, err error) error {\n\t\tif info != nil {\n\t\t\tprintln(\"Walking:\", path, \"size:\", info.Size())\n\t\t}\n\t\tif err != nil {\n\t\t\tprintln(\"Error:\", err.Error())\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Test the walk function\n\terr := walk(fs, \"/test\", fileInfo, walkFunc)\n\tif err != nil {\n\t\tprintln(\"Walk error:\", err.Error())\n\t}\n\n\t// Test walkFiles\n\terr2 := walkFiles(\"/root\", walkFunc)\n\tif err2 != nil {\n\t\tprintln(\"WalkFiles error:\", err2.Error())\n\t}\n\n\t// Test processPath\n\tprocessPath(walkFunc)\n}\n",
    "tsCode": "// Generated file based on filepath_walkfunc_call.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nimport * as filepath from \"@goscript/path/filepath/index.js\"\n\nimport * as time from \"@goscript/time/index.js\"\n\nexport type Filesystem = null | {\n\tReadDir(path: string): [$.Slice<null | os.FileInfo>, $.GoError]\n}\n\n$.registerInterfaceType(\n  'main.Filesystem',\n  null, // Zero value for interface is null\n  [{ name: \"ReadDir\", args: [{ name: \"path\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Interface, methods: [{ name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"ModTime\", args: [], returns: [{ type: \"Time\" }] }, { name: \"Mode\", args: [], returns: [{ type: \"FileMode\" }] }, { name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }, { name: \"Sys\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }] } } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class MockFileInfo {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._fields.size.value\n\t}\n\tpublic set size(value: number) {\n\t\tthis._fields.size.value = value\n\t}\n\n\tpublic get dir(): boolean {\n\t\treturn this._fields.dir.value\n\t}\n\tpublic set dir(value: boolean) {\n\t\tthis._fields.dir.value = value\n\t}\n\n\tpublic _fields: {\n\t\tname: $.VarRef<string>;\n\t\tsize: $.VarRef<number>;\n\t\tdir: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{dir?: boolean, name?: string, size?: number}>) {\n\t\tthis._fields = {\n\t\t\tname: $.varRef(init?.name ?? \"\"),\n\t\t\tsize: $.varRef(init?.size ?? 0),\n\t\t\tdir: $.varRef(init?.dir ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): MockFileInfo {\n\t\tconst cloned = new MockFileInfo()\n\t\tcloned._fields = {\n\t\t\tname: $.varRef(this._fields.name.value),\n\t\t\tsize: $.varRef(this._fields.size.value),\n\t\t\tdir: $.varRef(this._fields.dir.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Name(): string {\n\t\tconst m = this\n\t\treturn m.name\n\t}\n\n\tpublic Size(): number {\n\t\tconst m = this\n\t\treturn m.size\n\t}\n\n\tpublic Mode(): os.FileMode {\n\t\treturn 0o644\n\t}\n\n\tpublic ModTime(): time.Time {\n\t\treturn $.markAsStructValue(new time.Time({}))\n\t}\n\n\tpublic IsDir(): boolean {\n\t\tconst m = this\n\t\treturn m.dir\n\t}\n\n\tpublic Sys(): null | any {\n\t\treturn null\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MockFileInfo',\n\t  new MockFileInfo(),\n\t  [{ name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }, { name: \"Mode\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"uint32\" } }] }, { name: \"ModTime\", args: [], returns: [{ type: \"Time\" }] }, { name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"Sys\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }],\n\t  MockFileInfo,\n\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"size\": { kind: $.TypeKind.Basic, name: \"int64\" }, \"dir\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\nexport class MockFilesystem {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MockFilesystem {\n\t\tconst cloned = new MockFilesystem()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic ReadDir(path: string): [$.Slice<null | os.FileInfo>, $.GoError] {\n\t\treturn [$.arrayToSlice<null | os.FileInfo>([$.markAsStructValue(new MockFileInfo({dir: false, name: \"file1.txt\", size: 100})), $.markAsStructValue(new MockFileInfo({dir: true, name: \"subdir\", size: 0}))]), null]\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MockFilesystem',\n\t  new MockFilesystem(),\n\t  [{ name: \"ReadDir\", args: [{ name: \"path\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Interface, methods: [{ name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"ModTime\", args: [], returns: [{ type: \"Time\" }] }, { name: \"Mode\", args: [], returns: [{ type: \"FileMode\" }] }, { name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }, { name: \"Sys\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }] } } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  MockFilesystem,\n\t  {}\n\t);\n}\n\n// This is the exact function signature from the user's example\n// walkFn is filepath.WalkFunc which should be nullable and need ! operator\nexport function walk(fs: Filesystem, path: string, info: null | os.FileInfo, walkFn: filepath.WalkFunc | null): $.GoError {\n\tlet filename = path + \"/\" + info!.Name()\n\tlet fileInfo = info\n\n\t// This is the exact call that should generate walkFn!(filename, fileInfo, err)\n\t// but currently generates walkFn(filename, fileInfo, err) - missing !\n\t{\n\t\tlet err = walkFn!(filename, fileInfo, null)\n\t\tif (err != null && err != filepath.SkipDir) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Additional test case with error variable\n\tlet walkErr: $.GoError = null\n\t{\n\t\tlet err = walkFn!(filename, fileInfo, walkErr)\n\t\tif (err != null && err != filepath.SkipDir) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn null\n}\n\n// Additional test with direct filepath.WalkFunc usage\nexport function walkFiles(rootPath: string, walkFn: filepath.WalkFunc | null): $.GoError {\n\t// Test case: direct call to filepath.WalkFunc parameter\n\t// Should generate: walkFn!(rootPath, nil, nil)\n\t// Currently generates: walkFn(rootPath, nil, nil) - missing !\n\treturn walkFn!(rootPath, null, null)\n}\n\n// Test with filepath.WalkFunc in different contexts\nexport function processPath(walkFn: filepath.WalkFunc | null): void {\n\t// Test case: function call in standalone statement\n\t// Should generate: walkFn!(\"test\", nil, nil)\n\twalkFn!(\"test\", null, null)\n\n\t// Test case: function call in if condition\n\t// Should generate: if walkFn!(\"test\", nil, nil) != nil\n\tif (walkFn!(\"test\", null, null) != null) {\n\t\t$.println(\"Error occurred\")\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet fs = $.markAsStructValue(new MockFilesystem({}))\n\tlet fileInfo = $.markAsStructValue(new MockFileInfo({dir: false, name: \"test.txt\", size: 50}))\n\n\t// Test with actual filepath.WalkFunc\n\tlet walkFunc = (path: string, info: null | os.FileInfo, err: $.GoError): $.GoError => {\n\t\tif (info != null) {\n\t\t\t$.println(\"Walking:\", path, \"size:\", info!.Size())\n\t\t}\n\t\tif (err != null) {\n\t\t\t$.println(\"Error:\", err!.Error())\n\t\t}\n\t\treturn null\n\t}\n\n\t// Test the walk function\n\tlet err = walk(fs, \"/test\", fileInfo, walkFunc)\n\tif (err != null) {\n\t\t$.println(\"Walk error:\", err!.Error())\n\t}\n\n\t// Test walkFiles\n\tlet err2 = walkFiles(\"/root\", walkFunc)\n\tif (err2 != null) {\n\t\t$.println(\"WalkFiles error:\", err2!.Error())\n\t}\n\n\t// Test processPath\n\tprocessPath(walkFunc)\n}\n\n",
    "expectedOutput": "Walking: /test/test.txt size: 50\nWalking: /test/test.txt size: 50\n"
  },
  {
    "name": "flag_bitwise_op",
    "goCode": "package main\n\nfunc main() {\n\tconst (\n\t\tO_WRONLY int = 0x1\n\t\tO_CREATE int = 0x40\n\t\tO_APPEND int = 0x400\n\t\tO_TRUNC  int = 0x200\n\t)\n\tflag := O_WRONLY | O_CREATE | O_APPEND\n\tif flag&O_APPEND != 0 {\n\t\tprintln(\"O_APPEND is set: Expected: O_APPEND is set, Actual: O_APPEND is set\")\n\t} else {\n\t\tprintln(\"O_APPEND is not set: Expected: (no output)\")\n\t}\n\tif flag&O_TRUNC != 0 {\n\t\tprintln(\"O_TRUNC is set: Expected: (no output)\")\n\t} else {\n\t\tprintln(\"O_TRUNC is not set: Expected: O_TRUNC is not set, Actual: O_TRUNC is not set\")\n\t}\n\n\tflag = O_WRONLY | O_CREATE\n\tif flag&O_APPEND != 0 {\n\t\tprintln(\"O_APPEND is set: Expected: (no output)\")\n\t} else {\n\t\tprintln(\"O_APPEND is not set: Expected: O_APPEND is not set, Actual: O_APPEND is not set\")\n\t}\n}\n",
    "tsCode": "// Generated file based on flag_bitwise_op.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet O_WRONLY: number = 0x1\n\tlet O_CREATE: number = 0x40\n\tlet O_APPEND: number = 0x400\n\tlet O_TRUNC: number = 0x200\n\tlet flag = ((1 | 64) | 1024)\n\tif ((flag & 1024) != 0) {\n\t\t$.println(\"O_APPEND is set: Expected: O_APPEND is set, Actual: O_APPEND is set\")\n\t} else {\n\t\t$.println(\"O_APPEND is not set: Expected: (no output)\")\n\t}\n\tif ((flag & 512) != 0) {\n\t\t$.println(\"O_TRUNC is set: Expected: (no output)\")\n\t} else {\n\t\t$.println(\"O_TRUNC is not set: Expected: O_TRUNC is not set, Actual: O_TRUNC is not set\")\n\t}\n\n\tflag = (1 | 64)\n\tif ((flag & 1024) != 0) {\n\t\t$.println(\"O_APPEND is set: Expected: (no output)\")\n\t} else {\n\t\t$.println(\"O_APPEND is not set: Expected: O_APPEND is not set, Actual: O_APPEND is not set\")\n\t}\n}\n\n",
    "expectedOutput": "O_APPEND is set: Expected: O_APPEND is set, Actual: O_APPEND is set\nO_TRUNC is not set: Expected: O_TRUNC is not set, Actual: O_TRUNC is not set\nO_APPEND is not set: Expected: O_APPEND is not set, Actual: O_APPEND is not set"
  },
  {
    "name": "float64",
    "goCode": "package main\n\nfunc main() {\n\tvar a float64 = 1.23 //nolint:staticcheck\n\tb := 4.56\n\tvar c float64\n\n\tc = a + b\n\tprintln(\"a + b =\", c)\n\n\tc = a - b\n\tprintln(\"a - b =\", c)\n\n\tc = a * b\n\tprintln(\"a * b =\", c)\n\n\tc = a / b\n\tprintln(\"a / b =\", c)\n\n\t// Assignment\n\td := 7.89\n\tc = d\n\tprintln(\"c =\", c)\n\n\t// More complex expression\n\te := (a + b) * (c - d) / a\n\tprintln(\"(a + b) * (c - d) / a =\", e)\n}\n",
    "tsCode": "// Generated file based on float64.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t//nolint:staticcheck\n\tlet a: number = 1.23\n\tlet b = 4.56\n\tlet c: number = 0\n\n\tc = a + b\n\t$.println(\"a + b =\", c)\n\n\tc = a - b\n\t$.println(\"a - b =\", c)\n\n\tc = a * b\n\t$.println(\"a * b =\", c)\n\n\tc = a / b\n\t$.println(\"a / b =\", c)\n\n\t// Assignment\n\tlet d = 7.89\n\tc = d\n\t$.println(\"c =\", c)\n\n\t// More complex expression\n\tlet e = (a + b) * (c - d) / a\n\t$.println(\"(a + b) * (c - d) / a =\", e)\n}\n\n",
    "expectedOutput": "a + b = 5.789999999999999\na - b = -3.3299999999999996\na * b = 5.6088\na / b = 0.26973684210526316\nc = 7.89\n(a + b) * (c - d) / a = 0"
  },
  {
    "name": "for_init_exprstmt",
    "goCode": "package main\n\nfunc init_func() {\n\tprintln(\"init_func called\")\n}\n\nfunc main() {\n\t// Using a function call in the for loop's init statement\n\t// The condition is false to prevent the loop body from executing during the test,\n\t// focusing only on the init part's translation and execution.\n\tfor init_func(); false; {\n\t\tprintln(\"loop body (should not be printed)\")\n\t}\n\tprintln(\"done\")\n}\n",
    "tsCode": "// Generated file based on for_init_exprstmt.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function init_func(): void {\n\t$.println(\"init_func called\")\n}\n\nexport async function main(): Promise<void> {\n\t// Using a function call in the for loop's init statement\n\t// The condition is false to prevent the loop body from executing during the test,\n\t// focusing only on the init part's translation and execution.\n\tfor (init_func(); false; ) {\n\t\t$.println(\"loop body (should not be printed)\")\n\t}\n\t$.println(\"done\")\n}\n\n",
    "expectedOutput": "init_func called\ndone"
  },
  {
    "name": "for_init_multi_assign",
    "goCode": "package main\n\nfunc main() {\n\tfor i, j := 0, 1; i < 2; i++ {\n\t\tprintln(i, j)\n\t\tj += 10 // Modify j to see a clearer change in output\n\t}\n}\n",
    "tsCode": "// Generated file based on for_init_multi_assign.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\n\t// Modify j to see a clearer change in output\n\tfor (let i = 0, j = 1; i < 2; i++) {\n\t\t$.println(i, j)\n\t\tj += 10 // Modify j to see a clearer change in output\n\t}\n}\n\n",
    "expectedOutput": "0 1\n1 11"
  },
  {
    "name": "for_init_value_ok",
    "goCode": "package main\n\nfunc main() {\n\tm := make(map[string]int)\n\tm[\"key1\"] = 10\n\tm[\"key2\"] = 20\n\n\t// This should trigger the compiler error: for loop initialization with value, ok pattern\n\tfor value, ok := m[\"key1\"]; ok; {\n\t\tprintln(\"value:\", value)\n\t\tbreak\n\t}\n\n\t// Another case that might trigger the error\n\tfor v, exists := m[\"key2\"]; exists && v > 0; {\n\t\tprintln(\"v:\", v)\n\t\tbreak\n\t}\n}\n",
    "tsCode": "// Generated file based on for_init_value_ok.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet m = $.makeMap<string, number>()\n\t$.mapSet(m, \"key1\", 10)\n\t$.mapSet(m, \"key2\", 20)\n\n\t// This should trigger the compiler error: for loop initialization with value, ok pattern\n\tfor (let [value, ok] = $.mapGet(m, \"key1\", 0); ok; ) {\n\t\t$.println(\"value:\", value)\n\t\tbreak\n\t}\n\n\t// Another case that might trigger the error\n\tfor (let [v, exists] = $.mapGet(m, \"key2\", 0); exists && v > 0; ) {\n\t\t$.println(\"v:\", v)\n\t\tbreak\n\t}\n}\n\n",
    "expectedOutput": "value: 10\nv: 20\n"
  },
  {
    "name": "for_loop_basic",
    "goCode": "package main\n\nfunc main() {\n\tprintln(\"Starting loop\")\n\tfor i := 0; i < 3; i++ {\n\t\tprintln(\"Iteration:\", i)\n\t}\n\tprintln(\"Loop finished\")\n\n\tprintln(\"Starting loop\")\n\tx := 0\n\tfor range 5 {\n\t\tprintln(\"Iteration:\", x)\n\t\tx++\n\t}\n\tprintln(\"Loop finished\")\n}\n",
    "tsCode": "// Generated file based on for_loop_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t$.println(\"Starting loop\")\n\tfor (let i = 0; i < 3; i++) {\n\t\t$.println(\"Iteration:\", i)\n\t}\n\t$.println(\"Loop finished\")\n\n\t$.println(\"Starting loop\")\n\tlet x = 0\n\tfor (let _i = 0; _i < 5; _i++) {{\n\t\t$.println(\"Iteration:\", x)\n\t\tx++\n\t}\n}\n$.println(\"Loop finished\")\n}\n\n",
    "expectedOutput": "Starting loop\nIteration: 0\nIteration: 1\nIteration: 2\nLoop finished\nStarting loop\nIteration: 0\nIteration: 1\nIteration: 2\nIteration: 3\nIteration: 4\nLoop finished"
  },
  {
    "name": "for_loop_condition_only",
    "goCode": "package main\n\nfunc main() {\n\ti := 0\n\tfor i < 3 {\n\t\tprintln(\"Current value:\", i)\n\t\ti = i + 1\n\t}\n\tprintln(\"Loop finished\")\n}\n",
    "tsCode": "// Generated file based on for_loop_condition_only.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet i = 0\n\tfor (; i < 3; ) {\n\t\t$.println(\"Current value:\", i)\n\t\ti = i + 1\n\t}\n\t$.println(\"Loop finished\")\n}\n\n",
    "expectedOutput": "Current value: 0\nCurrent value: 1\nCurrent value: 2\nLoop finished"
  },
  {
    "name": "for_loop_infinite",
    "goCode": "package main\n\nfunc main() {\n\ti := 0\n\tfor {\n\t\tprintln(\"Looping forever...\")\n\t\ti++\n\t\tif i >= 3 {\n\t\t\tbreak\n\t\t}\n\t}\n\tprintln(\"Loop finished\")\n}\n",
    "tsCode": "// Generated file based on for_loop_infinite.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet i = 0\n\tfor (; ; ) {\n\t\t$.println(\"Looping forever...\")\n\t\ti++\n\t\tif (i >= 3) {\n\t\t\tbreak\n\t\t}\n\t}\n\t$.println(\"Loop finished\")\n}\n\n",
    "expectedOutput": "Looping forever...\nLooping forever...\nLooping forever...\nLoop finished"
  },
  {
    "name": "for_loop_multi_assign_mismatch",
    "goCode": "package main\n\nfunc getValues() (int, bool) {\n\treturn 42, true\n}\n\nfunc main() {\n\t// This should trigger the error: multi-assignment in for loop init\n\t// where lhs has 2 variables but rhs has 1 expression that returns 2 values\n\t// but is not a map access\n\tfor value, ok := getValues(); ok; {\n\t\tprintln(\"value:\", value)\n\t\tbreak\n\t}\n\n\tprintln(\"done\")\n}\n",
    "tsCode": "// Generated file based on for_loop_multi_assign_mismatch.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function getValues(): [number, boolean] {\n\treturn [42, true]\n}\n\nexport async function main(): Promise<void> {\n\t// This should trigger the error: multi-assignment in for loop init\n\t// where lhs has 2 variables but rhs has 1 expression that returns 2 values\n\t// but is not a map access\n\tfor (let [value, ok] = getValues(); ok; ) {\n\t\t$.println(\"value:\", value)\n\t\tbreak\n\t}\n\n\t$.println(\"done\")\n}\n\n",
    "expectedOutput": "value: 42\ndone\n"
  },
  {
    "name": "for_post_assign_stmt",
    "goCode": "package main\n\nfunc main() {\n\tvar x int\n\t// The post statement 'x = i' is an AssignStmt\n\tfor i := 0; i < 3; x = i {\n\t\tprintln(\"looping, i:\", i, \"x_before_post:\", x)\n\t\t// Increment i inside the loop body to ensure the loop progresses\n\t\t// and to clearly separate the loop's own increment from the post statement.\n\t\ti++\n\t}\n\tprintln(\"final x:\", x)\n}\n",
    "tsCode": "// Generated file based on for_post_assign_stmt.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet x: number = 0\n\t// The post statement 'x = i' is an AssignStmt\n\n\t// Increment i inside the loop body to ensure the loop progresses\n\t// and to clearly separate the loop's own increment from the post statement.\n\tfor (let i = 0; i < 3; x = i) {\n\t\t$.println(\"looping, i:\", i, \"x_before_post:\", x)\n\t\t// Increment i inside the loop body to ensure the loop progresses\n\t\t// and to clearly separate the loop's own increment from the post statement.\n\t\ti++\n\t}\n\t$.println(\"final x:\", x)\n}\n\n",
    "expectedOutput": "looping, i: 0 x_before_post: 0\nlooping, i: 1 x_before_post: 1\nlooping, i: 2 x_before_post: 2\nfinal x: 3"
  },
  {
    "name": "for_post_exprstmt",
    "goCode": "package main\n\nvar counter = 0\n\nfunc increment_counter() {\n\tcounter++\n\tprintln(\"counter incremented to\", counter)\n}\n\nfunc main() {\n\tfor i := 0; i < 2; increment_counter() {\n\t\tprintln(\"loop iteration:\", i)\n\t\t// We need to manually increment i or change the condition\n\t\t// to ensure the loop terminates as increment_counter() in post\n\t\t// does not affect 'i'.\n\t\ti++\n\t}\n\tprintln(\"done\", \"final counter:\", counter)\n}\n",
    "tsCode": "// Generated file based on for_post_exprstmt.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport let counter: number = 0\n\nexport function increment_counter(): void {\n\tcounter++\n\t$.println(\"counter incremented to\", counter)\n}\n\nexport async function main(): Promise<void> {\n\n\t// We need to manually increment i or change the condition\n\t// to ensure the loop terminates as increment_counter() in post\n\t// does not affect 'i'.\n\tfor (let i = 0; i < 2; increment_counter()) {\n\t\t$.println(\"loop iteration:\", i)\n\t\t// We need to manually increment i or change the condition\n\t\t// to ensure the loop terminates as increment_counter() in post\n\t\t// does not affect 'i'.\n\t\ti++\n\t}\n\t$.println(\"done\", \"final counter:\", counter)\n}\n\n",
    "expectedOutput": "loop iteration: 0\ncounter incremented to 1\nloop iteration: 1\ncounter incremented to 2\ndone final counter: 2"
  },
  {
    "name": "for_post_incdec",
    "goCode": "package main\n\nfunc main() {\n\tfor i := 0; i < 1; i++ {\n\t\tprintln(i)\n\t}\n\tprintln(\"done\")\n}\n",
    "tsCode": "// Generated file based on for_post_incdec.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tfor (let i = 0; i < 1; i++) {\n\t\t$.println(i)\n\t}\n\t$.println(\"done\")\n}\n\n",
    "expectedOutput": "0\ndone"
  },
  {
    "name": "for_post_multi_assign",
    "goCode": "package main\n\nfunc main() {\n\tfor i, j := 0, 5; i < j; i, j = i+1, j-1 {\n\t\tprintln(i, j)\n\t}\n\tprintln(\"done\")\n}\n",
    "tsCode": "// Generated file based on for_post_multi_assign.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tfor (let i = 0, j = 5; i < j; [i, j] = [i + 1, j - 1]) {\n\t\t$.println(i, j)\n\t}\n\t$.println(\"done\")\n}\n\n",
    "expectedOutput": "0 5\n1 4\n2 3\ndone"
  },
  {
    "name": "for_range",
    "goCode": "package main\n\nfunc main() {\n\tnums := []int{2, 3, 4}\n\tsum := 0\n\tfor _, num := range nums {\n\t\tsum += num\n\t}\n\tprintln(\"sum:\", sum)\n\n\tfor i, num := range nums {\n\t\tprintln(\"index:\", i, \"value:\", num)\n\t}\n\n\t// Test ranging over an array\n\tarr := [3]string{\"a\", \"b\", \"c\"}\n\tfor i, s := range arr {\n\t\tprintln(\"index:\", i, \"value:\", s)\n\t}\n\n\t// Test ranging over a string\n\tstr := \"go\"\n\tfor i, c := range str {\n\t\tprintln(\"index:\", i, \"value:\", c) // Note: c will be a rune (int32)\n\t}\n\n\t// Test ranging over a slice without key or value\n\tprintln(\"Ranging over slice (no key/value):\")\n\tfor range nums {\n\t\tprintln(\"Iterating slice\")\n\t}\n\n\t// Test ranging over an array without key or value\n\tprintln(\"Ranging over array (no key/value):\")\n\tfor range arr {\n\t\tprintln(\"Iterating array\")\n\t}\n\n\t// Test ranging over a string without key or value\n\tprintln(\"Ranging over string (no key/value):\")\n\tfor range str {\n\t\tprintln(\"Iterating string\")\n\t}\n}\n",
    "tsCode": "// Generated file based on for_range.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet nums = $.arrayToSlice<number>([2, 3, 4])\n\tlet sum = 0\n\tfor (let _i = 0; _i < $.len(nums); _i++) {\n\t\tlet num = nums![_i]\n\t\t{\n\t\t\tsum += num\n\t\t}\n\t}\n\t$.println(\"sum:\", sum)\n\n\tfor (let i = 0; i < $.len(nums); i++) {\n\t\tlet num = nums![i]\n\t\t{\n\t\t\t$.println(\"index:\", i, \"value:\", num)\n\t\t}\n\t}\n\n\t// Test ranging over an array\n\tlet arr = $.arrayToSlice<string>([\"a\", \"b\", \"c\"])\n\tfor (let i = 0; i < $.len(arr); i++) {\n\t\tlet s = arr![i]\n\t\t{\n\t\t\t$.println(\"index:\", i, \"value:\", s)\n\t\t}\n\t}\n\n\t// Test ranging over a string\n\tlet str = \"go\"\n\n\t// Note: c will be a rune (int32)\n\t{\n\t\tconst _runes = $.stringToRunes(str)\n\t\tfor (let i = 0; i < _runes.length; i++) {\n\t\t\tlet c = _runes[i]\n\t\t\t{\n\t\t\t\t$.println(\"index:\", i, \"value:\", c) // Note: c will be a rune (int32)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test ranging over a slice without key or value\n\t$.println(\"Ranging over slice (no key/value):\")\n\tfor (let _i = 0; _i < $.len(nums); _i++) {\n\t\t{\n\t\t\t$.println(\"Iterating slice\")\n\t\t}\n\t}\n\n\t// Test ranging over an array without key or value\n\t$.println(\"Ranging over array (no key/value):\")\n\tfor (let _i = 0; _i < $.len(arr); _i++) {\n\t\t{\n\t\t\t$.println(\"Iterating array\")\n\t\t}\n\t}\n\n\t// Test ranging over a string without key or value\n\t$.println(\"Ranging over string (no key/value):\")\n\t{\n\t\tconst _runes = $.stringToRunes(str)\n\t\tfor (let i = 0; i < _runes.length; i++) {\n\t\t\t{\n\t\t\t\t$.println(\"Iterating string\")\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "sum: 9\nindex: 0 value: 2\nindex: 1 value: 3\nindex: 2 value: 4\nindex: 0 value: a\nindex: 1 value: b\nindex: 2 value: c\nindex: 0 value: 103\nindex: 1 value: 111\nRanging over slice (no key/value):\nIterating slice\nIterating slice\nIterating slice\nRanging over array (no key/value):\nIterating array\nIterating array\nIterating array\nRanging over string (no key/value):\nIterating string\nIterating string"
  },
  {
    "name": "for_range_channel",
    "goCode": "package main\n\nfunc main() {\n\tc := make(chan int, 1)\n\tc <- 0\n\tclose(c)\n\n\tfor x := range c {\n\t\tprintln(x)\n\t}\n\n\t// test with = instead of := within the for range\n\tc = make(chan int, 1)\n\tc <- 1\n\tclose(c)\n\n\tvar y int\n\tfor y = range c {\n\t\tprintln(y)\n\t}\n}\n",
    "tsCode": "// Generated file based on for_range_channel.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet c = $.makeChannel<number>(1, 0, 'both')\n\tawait $.chanSend(c, 0)\n\tc.close()\n\n\tfor (;;) {\n\t\tconst { value: x, ok: _ok } = await $.chanRecvWithOk(c)\n\t\tif (!_ok) break\n\t\t{\n\t\t\t$.println(x)\n\t\t}\n\t}\n\n\t// test with = instead of := within the for range\n\tc = $.makeChannel<number>(1, 0, 'both')\n\tawait $.chanSend(c, 1)\n\tc.close()\n\n\tlet y: number = 0\n\tfor (;;) {\n\t\tlet _ok\n\t\t;({ value: y, ok: _ok } = await $.chanRecvWithOk(c))\n\t\tif (!_ok) break\n\t\t{\n\t\t\t$.println(y)\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "0\n1"
  },
  {
    "name": "for_range_index_use",
    "goCode": "package main\n\nfunc main() {\n\tslice := []int{10, 20, 30, 40, 50}\n\tsum := 0\n\tfor idx, val := range slice {\n\t\tsum += val\n\t\tprintln(\"Range idx:\", idx, \"val:\", val)\n\t}\n\tprintln(\"Sum:\", sum)\n}\n",
    "tsCode": "// Generated file based on for_range_index_use.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet slice = $.arrayToSlice<number>([10, 20, 30, 40, 50])\n\tlet sum = 0\n\tfor (let idx = 0; idx < $.len(slice); idx++) {\n\t\tlet val = slice![idx]\n\t\t{\n\t\t\tsum += val\n\t\t\t$.println(\"Range idx:\", idx, \"val:\", val)\n\t\t}\n\t}\n\t$.println(\"Sum:\", sum)\n}\n\n",
    "expectedOutput": "Range idx: 0 val: 10\nRange idx: 1 val: 20\nRange idx: 2 val: 30\nRange idx: 3 val: 40\nRange idx: 4 val: 50\nSum: 150"
  },
  {
    "name": "for_range_key_only",
    "goCode": "package main\n\nfunc main() {\n\ts := []int{10, 20, 30}\n\tprintln(\"Looping over slice (key only):\")\n\tfor i := range s {\n\t\tprintln(i)\n\t}\n\t// Expected output:\n\t// 0\n\t// 1\n\t// 2\n\n\ta := [2]string{\"alpha\", \"beta\"}\n\tprintln(\"Looping over array (key only):\")\n\tfor k := range a {\n\t\tprintln(k)\n\t}\n\t// Expected output:\n\t// 0\n\t// 1\n}\n",
    "tsCode": "// Generated file based on for_range_key_only.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet s = $.arrayToSlice<number>([10, 20, 30])\n\t$.println(\"Looping over slice (key only):\")\n\n\t// Expected output:\n\t// 0\n\t// 1\n\t// 2\n\tfor (let i = 0; i < $.len(s); i++) {\n\t\t{\n\t\t\t$.println(i)\n\t\t}\n\t}\n\n\tlet a = $.arrayToSlice<string>([\"alpha\", \"beta\"])\n\t$.println(\"Looping over array (key only):\")\n\n\t// Expected output:\n\t// 0\n\t// 1\n\tfor (let k = 0; k < $.len(a); k++) {\n\t\t{\n\t\t\t$.println(k)\n\t\t}\n\t}\n\t// Expected output:\n\t// 0\n\t// 1\n}\n\n",
    "expectedOutput": "Looping over slice (key only):\n0\n1\n2\nLooping over array (key only):\n0\n1"
  },
  {
    "name": "for_range_no_vars",
    "goCode": "package main\n\nfunc main() {\n\ts := []int{10, 20, 30}\n\tprintln(\"Looping over slice (no vars):\")\n\tcount := 0\n\tfor range s {\n\t\tcount++\n\t}\n\tprintln(count) // Expected output: 3\n\n\ta := [2]string{\"alpha\", \"beta\"}\n\tprintln(\"Looping over array (no vars):\")\n\tarrCount := 0\n\tfor range a {\n\t\tprintln(a[arrCount])\n\t\tarrCount++\n\t}\n\tprintln(arrCount) // Expected output: 2\n\n\tprintln(\"Ranging over number (no vars):\")\n\tnumCount := 0\n\tfor range 5 {\n\t\tnumCount++\n\t}\n\tprintln(numCount) // Expected output: 5\n}\n",
    "tsCode": "// Generated file based on for_range_no_vars.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet s = $.arrayToSlice<number>([10, 20, 30])\n\t$.println(\"Looping over slice (no vars):\")\n\tlet count = 0\n\tfor (let _i = 0; _i < $.len(s); _i++) {\n\t\t{\n\t\t\tcount++\n\t\t}\n\t}\n\t$.println(count) // Expected output: 3\n\n\tlet a = $.arrayToSlice<string>([\"alpha\", \"beta\"])\n\t$.println(\"Looping over array (no vars):\")\n\tlet arrCount = 0\n\tfor (let _i = 0; _i < $.len(a); _i++) {\n\t\t{\n\t\t\t$.println(a![arrCount])\n\t\t\tarrCount++\n\t\t}\n\t}\n\t$.println(arrCount) // Expected output: 2\n\n\t$.println(\"Ranging over number (no vars):\")\n\tlet numCount = 0\n\tfor (let _i = 0; _i < 5; _i++) {{\n\t\tnumCount++\n\t}\n}\n$.println(numCount) // Expected output: 5\n}\n\n",
    "expectedOutput": "Looping over slice (no vars):\n3\nLooping over array (no vars):\nalpha\nbeta\n2\nRanging over number (no vars):\n5"
  },
  {
    "name": "for_range_value_only",
    "goCode": "package main\n\nfunc main() {\n\ts := []int{10, 20, 30}\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t\tprintln(v)\n\t}\n\tprintln(sum)\n\n\tarr := [3]string{\"a\", \"b\", \"c\"}\n\tconcat := \"\"\n\tfor _, val := range arr {\n\t\tconcat += val\n\t\tprintln(val)\n\t}\n\tprintln(concat)\n\n\t// Test with blank identifier for value (should still iterate)\n\tprintln(\"Ranging with blank identifier for value:\")\n\tcount := 0\n\tfor range s { // Both key and value are blank identifiers\n\t\tcount++\n\t}\n\tprintln(count) // Should be 3\n}\n",
    "tsCode": "// Generated file based on for_range_value_only.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet s = $.arrayToSlice<number>([10, 20, 30])\n\tlet sum = 0\n\tfor (let _i = 0; _i < $.len(s); _i++) {\n\t\tlet v = s![_i]\n\t\t{\n\t\t\tsum += v\n\t\t\t$.println(v)\n\t\t}\n\t}\n\t$.println(sum)\n\n\tlet arr = $.arrayToSlice<string>([\"a\", \"b\", \"c\"])\n\tlet concat = \"\"\n\tfor (let _i = 0; _i < $.len(arr); _i++) {\n\t\tlet val = arr![_i]\n\t\t{\n\t\t\tconcat += val\n\t\t\t$.println(val)\n\t\t}\n\t}\n\t$.println(concat)\n\n\t// Test with blank identifier for value (should still iterate)\n\t$.println(\"Ranging with blank identifier for value:\")\n\tlet count = 0\n\t// Both key and value are blank identifiers\n\tfor (let _i = 0; _i < $.len(s); _i++) {\n\t\t{\n\t\t\t// Both key and value are blank identifiers\n\t\t\tcount++\n\t\t}\n\t}\n\t$.println(count) // Should be 3\n}\n\n",
    "expectedOutput": "10\n20\n30\n60\na\nb\nc\nabc\nRanging with blank identifier for value:\n3"
  },
  {
    "name": "func_literal",
    "goCode": "package main\n\nfunc main() {\n\tgreet := func(name string) string {\n\t\treturn \"Hello, \" + name\n\t}\n\n\tmessage := greet(\"world\")\n\tprintln(message)\n}\n",
    "tsCode": "// Generated file based on func_literal.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet greet = (name: string): string => {\n\t\treturn \"Hello, \" + name\n\t}\n\n\tlet message = greet!(\"world\")\n\t$.println(message)\n}\n\n",
    "expectedOutput": "Hello, world"
  },
  {
    "name": "function_call_result_assignment",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n\tmyBool   bool //nolint:unused\n}\n\n// NewMyStruct creates a new MyStruct instance.\nfunc NewMyStruct(s string) MyStruct {\n\treturn MyStruct{MyString: s}\n}\n\nfunc main() {\n\t// === Function Call Result Assignment (Value Copy) ===\n\t// Assigning the result of a function that returns a struct creates a copy.\n\tstructFromFunc := NewMyStruct(\"function result\")\n\tstructFromFuncCopy := structFromFunc\n\tstructFromFuncCopy.MyString = \"modified function result copy\"\n\t// Expected: \"function result\"\n\tprintln(\"Original struct from function: Expected: function result, Actual: \" + structFromFunc.MyString)\n\t// Expected: \"modified function result copy\"\n\tprintln(\"Modified struct from function copy: Expected: modified function result copy, Actual: \" + structFromFuncCopy.MyString)\n}\n",
    "tsCode": "// Generated file based on function_call_result_assignment.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get myBool(): boolean {\n\t\treturn this._fields.myBool.value\n\t}\n\tpublic set myBool(value: boolean) {\n\t\tthis._fields.myBool.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t\tmyBool: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string, myBool?: boolean}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\"),\n\t\t\tmyBool: $.varRef(init?.myBool ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value),\n\t\t\tmyBool: $.varRef(this._fields.myBool.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }, \"myBool\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\n// NewMyStruct creates a new MyStruct instance.\nexport function NewMyStruct(s: string): MyStruct {\n\treturn $.markAsStructValue(new MyStruct({MyString: s}))\n}\n\nexport async function main(): Promise<void> {\n\t// === Function Call Result Assignment (Value Copy) ===\n\t// Assigning the result of a function that returns a struct creates a copy.\n\tlet structFromFunc = $.markAsStructValue(NewMyStruct(\"function result\").clone())\n\tlet structFromFuncCopy = $.markAsStructValue(structFromFunc.clone())\n\tstructFromFuncCopy.MyString = \"modified function result copy\"\n\t// Expected: \"function result\"\n\t$.println(\"Original struct from function: Expected: function result, Actual: \" + structFromFunc.MyString)\n\t// Expected: \"modified function result copy\"\n\t$.println(\"Modified struct from function copy: Expected: modified function result copy, Actual: \" + structFromFuncCopy.MyString)\n}\n\n",
    "expectedOutput": "Original struct from function: Expected: function result, Actual: function result\nModified struct from function copy: Expected: modified function result copy, Actual: modified function result copy"
  },
  {
    "name": "function_call_variable_shadowing",
    "goCode": "package main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// Mock billy.Filesystem for testing\ntype Filesystem interface {\n\tLstat(filename string) (os.FileInfo, error)\n}\n\ntype MockFilesystem struct{}\n\nfunc (fs MockFilesystem) Lstat(filename string) (os.FileInfo, error) {\n\treturn nil, nil\n}\n\n// Reproduce the exact variable shadowing scenario that causes the issue\nfunc walkWithShadowing(fs Filesystem, path string, info os.FileInfo, walkFn filepath.WalkFunc) error {\n\t// This reproduces the pattern where variable shadowing occurs with := assignment\n\tfileInfo, err := fs.Lstat(path)\n\tif err != nil {\n\t\t// This is the problematic line that generates:\n\t\t// let err = walkFn(filename, fileInfo, _temp_err) - missing !\n\t\t// Instead of:\n\t\t// let err = walkFn!(filename, fileInfo, _temp_err) - with !\n\t\tif err := walkFn(path, fileInfo, err); err != nil && err != filepath.SkipDir {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Additional test cases with different variable shadowing scenarios\nfunc testShadowing1(walkFn filepath.WalkFunc) error {\n\tvar err error = nil\n\t// Case 1: Direct shadowing with if statement\n\tif err := walkFn(\"test1\", nil, err); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc testShadowing2(walkFn filepath.WalkFunc) error {\n\t// Case 2: Multiple levels of shadowing\n\touterErr := os.ErrNotExist // Use a known error instead of errors.New\n\t{\n\t\tif err := walkFn(\"test2\", nil, outerErr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc testShadowing3(walkFn filepath.WalkFunc) error {\n\t// Case 3: Shadowing in for loop\n\terrorList := []error{nil, os.ErrNotExist} // Use os.ErrNotExist instead of errors.New\n\tfor _, err := range errorList {\n\t\tif err := walkFn(\"test3\", nil, err); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Non-shadowing case for comparison\nfunc testNoShadowing(walkFn filepath.WalkFunc) error {\n\t// This should work correctly (no shadowing)\n\treturn walkFn(\"test\", nil, nil)\n}\n\nfunc main() {\n\tfs := MockFilesystem{}\n\n\twalkFunc := func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tprintln(\"Error:\", err.Error())\n\t\t}\n\t\tprintln(\"Walking:\", path)\n\t\treturn nil\n\t}\n\n\t// Test the shadowing scenario\n\terr := walkWithShadowing(fs, \"/test\", nil, walkFunc)\n\tif err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t}\n\n\t// Test other shadowing cases\n\ttestShadowing1(walkFunc)\n\ttestShadowing2(walkFunc)\n\ttestShadowing3(walkFunc)\n\ttestNoShadowing(walkFunc)\n}\n",
    "tsCode": "// Generated file based on function_call_variable_shadowing.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nimport * as filepath from \"@goscript/path/filepath/index.js\"\n\nexport type Filesystem = null | {\n\tLstat(filename: string): [null | os.FileInfo, $.GoError]\n}\n\n$.registerInterfaceType(\n  'main.Filesystem',\n  null, // Zero value for interface is null\n  [{ name: \"Lstat\", args: [{ name: \"filename\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Interface, methods: [{ name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"ModTime\", args: [], returns: [{ type: \"Time\" }] }, { name: \"Mode\", args: [], returns: [{ type: \"FileMode\" }] }, { name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }, { name: \"Sys\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }] } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class MockFilesystem {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MockFilesystem {\n\t\tconst cloned = new MockFilesystem()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Lstat(filename: string): [null | os.FileInfo, $.GoError] {\n\t\treturn [null, null]\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MockFilesystem',\n\t  new MockFilesystem(),\n\t  [{ name: \"Lstat\", args: [{ name: \"filename\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Interface, methods: [{ name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"ModTime\", args: [], returns: [{ type: \"Time\" }] }, { name: \"Mode\", args: [], returns: [{ type: \"FileMode\" }] }, { name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }, { name: \"Sys\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }] } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  MockFilesystem,\n\t  {}\n\t);\n}\n\n// Reproduce the exact variable shadowing scenario that causes the issue\nexport function walkWithShadowing(fs: Filesystem, path: string, info: null | os.FileInfo, walkFn: filepath.WalkFunc | null): $.GoError {\n\t// This reproduces the pattern where variable shadowing occurs with := assignment\n\tlet [fileInfo, err] = fs!.Lstat(path)\n\n\t// This is the problematic line that generates:\n\t// let err = walkFn(filename, fileInfo, _temp_err) - missing !\n\t// Instead of:\n\t// let err = walkFn!(filename, fileInfo, _temp_err) - with !\n\tif (err != null) {\n\t\t// This is the problematic line that generates:\n\t\t// let err = walkFn(filename, fileInfo, _temp_err) - missing !\n\t\t// Instead of:\n\t\t// let err = walkFn!(filename, fileInfo, _temp_err) - with !\n\t\tconst _temp_err = err\n\t\t{\n\t\t\tlet err = walkFn!(path, fileInfo, _temp_err)\n\t\t\tif (err != null && err != filepath.SkipDir) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn null\n}\n\n// Additional test cases with different variable shadowing scenarios\nexport function testShadowing1(walkFn: filepath.WalkFunc | null): $.GoError {\n\tlet err: $.GoError = null\n\t// Case 1: Direct shadowing with if statement\n\tconst _temp_err = err\n\t{\n\t\tlet err = walkFn!(\"test1\", null, _temp_err)\n\t\tif (err != null) {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn null\n}\n\nexport function testShadowing2(walkFn: filepath.WalkFunc | null): $.GoError {\n\t// Case 2: Multiple levels of shadowing\n\tlet outerErr = os.ErrNotExist // Use a known error instead of errors.New\n\t{\n\t\t{\n\t\t\tlet err = walkFn!(\"test2\", null, outerErr)\n\t\t\tif (err != null) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn null\n}\n\nexport function testShadowing3(walkFn: filepath.WalkFunc | null): $.GoError {\n\t// Case 3: Shadowing in for loop\n\tlet errorList = $.arrayToSlice<$.GoError>([null, os.ErrNotExist]) // Use os.ErrNotExist instead of errors.New\n\tfor (let _i = 0; _i < $.len(errorList); _i++) {\n\t\tlet err = errorList![_i]\n\t\t{\n\t\t\tconst _temp_err = err\n\t\t\t{\n\t\t\t\tlet err = walkFn!(\"test3\", null, _temp_err)\n\t\t\t\tif (err != null) {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn null\n}\n\n// Non-shadowing case for comparison\nexport function testNoShadowing(walkFn: filepath.WalkFunc | null): $.GoError {\n\t// This should work correctly (no shadowing)\n\treturn walkFn!(\"test\", null, null)\n}\n\nexport async function main(): Promise<void> {\n\tlet fs = $.markAsStructValue(new MockFilesystem({}))\n\n\tlet walkFunc = (path: string, info: null | os.FileInfo, err: $.GoError): $.GoError => {\n\t\tif (err != null) {\n\t\t\t$.println(\"Error:\", err!.Error())\n\t\t}\n\t\t$.println(\"Walking:\", path)\n\t\treturn null\n\t}\n\n\t// Test the shadowing scenario\n\tlet err = walkWithShadowing(fs, \"/test\", null, walkFunc)\n\tif (err != null) {\n\t\t$.println(\"Error:\", err!.Error())\n\t}\n\n\t// Test other shadowing cases\n\ttestShadowing1(walkFunc)\n\ttestShadowing2(walkFunc)\n\ttestShadowing3(walkFunc)\n\ttestNoShadowing(walkFunc)\n}\n\n",
    "expectedOutput": "Walking: test1\nError: file does not exist\nWalking: test2\nWalking: test3\nError: file does not exist\nWalking: test3\nWalking: test\n"
  },
  {
    "name": "function_returns_function",
    "goCode": "package main\n\nfunc getAdder(x int) func(int) int {\n\treturn func(y int) int {\n\t\treturn x + y\n\t}\n}\n\nfunc main() {\n\tadder := getAdder(5)\n\tresult := adder(3)\n\tprintln(\"Result:\", result)\n}\n",
    "tsCode": "// Generated file based on function_returns_function.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function getAdder(x: number): ((p0: number) => number) | null {\n\treturn (y: number): number => {\n\t\treturn x + y\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet adder = getAdder(5)\n\tlet result = adder!(3)\n\t$.println(\"Result:\", result)\n}\n\n",
    "expectedOutput": "Result: 8\n"
  },
  {
    "name": "function_signature_type",
    "goCode": "package main\n\n// Test case 1: Named parameters, multiple return values\ntype Func1 func(a int, b string) (bool, error)\n\nvar fn1 Func1\n\n// Test case 2: Unnamed parameters, single return value\ntype Func2 func(int, string) bool\n\nvar fn2 Func2\n\n// Test case 3: No parameters, no return value\ntype Func3 func()\n\nvar fn3 Func3\n\n// Test case 4: Variadic parameter\n// Note: The current implementation of WriteSignatureType might not fully support\n// variadic parameters in the way Go handles them (e.g. as a slice).\n// This will test its current translation.\ntype Func4 func(a int, b ...string)\n\nvar fn4 Func4\n\n// Custom error type\ntype MyError struct {\n\ts string\n}\n\nfunc NewMyError(text string) *MyError {\n\treturn &MyError{s: text}\n}\n\nfunc (e *MyError) Error() string {\n\treturn e.s\n}\n\nfunc main() {\n\tfn1 = func(a int, b string) (bool, error) {\n\t\tprintln(\"fn1 called with:\", a, b)\n\t\tif a > 0 {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, NewMyError(\"a was not positive\")\n\t}\n\n\tfn2 = func(p0 int, p1 string) bool {\n\t\tprintln(\"fn2 called with:\", p0, p1)\n\t\treturn p0 == len(p1)\n\t}\n\n\tfn3 = func() {\n\t\tprintln(\"fn3 called\")\n\t}\n\n\tfn4 = func(a int, b ...string) {\n\t\tprintln(\"fn4 called with: \", a)\n\t\tfor _, s := range b {\n\t\t\tprintln(\" \", s)\n\t\t}\n\t\tprintln() // Newline after all strings\n\t}\n\n\tres1, err1 := fn1(10, \"hello\")\n\tprintln(\"fn1 result 1: \", res1, \" \")\n\tif err1 != nil {\n\t\tprintln(err1.Error())\n\t} else {\n\t\tprintln(\"nil\")\n\t}\n\n\tres1_2, err1_2 := fn1(-5, \"world\")\n\tprintln(\"fn1 result 2: \", res1_2, \" \")\n\tif err1_2 != nil {\n\t\tprintln(err1_2.Error())\n\t} else {\n\t\tprintln(\"nil\")\n\t}\n\n\tres2 := fn2(5, \"hello\")\n\tprintln(\"fn2 result 1:\", res2)\n\n\tres2_2 := fn2(3, \"hey\")\n\tprintln(\"fn2 result 2:\", res2_2)\n\n\tfn3()\n\n\tfn4(1)\n\tfn4(2, \"one\")\n\tfn4(3, \"two\", \"three\")\n}\n",
    "tsCode": "// Generated file based on function_signature_type.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type Func1 = ((a: number, b: string) => [boolean, $.GoError]) | null;\n\nexport type Func2 = ((p0: number, p1: string) => boolean) | null;\n\nexport type Func3 = (() => void) | null;\n\nexport type Func4 = ((a: number, ...b: string[]) => void) | null;\n\nexport class MyError {\n\tpublic get s(): string {\n\t\treturn this._fields.s.value\n\t}\n\tpublic set s(value: string) {\n\t\tthis._fields.s.value = value\n\t}\n\n\tpublic _fields: {\n\t\ts: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{s?: string}>) {\n\t\tthis._fields = {\n\t\t\ts: $.varRef(init?.s ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyError {\n\t\tconst cloned = new MyError()\n\t\tcloned._fields = {\n\t\t\ts: $.varRef(this._fields.s.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Error(): string {\n\t\tconst e = this\n\t\treturn e.s\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyError',\n\t  new MyError(),\n\t  [{ name: \"Error\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  MyError,\n\t  {\"s\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport let fn1: Func1 | null = null\n\nexport let fn2: Func2 | null = null\n\nexport let fn3: Func3 | null = null\n\nexport let fn4: Func4 | null = null\n\nexport function NewMyError(text: string): MyError | null {\n\treturn new MyError({s: text})\n}\n\nexport async function main(): Promise<void> {\n\tfn1 = (a: number, b: string): [boolean, $.GoError] => {\n\t\t$.println(\"fn1 called with:\", a, b)\n\t\tif (a > 0) {\n\t\t\treturn [true, null]\n\t\t}\n\t\treturn [false, NewMyError(\"a was not positive\")]\n\t}\n\n\tfn2 = (p0: number, p1: string): boolean => {\n\t\t$.println(\"fn2 called with:\", p0, p1)\n\t\treturn p0 == $.len(p1)\n\t}\n\n\tfn3 = (): void => {\n\t\t$.println(\"fn3 called\")\n\t}\n\n\t// Newline after all strings\n\tfn4 = (a: number, ...b: string[]): void => {\n\t\t$.println(\"fn4 called with: \", a)\n\t\tfor (let _i = 0; _i < $.len(b); _i++) {\n\t\t\tlet s = b![_i]\n\t\t\t{\n\t\t\t\t$.println(\" \", s)\n\t\t\t}\n\t\t}\n\t\t$.println() // Newline after all strings\n\t}\n\n\tlet [res1, err1] = fn1!(10, \"hello\")\n\t$.println(\"fn1 result 1: \", res1, \" \")\n\tif (err1 != null) {\n\t\t$.println(err1!.Error())\n\t} else {\n\t\t$.println(\"nil\")\n\t}\n\n\tlet [res1_2, err1_2] = fn1!(-5, \"world\")\n\t$.println(\"fn1 result 2: \", res1_2, \" \")\n\tif (err1_2 != null) {\n\t\t$.println(err1_2!.Error())\n\t} else {\n\t\t$.println(\"nil\")\n\t}\n\n\tlet res2 = fn2!(5, \"hello\")\n\t$.println(\"fn2 result 1:\", res2)\n\n\tlet res2_2 = fn2!(3, \"hey\")\n\t$.println(\"fn2 result 2:\", res2_2)\n\n\tfn3!()\n\n\tfn4!(1)\n\tfn4!(2, \"one\")\n\tfn4!(3, \"two\", \"three\")\n}\n\n",
    "expectedOutput": "fn1 called with: 10 hello\nfn1 result 1:  true  \nnil\nfn1 called with: -5 world\nfn1 result 2:  false  \na was not positive\nfn2 called with: 5 hello\nfn2 result 1: true\nfn2 called with: 3 hey\nfn2 result 2: true\nfn3 called\nfn4 called with:  1\n\nfn4 called with:  2\n  one\n\nfn4 called with:  3\n  two\n  three"
  },
  {
    "name": "function_type_assertion",
    "goCode": "package main\n\ntype (\n\tGreeter func(name string) string\n\tAdder   func(a, b int) int\n)\n\nfunc greet(name string) string {\n\treturn \"Hello, \" + name\n}\n\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc getGreeter() interface{} {\n\treturn Greeter(greet)\n}\n\nfunc getAdder() interface{} {\n\treturn Adder(add)\n}\n\ntype FuncContainer struct {\n\tmyFunc interface{}\n}\n\nfunc main() {\n\t// 1. Simple function type assertion\n\tvar i interface{} = Greeter(greet)\n\tfn, ok := i.(Greeter)\n\tif ok {\n\t\tprintln(fn(\"World\"))\n\t} else {\n\t\tprintln(\"Simple assertion failed\")\n\t}\n\n\tvar j interface{} = Adder(add)\n\taddFn, ok := j.(Adder)\n\tif ok {\n\t\tprintln(addFn(5, 3))\n\t} else {\n\t\tprintln(\"Simple adder assertion failed\")\n\t}\n\n\t// 2. Type assertion of a function returned from another function\n\treturnedFn := getGreeter()\n\tgreetFn, ok := returnedFn.(Greeter)\n\tif ok {\n\t\tprintln(greetFn(\"Gopher\"))\n\t} else {\n\t\tprintln(\"Returned function assertion failed\")\n\t}\n\n\treturnedAdder := getAdder()\n\taddFnFromFunc, ok := returnedAdder.(Adder)\n\tif ok {\n\t\tprintln(addFnFromFunc(10, 20))\n\t} else {\n\t\tprintln(\"Returned adder assertion failed\")\n\t}\n\n\t// 3. Type assertion of a function in a struct field\n\tcontainer := FuncContainer{myFunc: Greeter(greet)}\n\tstructFn, ok := container.myFunc.(Greeter)\n\tif ok {\n\t\tprintln(structFn(\"Struct\"))\n\t} else {\n\t\tprintln(\"Struct function assertion failed\")\n\t}\n\n\tadderContainer := FuncContainer{myFunc: Adder(add)}\n\tstructAdderFn, ok := adderContainer.myFunc.(Adder)\n\tif ok {\n\t\tprintln(structAdderFn(7, 8))\n\t} else {\n\t\tprintln(\"Struct adder assertion failed\")\n\t}\n\n\t// 4. Type assertion of a function in a map\n\tfuncMap := make(map[string]interface{})\n\tfuncMap[\"greeter\"] = Greeter(greet)\n\tfuncMap[\"adder\"] = Adder(add)\n\n\tmapFn, ok := funcMap[\"greeter\"].(Greeter)\n\tif ok {\n\t\tprintln(mapFn(\"Map\"))\n\t} else {\n\t\tprintln(\"Map function assertion failed\")\n\t}\n\n\tmapAdderFn, ok := funcMap[\"adder\"].(Adder)\n\tif ok {\n\t\tprintln(mapAdderFn(1, 2))\n\t} else {\n\t\tprintln(\"Map adder assertion failed\")\n\t}\n\n\t// 5. Type assertion of a function in a slice\n\tfuncSlice := make([]interface{}, 2)\n\tfuncSlice[0] = Greeter(greet)\n\tfuncSlice[1] = Adder(add)\n\n\tsliceFn, ok := funcSlice[0].(Greeter)\n\tif ok {\n\t\tprintln(sliceFn(\"Slice\"))\n\t} else {\n\t\tprintln(\"Slice function assertion failed\")\n\t}\n\tsliceAdderFn, ok := funcSlice[1].(Adder)\n\tif ok {\n\t\tprintln(sliceAdderFn(9, 9))\n\t} else {\n\t\tprintln(\"Slice adder assertion failed\")\n\t}\n\n\t// 6. Type assertion with ok variable (successful and failing)\n\tvar k interface{} = Greeter(greet)\n\t_, ok1 := k.(Greeter)\n\tprintln(ok1) // true\n\n\t_, ok2 := k.(Adder)\n\tprintln(ok2) // false\n\n\tvar l interface{} = \"not a function\"\n\t_, ok3 := l.(Greeter)\n\tprintln(ok3) // false\n\n\t// 7. Type assertion that should panic (commented out for now to allow test to run)\n\t// defer func() {\n\t// \tif r := recover(); r != nil {\n\t// \t\tprintln(\"Panic caught as expected\")\n\t// \t}\n\t// }()\n\t// var m interface{} = \"definitely not a func\"\n\t// _ = m.(Greeter) // This would panic\n\t// println(\"This line should not be reached if panic test is active\")\n\n\t// Test with nil interface\n\tvar nilInterface interface{}\n\tnilFn, okNil := nilInterface.(Greeter)\n\tif !okNil && nilFn == nil {\n\t\tprintln(\"Nil interface assertion correct\")\n\t} else {\n\t\tprintln(\"Nil interface assertion failed\")\n\t}\n\n\t// Test assertion to wrong function type\n\tvar wrongFnInterface interface{} = Greeter(greet)\n\twrongFn, okWrong := wrongFnInterface.(Adder)\n\tif !okWrong && wrongFn == nil {\n\t\tprintln(\"Wrong function type assertion correct\")\n\t} else {\n\t\tprintln(\"Wrong function type assertion failed\")\n\t}\n}\n",
    "tsCode": "// Generated file based on function_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type Adder = ((a: number, b: number) => number) | null;\n\nexport class FuncContainer {\n\tpublic get myFunc(): null | any {\n\t\treturn this._fields.myFunc.value\n\t}\n\tpublic set myFunc(value: null | any) {\n\t\tthis._fields.myFunc.value = value\n\t}\n\n\tpublic _fields: {\n\t\tmyFunc: $.VarRef<null | any>;\n\t}\n\n\tconstructor(init?: Partial<{myFunc?: null | any}>) {\n\t\tthis._fields = {\n\t\t\tmyFunc: $.varRef(init?.myFunc ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): FuncContainer {\n\t\tconst cloned = new FuncContainer()\n\t\tcloned._fields = {\n\t\t\tmyFunc: $.varRef(this._fields.myFunc.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.FuncContainer',\n\t  new FuncContainer(),\n\t  [],\n\t  FuncContainer,\n\t  {\"myFunc\": { kind: $.TypeKind.Interface, methods: [] }}\n\t);\n}\n\nexport type Greeter = ((name: string) => string) | null;\n\nexport function greet(name: string): string {\n\treturn \"Hello, \" + name\n}\n\nexport function add(a: number, b: number): number {\n\treturn a + b\n}\n\nexport function getGreeter(): null | any {\n\treturn Object.assign(greet, { __goTypeName: 'Greeter' })\n}\n\nexport function getAdder(): null | any {\n\treturn Object.assign(add, { __goTypeName: 'Adder' })\n}\n\nexport async function main(): Promise<void> {\n\t// 1. Simple function type assertion\n\tlet i: null | any = Object.assign(greet, { __goTypeName: 'Greeter' })\n\tlet { value: fn, ok: ok } = $.typeAssert<Greeter | null>(i, {kind: $.TypeKind.Function, name: 'Greeter', params: [{ kind: $.TypeKind.Basic, name: \"string\" }], results: [{ kind: $.TypeKind.Basic, name: \"string\" }]})\n\tif (ok) {\n\t\t$.println(fn!(\"World\"))\n\t} else {\n\t\t$.println(\"Simple assertion failed\")\n\t}\n\n\tlet j: null | any = Object.assign(add, { __goTypeName: 'Adder' })\n\tlet addFn: Adder | null\n\t({ value: addFn, ok: ok } = $.typeAssert<Adder | null>(j, {kind: $.TypeKind.Function, name: 'Adder', params: [{ kind: $.TypeKind.Basic, name: \"int\" }, { kind: $.TypeKind.Basic, name: \"int\" }], results: [{ kind: $.TypeKind.Basic, name: \"int\" }]}))\n\tif (ok) {\n\t\t$.println(addFn!(5, 3))\n\t} else {\n\t\t$.println(\"Simple adder assertion failed\")\n\t}\n\n\t// 2. Type assertion of a function returned from another function\n\tlet returnedFn = getGreeter()\n\tlet greetFn: Greeter | null\n\t({ value: greetFn, ok: ok } = $.typeAssert<Greeter | null>(returnedFn, {kind: $.TypeKind.Function, name: 'Greeter', params: [{ kind: $.TypeKind.Basic, name: \"string\" }], results: [{ kind: $.TypeKind.Basic, name: \"string\" }]}))\n\tif (ok) {\n\t\t$.println(greetFn!(\"Gopher\"))\n\t} else {\n\t\t$.println(\"Returned function assertion failed\")\n\t}\n\n\tlet returnedAdder = getAdder()\n\tlet addFnFromFunc: Adder | null\n\t({ value: addFnFromFunc, ok: ok } = $.typeAssert<Adder | null>(returnedAdder, {kind: $.TypeKind.Function, name: 'Adder', params: [{ kind: $.TypeKind.Basic, name: \"int\" }, { kind: $.TypeKind.Basic, name: \"int\" }], results: [{ kind: $.TypeKind.Basic, name: \"int\" }]}))\n\tif (ok) {\n\t\t$.println(addFnFromFunc!(10, 20))\n\t} else {\n\t\t$.println(\"Returned adder assertion failed\")\n\t}\n\n\t// 3. Type assertion of a function in a struct field\n\tlet container = $.markAsStructValue(new FuncContainer({myFunc: Object.assign(greet, { __goTypeName: 'Greeter' })}))\n\tlet structFn: Greeter | null\n\t({ value: structFn, ok: ok } = $.typeAssert<Greeter | null>(container.myFunc, {kind: $.TypeKind.Function, name: 'Greeter', params: [{ kind: $.TypeKind.Basic, name: \"string\" }], results: [{ kind: $.TypeKind.Basic, name: \"string\" }]}))\n\tif (ok) {\n\t\t$.println(structFn!(\"Struct\"))\n\t} else {\n\t\t$.println(\"Struct function assertion failed\")\n\t}\n\n\tlet adderContainer = $.markAsStructValue(new FuncContainer({myFunc: Object.assign(add, { __goTypeName: 'Adder' })}))\n\tlet structAdderFn: Adder | null\n\t({ value: structAdderFn, ok: ok } = $.typeAssert<Adder | null>(adderContainer.myFunc, {kind: $.TypeKind.Function, name: 'Adder', params: [{ kind: $.TypeKind.Basic, name: \"int\" }, { kind: $.TypeKind.Basic, name: \"int\" }], results: [{ kind: $.TypeKind.Basic, name: \"int\" }]}))\n\tif (ok) {\n\t\t$.println(structAdderFn!(7, 8))\n\t} else {\n\t\t$.println(\"Struct adder assertion failed\")\n\t}\n\n\t// 4. Type assertion of a function in a map\n\tlet funcMap = $.makeMap<string, null | any>()\n\t$.mapSet(funcMap, \"greeter\", Object.assign(greet, { __goTypeName: 'Greeter' }))\n\t$.mapSet(funcMap, \"adder\", Object.assign(add, { __goTypeName: 'Adder' }))\n\n\tlet mapFn: Greeter | null\n\t({ value: mapFn, ok: ok } = $.typeAssert<Greeter | null>($.mapGet(funcMap, \"greeter\", null)[0], {kind: $.TypeKind.Function, name: 'Greeter', params: [{ kind: $.TypeKind.Basic, name: \"string\" }], results: [{ kind: $.TypeKind.Basic, name: \"string\" }]}))\n\tif (ok) {\n\t\t$.println(mapFn!(\"Map\"))\n\t} else {\n\t\t$.println(\"Map function assertion failed\")\n\t}\n\n\tlet mapAdderFn: Adder | null\n\t({ value: mapAdderFn, ok: ok } = $.typeAssert<Adder | null>($.mapGet(funcMap, \"adder\", null)[0], {kind: $.TypeKind.Function, name: 'Adder', params: [{ kind: $.TypeKind.Basic, name: \"int\" }, { kind: $.TypeKind.Basic, name: \"int\" }], results: [{ kind: $.TypeKind.Basic, name: \"int\" }]}))\n\tif (ok) {\n\t\t$.println(mapAdderFn!(1, 2))\n\t} else {\n\t\t$.println(\"Map adder assertion failed\")\n\t}\n\n\t// 5. Type assertion of a function in a slice\n\tlet funcSlice = $.makeSlice<null | any>(2)\n\tfuncSlice![0] = Object.assign(greet, { __goTypeName: 'Greeter' })\n\tfuncSlice![1] = Object.assign(add, { __goTypeName: 'Adder' })\n\n\tlet sliceFn: Greeter | null\n\t({ value: sliceFn, ok: ok } = $.typeAssert<Greeter | null>(funcSlice![0], {kind: $.TypeKind.Function, name: 'Greeter', params: [{ kind: $.TypeKind.Basic, name: \"string\" }], results: [{ kind: $.TypeKind.Basic, name: \"string\" }]}))\n\tif (ok) {\n\t\t$.println(sliceFn!(\"Slice\"))\n\t} else {\n\t\t$.println(\"Slice function assertion failed\")\n\t}\n\tlet sliceAdderFn: Adder | null\n\t({ value: sliceAdderFn, ok: ok } = $.typeAssert<Adder | null>(funcSlice![1], {kind: $.TypeKind.Function, name: 'Adder', params: [{ kind: $.TypeKind.Basic, name: \"int\" }, { kind: $.TypeKind.Basic, name: \"int\" }], results: [{ kind: $.TypeKind.Basic, name: \"int\" }]}))\n\tif (ok) {\n\t\t$.println(sliceAdderFn!(9, 9))\n\t} else {\n\t\t$.println(\"Slice adder assertion failed\")\n\t}\n\n\t// 6. Type assertion with ok variable (successful and failing)\n\tlet k: null | any = Object.assign(greet, { __goTypeName: 'Greeter' })\n\tlet { ok: ok1 } = $.typeAssert<Greeter | null>(k, {kind: $.TypeKind.Function, name: 'Greeter', params: [{ kind: $.TypeKind.Basic, name: \"string\" }], results: [{ kind: $.TypeKind.Basic, name: \"string\" }]})\n\t$.println(ok1) // true\n\n\tlet { ok: ok2 } = $.typeAssert<Adder | null>(k, {kind: $.TypeKind.Function, name: 'Adder', params: [{ kind: $.TypeKind.Basic, name: \"int\" }, { kind: $.TypeKind.Basic, name: \"int\" }], results: [{ kind: $.TypeKind.Basic, name: \"int\" }]})\n\t$.println(ok2) // false\n\n\tlet l: null | any = \"not a function\"\n\tlet { ok: ok3 } = $.typeAssert<Greeter | null>(l, {kind: $.TypeKind.Function, name: 'Greeter', params: [{ kind: $.TypeKind.Basic, name: \"string\" }], results: [{ kind: $.TypeKind.Basic, name: \"string\" }]})\n\t$.println(ok3) // false\n\n\t// 7. Type assertion that should panic (commented out for now to allow test to run)\n\t// defer func() {\n\t// \tif r := recover(); r != nil {\n\t// \t\tprintln(\"Panic caught as expected\")\n\t// \t}\n\t// }()\n\t// var m interface{} = \"definitely not a func\"\n\t// _ = m.(Greeter) // This would panic\n\t// println(\"This line should not be reached if panic test is active\")\n\n\t// Test with nil interface\n\tlet nilInterface: null | any = null\n\tlet { value: nilFn, ok: okNil } = $.typeAssert<Greeter | null>(nilInterface, {kind: $.TypeKind.Function, name: 'Greeter', params: [{ kind: $.TypeKind.Basic, name: \"string\" }], results: [{ kind: $.TypeKind.Basic, name: \"string\" }]})\n\tif (!okNil && nilFn == null) {\n\t\t$.println(\"Nil interface assertion correct\")\n\t} else {\n\t\t$.println(\"Nil interface assertion failed\")\n\t}\n\n\t// Test assertion to wrong function type\n\tlet wrongFnInterface: null | any = Object.assign(greet, { __goTypeName: 'Greeter' })\n\tlet { value: wrongFn, ok: okWrong } = $.typeAssert<Adder | null>(wrongFnInterface, {kind: $.TypeKind.Function, name: 'Adder', params: [{ kind: $.TypeKind.Basic, name: \"int\" }, { kind: $.TypeKind.Basic, name: \"int\" }], results: [{ kind: $.TypeKind.Basic, name: \"int\" }]})\n\tif (!okWrong && wrongFn == null) {\n\t\t$.println(\"Wrong function type assertion correct\")\n\t} else {\n\t\t$.println(\"Wrong function type assertion failed\")\n\t}\n}\n\n",
    "expectedOutput": "Hello, World\n8\nHello, Gopher\n30\nHello, Struct\n15\nHello, Map\n3\nHello, Slice\n18\ntrue\nfalse\nfalse\nNil interface assertion correct\nWrong function type assertion correct"
  },
  {
    "name": "generic_index_assignment",
    "goCode": "package main\n\n// Test case for generic index assignment issue\n// This reproduces the \"Invalid assignment target\" error where\n// s[i] = v generates $.indexStringOrBytes(s, i) = v in TypeScript\n\nfunc modifyGenericSlice[S ~[]E, E any](s S, i int, v E) {\n\t// This line causes the issue: s[i] = v\n\t// For generic slice types, the compiler should generate proper assignment\n\t// But currently it may generate: $.indexStringOrBytes(s, i) = v\n\t// which is invalid TypeScript syntax\n\ts[i] = v\n}\n\nfunc main() {\n\tslice := []int{1, 2, 3}\n\tmodifyGenericSlice(slice, 1, 42)\n\n\tprintln(\"slice[0]:\", slice[0])\n\tprintln(\"slice[1]:\", slice[1])\n\tprintln(\"slice[2]:\", slice[2])\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on generic_index_assignment.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function modifyGenericSlice<S extends $.Slice<E>, E extends any>(s: S, i: number, v: E): void {\n\t// This line causes the issue: s[i] = v\n\t// For generic slice types, the compiler should generate proper assignment\n\t// But currently it may generate: $.indexStringOrBytes(s, i) = v\n\t// which is invalid TypeScript syntax\n\ts![i] = v\n}\n\nexport async function main(): Promise<void> {\n\tlet slice = $.arrayToSlice<number>([1, 2, 3])\n\tmodifyGenericSlice(slice, 1, 42)\n\n\t$.println(\"slice[0]:\", slice![0])\n\t$.println(\"slice[1]:\", slice![1])\n\t$.println(\"slice[2]:\", slice![2])\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "slice[0]: 1\nslice[1]: 42\nslice[2]: 3\ntest finished "
  },
  {
    "name": "generics",
    "goCode": "package main\n\n// Generic function with any constraint\nfunc printVal[T any](val T) {\n\tprintln(val)\n}\n\n// Generic function with comparable constraint\nfunc equal[T comparable](a, b T) bool {\n\treturn a == b\n}\n\n// Generic function with union constraint\nfunc getLength[S string | []byte](s S) int {\n\treturn len(s)\n}\n\n// Generic struct\ntype Pair[T any] struct {\n\tFirst  T\n\tSecond T\n}\n\nfunc (p Pair[T]) GetFirst() T {\n\treturn p.First\n}\n\n// Generic function returning a generic struct\nfunc makePair[T any](a, b T) Pair[T] {\n\treturn Pair[T]{First: a, Second: b}\n}\n\n// Generic slice operations\nfunc append2[T any](slice []T, elem T) []T {\n\treturn append(slice, elem)\n}\n\nfunc main() {\n\t// Test basic generic function\n\tprintln(\"=== Basic Generic Function ===\")\n\tprintVal(42)\n\tprintVal(\"hello\")\n\tprintVal(true)\n\n\t// Test comparable constraint\n\tprintln(\"=== Comparable Constraint ===\")\n\tprintln(equal(1, 1))\n\tprintln(equal(1, 2))\n\tprintln(equal(\"hello\", \"hello\"))\n\tprintln(equal(\"hello\", \"world\"))\n\n\t// Test union constraint with string\n\tprintln(\"=== Union Constraint ===\")\n\tstr := \"hello\"\n\tprintln(getLength(str))\n\n\t// Test union constraint with []byte\n\tbytes := []byte(\"world\")\n\tprintln(getLength(bytes))\n\n\t// Test generic struct\n\tprintln(\"=== Generic Struct ===\")\n\tintPair := makePair(10, 20)\n\tprintln(intPair.GetFirst())\n\tprintln(intPair.First)\n\tprintln(intPair.Second)\n\n\tstringPair := makePair(\"foo\", \"bar\")\n\tprintln(stringPair.GetFirst())\n\tprintln(stringPair.First)\n\tprintln(stringPair.Second)\n\n\t// Test generic slice operations\n\tprintln(\"=== Generic Slice Operations ===\")\n\tnums := []int{1, 2, 3}\n\tnums = append2(nums, 4)\n\tfor _, n := range nums {\n\t\tprintln(n)\n\t}\n\n\twords := []string{\"a\", \"b\"}\n\twords = append2(words, \"c\")\n\tfor _, w := range words {\n\t\tprintln(w)\n\t}\n\n\t// Test type inference\n\tprintln(\"=== Type Inference ===\")\n\tresult := makePair(100, 200)\n\tprintln(result.First)\n\tprintln(result.Second)\n}\n",
    "tsCode": "// Generated file based on generics.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Pair<T extends any> {\n\tpublic get First(): T {\n\t\treturn this._fields.First.value\n\t}\n\tpublic set First(value: T) {\n\t\tthis._fields.First.value = value\n\t}\n\n\tpublic get Second(): T {\n\t\treturn this._fields.Second.value\n\t}\n\tpublic set Second(value: T) {\n\t\tthis._fields.Second.value = value\n\t}\n\n\tpublic _fields: {\n\t\tFirst: $.VarRef<T>;\n\t\tSecond: $.VarRef<T>;\n\t}\n\n\tconstructor(init?: Partial<{First?: T, Second?: T}>) {\n\t\tthis._fields = {\n\t\t\tFirst: $.varRef(init?.First ?? null as any),\n\t\t\tSecond: $.varRef(init?.Second ?? null as any)\n\t\t}\n\t}\n\n\tpublic clone(): Pair<T> {\n\t\tconst cloned = new Pair<T>()\n\t\tcloned._fields = {\n\t\t\tFirst: $.varRef(this._fields.First.value),\n\t\t\tSecond: $.varRef(this._fields.Second.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic GetFirst(): T {\n\t\tconst p = this\n\t\treturn p.First\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Pair',\n\t  new Pair(),\n\t  [{ name: \"GetFirst\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }],\n\t  Pair,\n\t  {\"First\": { kind: $.TypeKind.Interface, methods: [] }, \"Second\": { kind: $.TypeKind.Interface, methods: [] }}\n\t);\n}\n\n// Generic function with any constraint\nexport function printVal<T extends any>(val: T): void {\n\t$.println(val)\n}\n\n// Generic function with comparable constraint\nexport function equal<T extends $.Comparable>(a: T, b: T): boolean {\n\treturn a == b\n}\n\n// Generic function with union constraint\nexport function getLength<S extends string | $.Bytes>(s: S): number {\n\treturn $.len(s)\n}\n\n// Generic function returning a generic struct\nexport function makePair<T extends any>(a: T, b: T): Pair<T> {\n\treturn $.markAsStructValue(new Pair<T>({First: a, Second: b}))\n}\n\n// Generic slice operations\nexport function append2<T extends any>(slice: $.Slice<T>, elem: T): $.Slice<T> {\n\treturn $.append(slice, elem)\n}\n\nexport async function main(): Promise<void> {\n\t// Test basic generic function\n\t$.println(\"=== Basic Generic Function ===\")\n\tprintVal(42)\n\tprintVal(\"hello\")\n\tprintVal(true)\n\n\t// Test comparable constraint\n\t$.println(\"=== Comparable Constraint ===\")\n\t$.println(equal(1, 1))\n\t$.println(equal(1, 2))\n\t$.println(equal(\"hello\", \"hello\"))\n\t$.println(equal(\"hello\", \"world\"))\n\n\t// Test union constraint with string\n\t$.println(\"=== Union Constraint ===\")\n\tlet str = \"hello\"\n\t$.println(getLength(str))\n\n\t// Test union constraint with []byte\n\tlet bytes = $.stringToBytes(\"world\")\n\t$.println(getLength(bytes))\n\n\t// Test generic struct\n\t$.println(\"=== Generic Struct ===\")\n\tlet intPair = $.markAsStructValue(makePair(10, 20).clone())\n\t$.println(intPair.GetFirst())\n\t$.println(intPair.First)\n\t$.println(intPair.Second)\n\n\tlet stringPair = $.markAsStructValue(makePair(\"foo\", \"bar\").clone())\n\t$.println(stringPair.GetFirst())\n\t$.println(stringPair.First)\n\t$.println(stringPair.Second)\n\n\t// Test generic slice operations\n\t$.println(\"=== Generic Slice Operations ===\")\n\tlet nums = $.arrayToSlice<number>([1, 2, 3])\n\tnums = append2(nums, 4)\n\tfor (let _i = 0; _i < $.len(nums); _i++) {\n\t\tlet n = nums![_i]\n\t\t{\n\t\t\t$.println(n)\n\t\t}\n\t}\n\n\tlet words = $.arrayToSlice<string>([\"a\", \"b\"])\n\twords = append2(words, \"c\")\n\tfor (let _i = 0; _i < $.len(words); _i++) {\n\t\tlet w = words![_i]\n\t\t{\n\t\t\t$.println(w)\n\t\t}\n\t}\n\n\t// Test type inference\n\t$.println(\"=== Type Inference ===\")\n\tlet result = $.markAsStructValue(makePair(100, 200).clone())\n\t$.println(result.First)\n\t$.println(result.Second)\n}\n\n",
    "expectedOutput": "=== Basic Generic Function ===\n42\nhello\ntrue\n=== Comparable Constraint ===\ntrue\nfalse\ntrue\nfalse\n=== Union Constraint ===\n5\n5\n=== Generic Struct ===\n10\n10\n20\nfoo\nfoo\nbar\n=== Generic Slice Operations ===\n1\n2\n3\n4\na\nb\nc\n=== Type Inference ===\n100\n200 "
  },
  {
    "name": "generics_basic",
    "goCode": "package main\n\nfunc printVal[T any](val T) {\n\tprintln(val)\n}\n\nfunc main() {\n\tprintVal(10)\n\tprintVal(\"hello\")\n\tprintVal(true)\n}\n",
    "tsCode": "// Generated file based on generics_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function printVal<T extends any>(val: T): void {\n\t$.println(val)\n}\n\nexport async function main(): Promise<void> {\n\tprintVal(10)\n\tprintVal(\"hello\")\n\tprintVal(true)\n}\n\n",
    "expectedOutput": "10\nhello\ntrue\n"
  },
  {
    "name": "generics_interface",
    "goCode": "package main\n\n// Generic interface with type parameter\ntype Container[T any] interface {\n\tGet() T\n\tSet(T)\n\tSize() int\n}\n\n// Generic interface with constraint\ntype Comparable[T comparable] interface {\n\tCompare(T) int\n\tEqual(T) bool\n}\n\n// Simple struct implementing generic interface\ntype ValueContainer[T any] struct {\n\tvalue T\n\tcount int\n}\n\nfunc (b *ValueContainer[T]) Get() T {\n\treturn b.value\n}\n\nfunc (b *ValueContainer[T]) Set(v T) {\n\tb.value = v\n\tb.count++\n}\n\nfunc (b *ValueContainer[T]) Size() int {\n\treturn b.count\n}\n\n// String struct implementing comparable interface\ntype StringValueContainer struct {\n\tvalue string\n}\n\nfunc (s *StringValueContainer) Compare(other string) int {\n\tif s.value < other {\n\t\treturn -1\n\t} else if s.value > other {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc (s *StringValueContainer) Equal(other string) bool {\n\treturn s.value == other\n}\n\n// Function that works with generic interface\nfunc useContainer[T any](c Container[T], val T) T {\n\tc.Set(val)\n\treturn c.Get()\n}\n\n// Function that works with comparable interface\nfunc checkEqual[T comparable](c Comparable[T], val T) bool {\n\treturn c.Equal(val)\n}\n\nfunc main() {\n\tprintln(\"=== Generic Interface Test ===\")\n\n\t// Test ValueContainer implementing Container\n\tintValueContainer := &ValueContainer[int]{}\n\tresult := useContainer(intValueContainer, 42)\n\tprintln(\"Int ValueContainer result:\", result)\n\tprintln(\"Int ValueContainer size:\", intValueContainer.Size())\n\n\tstringValueContainer := &ValueContainer[string]{}\n\tstrResult := useContainer(stringValueContainer, \"hello\")\n\tprintln(\"String ValueContainer result:\", strResult)\n\tprintln(\"String ValueContainer size:\", stringValueContainer.Size())\n\n\t// Test StringValueContainer implementing Comparable\n\tsb := &StringValueContainer{value: \"test\"}\n\tprintln(\"String comparison equal:\", checkEqual(sb, \"test\"))\n\tprintln(\"String comparison not equal:\", checkEqual(sb, \"other\"))\n\tprintln(\"String comparison -1:\", sb.Compare(\"zebra\"))\n\tprintln(\"String comparison 1:\", sb.Compare(\"alpha\"))\n\tprintln(\"String comparison 0:\", sb.Compare(\"test\"))\n}\n",
    "tsCode": "// Generated file based on generics_interface.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type Comparable<T extends $.Comparable> = null | {\n\tCompare(_p0: T): number\n\tEqual(_p0: T): boolean\n}\n\n$.registerInterfaceType(\n  'main.Comparable',\n  null, // Zero value for interface is null\n  [{ name: \"Compare\", args: [{ name: \"\", type: { kind: $.TypeKind.Interface, methods: [] } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }, { name: \"Equal\", args: [{ name: \"\", type: { kind: $.TypeKind.Interface, methods: [] } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }]\n);\n\nexport type Container<T extends any> = null | {\n\tGet(): T\n\tSet(_p0: T): void\n\tSize(): number\n}\n\n$.registerInterfaceType(\n  'main.Container',\n  null, // Zero value for interface is null\n  [{ name: \"Get\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }, { name: \"Set\", args: [{ name: \"\", type: { kind: $.TypeKind.Interface, methods: [] } }], returns: [] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }]\n);\n\nexport class StringValueContainer {\n\tpublic get value(): string {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: string) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{value?: string}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): StringValueContainer {\n\t\tconst cloned = new StringValueContainer()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Compare(other: string): number {\n\t\tconst s = this\n\t\tif (s.value < other) {\n\t\t\treturn -1\n\t\t} else if (s.value > other) {\n\t\t\treturn 1\n\t\t}\n\t\treturn 0\n\t}\n\n\tpublic Equal(other: string): boolean {\n\t\tconst s = this\n\t\treturn s.value == other\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.StringValueContainer',\n\t  new StringValueContainer(),\n\t  [{ name: \"Compare\", args: [{ name: \"other\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }, { name: \"Equal\", args: [{ name: \"other\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }],\n\t  StringValueContainer,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport class ValueContainer<T extends any> {\n\tpublic get value(): T {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: T) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic get count(): number {\n\t\treturn this._fields.count.value\n\t}\n\tpublic set count(value: number) {\n\t\tthis._fields.count.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<T>;\n\t\tcount: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{count?: number, value?: T}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? null as any),\n\t\t\tcount: $.varRef(init?.count ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): ValueContainer<T> {\n\t\tconst cloned = new ValueContainer<T>()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value),\n\t\t\tcount: $.varRef(this._fields.count.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Get(): T {\n\t\tconst b = this\n\t\treturn b.value\n\t}\n\n\tpublic Set(v: T): void {\n\t\tconst b = this\n\t\tb.value = v\n\t\tb.count++\n\t}\n\n\tpublic Size(): number {\n\t\tconst b = this\n\t\treturn b.count\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.ValueContainer',\n\t  new ValueContainer(),\n\t  [{ name: \"Get\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }, { name: \"Set\", args: [{ name: \"v\", type: { kind: $.TypeKind.Interface, methods: [] } }], returns: [] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  ValueContainer,\n\t  {\"value\": { kind: $.TypeKind.Interface, methods: [] }, \"count\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\n// Function that works with generic interface\nexport function useContainer<T extends any>(c: Container<T>, val: T): T {\n\tc!.Set(val)\n\treturn c!.Get()\n}\n\n// Function that works with comparable interface\nexport function checkEqual<T extends $.Comparable>(c: Comparable<T>, val: T): boolean {\n\treturn c!.Equal(val)\n}\n\nexport async function main(): Promise<void> {\n\t$.println(\"=== Generic Interface Test ===\")\n\n\t// Test ValueContainer implementing Container\n\tlet intValueContainer = new ValueContainer<number>({})\n\tlet result = useContainer(intValueContainer, 42)\n\t$.println(\"Int ValueContainer result:\", result)\n\t$.println(\"Int ValueContainer size:\", intValueContainer!.Size())\n\n\tlet stringValueContainer = new ValueContainer<string>({})\n\tlet strResult = useContainer(stringValueContainer, \"hello\")\n\t$.println(\"String ValueContainer result:\", strResult)\n\t$.println(\"String ValueContainer size:\", stringValueContainer!.Size())\n\n\t// Test StringValueContainer implementing Comparable\n\tlet sb = new StringValueContainer({value: \"test\"})\n\t$.println(\"String comparison equal:\", checkEqual(sb, \"test\"))\n\t$.println(\"String comparison not equal:\", checkEqual(sb, \"other\"))\n\t$.println(\"String comparison -1:\", sb!.Compare(\"zebra\"))\n\t$.println(\"String comparison 1:\", sb!.Compare(\"alpha\"))\n\t$.println(\"String comparison 0:\", sb!.Compare(\"test\"))\n}\n\n",
    "expectedOutput": "=== Generic Interface Test ===\nInt ValueContainer result: 42\nInt ValueContainer size: 1\nString ValueContainer result: hello\nString ValueContainer size: 1\nString comparison equal: true\nString comparison not equal: false\nString comparison -1: -1\nString comparison 1: 1\nString comparison 0: 0\n"
  },
  {
    "name": "generics_leading_int",
    "goCode": "package main\n\n// leadingInt consumes the leading [0-9]* from s.\nfunc leadingInt[bytes []byte | string](s bytes) (x uint64, rem bytes, err bool) {\n\ti := 0\n\tfor ; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif c < '0' || c > '9' {\n\t\t\tbreak\n\t\t}\n\t\tif x > 1<<63/10 {\n\t\t\t// overflow\n\t\t\treturn 0, s[len(s):], true\n\t\t}\n\t\tx = x*10 + uint64(c) - '0'\n\t\tif x > 1<<63 {\n\t\t\t// overflow\n\t\t\treturn 0, s[len(s):], true\n\t\t}\n\t}\n\treturn x, s[i:], false\n}\n\nfunc main() {\n\tx1, rem1, err1 := leadingInt([]byte(\"123abc456\"))\n\tprintln(x1, string(rem1), err1)\n\n\tx2, rem2, err2 := leadingInt(\"456def123\")\n\tprintln(x2, string(rem2), err2)\n\n\tx3, rem3, err3 := leadingInt(\"abc\")\n\tprintln(x3, string(rem3), err3)\n\n\t// Test overflow\n\tx4, rem4, err4 := leadingInt(\"999999999999999999999999999999\") // This will overflow uint64 during intermediate calculation\n\tprintln(x4, string(rem4), err4)\n\n\tx5, rem5, err5 := leadingInt[string](\"123\")\n\tprintln(x5, string(rem5), err5)\n}\n",
    "tsCode": "// Generated file based on generics_leading_int.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\n// leadingInt consumes the leading [0-9]* from s.\nexport function leadingInt<bytes extends $.Bytes | string>(s: bytes): [number, bytes, boolean] {\n\tlet x: number = 0\n\tlet rem: bytes = null as any\n\tlet err: boolean = false\n\t{\n\t\tlet i = 0\n\n\t\t// overflow\n\n\t\t// overflow\n\t\tfor (; i < $.len(s); i++) {\n\t\t\tlet c = $.indexString(s, i)\n\t\t\tif (c < 48 || c > 57) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// overflow\n\t\t\tif (x > Math.trunc(Number.MAX_SAFE_INTEGER / 10)) {\n\t\t\t\t// overflow\n\t\t\t\treturn [0, $.sliceStringOrBytes(s, $.len(s), undefined), true]\n\t\t\t}\n\t\t\tx = x * 10 + (c as number) - 48\n\n\t\t\t// overflow\n\t\t\tif (x > Number.MAX_SAFE_INTEGER) {\n\t\t\t\t// overflow\n\t\t\t\treturn [0, $.sliceStringOrBytes(s, $.len(s), undefined), true]\n\t\t\t}\n\t\t}\n\t\treturn [x, $.sliceStringOrBytes(s, i, undefined), false]\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet [x1, rem1, err1] = leadingInt($.stringToBytes(\"123abc456\"))\n\t$.println(x1, $.bytesToString(rem1), err1)\n\n\tlet [x2, rem2, err2] = leadingInt(\"456def123\")\n\t$.println(x2, rem2, err2)\n\n\tlet [x3, rem3, err3] = leadingInt(\"abc\")\n\t$.println(x3, rem3, err3)\n\n\t// Test overflow\n\tlet [x4, rem4, err4] = leadingInt(\"999999999999999999999999999999\")\n\t$.println(x4, rem4, err4)\n\n\tlet [x5, rem5, err5] = leadingInt<string>(\"123\")\n\t$.println(x5, rem5, err5)\n}\n\n",
    "expectedOutput": "123 abc456 false\n456 def123 false\n0 abc false\n0  true\n123  false\n"
  },
  {
    "name": "go_type_assertion",
    "goCode": "package main\n\nfunc main() {\n\tvar x interface{} = func() {\n\t\tprintln(\"goroutine executed\")\n\t}\n\tgo x.(func())()\n\tprintln(\"main finished\")\n}\n",
    "tsCode": "// Generated file based on go_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet x: null | any = (): void => {\n\t\t$.println(\"goroutine executed\")\n\t}\n\tqueueMicrotask(() => {\n\t\t$.mustTypeAssert<(() => void) | null>(x, {kind: $.TypeKind.Function})!()\n\t})\n\t$.println(\"main finished\")\n}\n\n",
    "expectedOutput": "main finished\ngoroutine executed\n"
  },
  {
    "name": "goroutines",
    "goCode": "// Package main tests goroutine handling with named functions\npackage main\n\n// Message struct with priority and text for deterministic ordering\ntype Message struct {\n\tpriority int\n\ttext     string\n}\n\n// Channel to collect messages from all goroutines\nvar messages = make(chan Message)\n\n// Total number of messages we expect to receive\nconst totalMessages = 8\n\n// A worker function that will be called as a goroutine\nfunc worker(id int) {\n\t// Send worker starting message\n\tmessages <- Message{\n\t\tpriority: 10 + id,\n\t\ttext:     \"Worker \" + string(rune('0'+id)) + \" starting\",\n\t}\n\n\t// Send worker done message\n\tmessages <- Message{\n\t\tpriority: 20 + id,\n\t\ttext:     \"Worker \" + string(rune('0'+id)) + \" done\",\n\t}\n}\n\n// Another worker function to test multiple different goroutines\nfunc anotherWorker(name string) {\n\tmessages <- Message{\n\t\tpriority: 40,\n\t\ttext:     \"Another worker: \" + name,\n\t}\n}\n\nfunc main() {\n\t// Create a slice to collect all messages\n\tallMessages := make([]Message, 0, totalMessages+3) // +3 for main thread messages\n\n\t// Add initial message\n\tallMessages = append(allMessages, Message{\n\t\tpriority: 0,\n\t\ttext:     \"Main: Starting workers\",\n\t})\n\n\t// Start 3 worker goroutines\n\tfor i := range 3 {\n\t\tgo worker(i) // This will trigger a past error with *ast.Ident\n\t}\n\n\t// Start another worker goroutine\n\tgo anotherWorker(\"test\")\n\n\t// Start an anonymous function worker\n\tgo func() {\n\t\tmessages <- Message{\n\t\t\tpriority: 50,\n\t\t\ttext:     \"Anonymous function worker\",\n\t\t}\n\t}()\n\n\t// Add status message\n\tallMessages = append(allMessages, Message{\n\t\tpriority: 1,\n\t\ttext:     \"Main: Workers started\",\n\t})\n\n\t// Collect all messages from goroutines\n\tfor i := 0; i < totalMessages; i++ {\n\t\tallMessages = append(allMessages, <-messages)\n\t}\n\n\t// Add final message\n\tallMessages = append(allMessages, Message{\n\t\tpriority: 100,\n\t\ttext:     \"Main: All workers completed\",\n\t})\n\n\t// Sort messages by priority for deterministic order\n\tfor i := range allMessages {\n\t\tfor j := i + 1; j < len(allMessages); j++ {\n\t\t\tif allMessages[i].priority > allMessages[j].priority {\n\t\t\t\tallMessages[i], allMessages[j] = allMessages[j], allMessages[i]\n\t\t\t}\n\t\t}\n\t}\n\n\t// Print all messages in deterministic order\n\tfor _, msg := range allMessages {\n\t\tprintln(msg.priority, msg.text)\n\t}\n\tprintln(\"done\")\n}\n",
    "tsCode": "// Generated file based on goroutines.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport let totalMessages: number = 8\n\nexport class Message {\n\tpublic get priority(): number {\n\t\treturn this._fields.priority.value\n\t}\n\tpublic set priority(value: number) {\n\t\tthis._fields.priority.value = value\n\t}\n\n\tpublic get text(): string {\n\t\treturn this._fields.text.value\n\t}\n\tpublic set text(value: string) {\n\t\tthis._fields.text.value = value\n\t}\n\n\tpublic _fields: {\n\t\tpriority: $.VarRef<number>;\n\t\ttext: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{priority?: number, text?: string}>) {\n\t\tthis._fields = {\n\t\t\tpriority: $.varRef(init?.priority ?? 0),\n\t\t\ttext: $.varRef(init?.text ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): Message {\n\t\tconst cloned = new Message()\n\t\tcloned._fields = {\n\t\t\tpriority: $.varRef(this._fields.priority.value),\n\t\t\ttext: $.varRef(this._fields.text.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Message',\n\t  new Message(),\n\t  [],\n\t  Message,\n\t  {\"priority\": { kind: $.TypeKind.Basic, name: \"int\" }, \"text\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport let messages: $.Channel<Message> | null = $.makeChannel<Message>(0, new Message(), 'both')\n\n// A worker function that will be called as a goroutine\nexport async function worker(id: number): Promise<void> {\n\t// Send worker starting message\n\tawait $.chanSend(messages, $.markAsStructValue(new Message({priority: 10 + id, text: \"Worker \" + $.runeOrStringToString(48 + id) + \" starting\"})))\n\n\t// Send worker done message\n\tawait $.chanSend(messages, $.markAsStructValue(new Message({priority: 20 + id, text: \"Worker \" + $.runeOrStringToString(48 + id) + \" done\"})))\n}\n\n// Another worker function to test multiple different goroutines\nexport async function anotherWorker(name: string): Promise<void> {\n\tawait $.chanSend(messages, $.markAsStructValue(new Message({priority: 40, text: \"Another worker: \" + name})))\n}\n\nexport async function main(): Promise<void> {\n\t// Create a slice to collect all messages\n\tlet allMessages = $.makeSlice<Message>(0, 8 + 3) // +3 for main thread messages\n\n\t// Add initial message\n\tallMessages = $.append(allMessages, $.markAsStructValue(new Message({priority: 0, text: \"Main: Starting workers\"})))\n\n\t// Start 3 worker goroutines\n\n\t// This will trigger a past error with *ast.Ident\n\tfor (let i = 0; i < 3; i++) {{\n\t\tqueueMicrotask(async () => {\n\t\t\tawait worker(i)\n\t\t})\n\t}\n}\n\n// Start another worker goroutine\nqueueMicrotask(async () => {\n\tawait anotherWorker(\"test\")\n})\n\n// Start an anonymous function worker\nqueueMicrotask(async () => {\n\tawait $.chanSend(messages, $.markAsStructValue(new Message({priority: 50, text: \"Anonymous function worker\"})))\n})\n\n// Add status message\nallMessages = $.append(allMessages, $.markAsStructValue(new Message({priority: 1, text: \"Main: Workers started\"})))\n\n// Collect all messages from goroutines\nfor (let i = 0; i < 8; i++) {\n\tallMessages = $.append(allMessages, await $.chanRecv(messages))\n}\n\n// Add final message\nallMessages = $.append(allMessages, $.markAsStructValue(new Message({priority: 100, text: \"Main: All workers completed\"})))\n\n// Sort messages by priority for deterministic order\nfor (let i = 0; i < $.len(allMessages); i++) {\n\t{\n\t\tfor (let j = i + 1; j < $.len(allMessages); j++) {\n\t\t\tif (allMessages![i].priority > allMessages![j].priority) {\n\t\t\t\t;[allMessages![i], allMessages![j]] = [allMessages![j], allMessages![i]]\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Print all messages in deterministic order\nfor (let _i = 0; _i < $.len(allMessages); _i++) {\n\tlet msg = allMessages![_i]\n\t{\n\t\t$.println(msg.priority, msg.text)\n\t}\n}\n$.println(\"done\")\n}\n\n",
    "expectedOutput": "0 Main: Starting workers\n1 Main: Workers started\n10 Worker 0 starting\n11 Worker 1 starting\n12 Worker 2 starting\n20 Worker 0 done\n21 Worker 1 done\n22 Worker 2 done\n40 Another worker: test\n50 Anonymous function worker\n100 Main: All workers completed\ndone"
  },
  {
    "name": "goroutines_anonymous",
    "goCode": "package main\n\nfunc main() {\n\t// Start an anonymous function worker\n\tmsgs := make(chan string, 1)\n\tgo func() {\n\t\tmsgs <- \"anonymous function worker\"\n\t}()\n\tprintln(<-msgs)\n}\n",
    "tsCode": "// Generated file based on goroutines_anonymous.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Start an anonymous function worker\n\tlet msgs = $.makeChannel<string>(1, \"\", 'both')\n\tqueueMicrotask(async () => {\n\t\tawait $.chanSend(msgs, \"anonymous function worker\")\n\t})\n\t$.println(await $.chanRecv(msgs))\n}\n\n",
    "expectedOutput": "anonymous function worker"
  },
  {
    "name": "goroutines_selector",
    "goCode": "package main\n\ntype Foo struct {\n\tdone chan bool\n}\n\nfunc NewFoo() *Foo {\n\treturn &Foo{done: make(chan bool)}\n}\n\nfunc (f *Foo) Bar() {\n\tprintln(\"Foo.Bar called\")\n\tf.done <- true\n}\n\nfunc main() {\n\tf := NewFoo()\n\tgo f.Bar()\n\t<-f.done // Wait for the goroutine to complete\n\tprintln(\"main done\")\n}\n",
    "tsCode": "// Generated file based on goroutines_selector.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Foo {\n\tpublic get done(): $.Channel<boolean> | null {\n\t\treturn this._fields.done.value\n\t}\n\tpublic set done(value: $.Channel<boolean> | null) {\n\t\tthis._fields.done.value = value\n\t}\n\n\tpublic _fields: {\n\t\tdone: $.VarRef<$.Channel<boolean> | null>;\n\t}\n\n\tconstructor(init?: Partial<{done?: $.Channel<boolean> | null}>) {\n\t\tthis._fields = {\n\t\t\tdone: $.varRef(init?.done ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): Foo {\n\t\tconst cloned = new Foo()\n\t\tcloned._fields = {\n\t\t\tdone: $.varRef(this._fields.done.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic async Bar(): Promise<void> {\n\t\tconst f = this\n\t\t$.println(\"Foo.Bar called\")\n\t\tawait $.chanSend(f.done, true)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Foo',\n\t  new Foo(),\n\t  [{ name: \"Bar\", args: [], returns: [] }],\n\t  Foo,\n\t  {\"done\": { kind: $.TypeKind.Channel, direction: \"both\", elemType: { kind: $.TypeKind.Basic, name: \"bool\" } }}\n\t);\n}\n\nexport function NewFoo(): Foo | null {\n\treturn new Foo({done: $.makeChannel<boolean>(0, false, 'both')})\n}\n\nexport async function main(): Promise<void> {\n\tlet f = NewFoo()\n\tqueueMicrotask(async () => {\n\t\tawait f!.Bar()\n\t})\n\tawait $.chanRecv(f!.done)\n\t$.println(\"main done\")\n}\n\n",
    "expectedOutput": "Foo.Bar called\nmain done\n"
  },
  {
    "name": "hex_escape_sequence",
    "goCode": "package main\n\nfunc main() {\n\t// Test hexadecimal escape sequences in string literals\n\t// This should reproduce the error: TS1125: Hexadecimal digit expected.\n\n\t// This reproduces the original error: buf = $.append(buf, `\\x`)\n\tvar buf []byte\n\tbuf = append(buf, `\\x`...)\n\tprintln(\"Appended raw string with \\\\x:\", string(buf))\n\n\t// Raw string with incomplete hex escape\n\ts1 := `\\x` // This should be treated as literal \\x\n\tprintln(\"Raw string with \\\\x:\", s1)\n\n\t// Raw string with \\x followed by non-hex\n\ts2 := `\\xG` // This should be treated as literal \\xG\n\tprintln(\"Raw string with \\\\xG:\", s2)\n\n\t// Interpreted string with \\x escape sequence\n\ts3 := \"\\x41\" // This should be treated as hex escape for 'A'\n\tprintln(\"Interpreted string:\", s3)\n}\n",
    "tsCode": "// Generated file based on hex_escape_sequence.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test hexadecimal escape sequences in string literals\n\t// This should reproduce the error: TS1125: Hexadecimal digit expected.\n\n\t// This reproduces the original error: buf = $.append(buf, `\\x`)\n\tlet buf: $.Bytes = new Uint8Array(0)\n\tbuf = $.append(buf, ...$.stringToBytes(\"\\\\x\"))\n\t$.println(\"Appended raw string with \\\\x:\", $.bytesToString(buf))\n\n\t// Raw string with incomplete hex escape\n\tlet s1 = \"\\\\x\" // This should be treated as literal \\x\n\t$.println(\"Raw string with \\\\x:\", s1)\n\n\t// Raw string with \\x followed by non-hex\n\tlet s2 = \"\\\\xG\" // This should be treated as literal \\xG\n\t$.println(\"Raw string with \\\\xG:\", s2)\n\n\t// Interpreted string with \\x escape sequence\n\tlet s3 = \"\\x41\" // This should be treated as hex escape for 'A'\n\t$.println(\"Interpreted string:\", s3)\n}\n\n",
    "expectedOutput": "Appended raw string with \\x: \\x\nRaw string with \\x: \\x\nRaw string with \\xG: \\xG\nInterpreted string: A\n"
  },
  {
    "name": "if_statement",
    "goCode": "package main\n\nfunc main() {\n\t// === If Statement ===\n\tn := 7\n\tif n%2 == 0 {\n\t\tprintln(\"Even: Expected: (no output)\")\n\t} else {\n\t\tprintln(\"Odd: Expected: Odd, Actual: Odd\")\n\t}\n}\n",
    "tsCode": "// Generated file based on if_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// === If Statement ===\n\tlet n = 7\n\tif (n % 2 == 0) {\n\t\t$.println(\"Even: Expected: (no output)\")\n\t} else {\n\t\t$.println(\"Odd: Expected: Odd, Actual: Odd\")\n\t}\n}\n\n",
    "expectedOutput": "Odd: Expected: Odd, Actual: Odd"
  },
  {
    "name": "if_type_assert",
    "goCode": "package main\n\nfunc main() {\n\tvar a any\n\ta = \"this is a string\"\n\tif _, ok := a.(string); ok {\n\t\tprintln(\"Expected: string\")\n\t} else {\n\t\tprintln(\"Not Expected: should be a string\")\n\t}\n\n\t// this is from go/ast/filter.go, line 117\n\ttype KV struct {\n\t\tKey any\n\t}\n\n\tvar list []any\n\tkv := &KV{Key: \"string\"}\n\tlist = []any{kv}\n\tfor _, exp := range list {\n\t\tswitch x := exp.(type) {\n\t\tcase *KV:\n\t\t\tif x, ok := x.Key.(string); ok {\n\t\t\t\tprintln(\"got string:\", x)\n\t\t\t} else {\n\t\t\t\tprintln(\"fail: should be string\")\n\t\t\t}\n\t\tdefault:\n\t\t\tprintln(\"fail: should be KV\")\n\t\t}\n\t}\n}\n",
    "tsCode": "// Generated file based on if_type_assert.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet a: null | any = null\n\ta = \"this is a string\"\n\t{\n\t\tlet { ok: ok } = $.typeAssert<string>(a, {kind: $.TypeKind.Basic, name: 'string'})\n\t\tif (ok) {\n\t\t\t$.println(\"Expected: string\")\n\t\t} else {\n\t\t\t$.println(\"Not Expected: should be a string\")\n\t\t}\n\t}\n\n\t// this is from go/ast/filter.go, line 117\n\tclass KV {\n\t\tpublic get Key(): null | any {\n\t\t\treturn this._fields.Key.value\n\t\t}\n\t\tpublic set Key(value: null | any) {\n\t\t\tthis._fields.Key.value = value\n\t\t}\n\n\t\tpublic _fields: {\n\t\t\tKey: $.VarRef<null | any>;\n\t\t}\n\n\t\tconstructor(init?: Partial<{Key?: null | any}>) {\n\t\t\tthis._fields = {\n\t\t\t\tKey: $.varRef(init?.Key ?? null)\n\t\t\t}\n\t\t}\n\n\t\tpublic clone(): KV {\n\t\t\tconst cloned = new KV()\n\t\t\tcloned._fields = {\n\t\t\t\tKey: $.varRef(this._fields.Key.value)\n\t\t\t}\n\t\t\treturn cloned\n\t\t}\n\n\t\t// Register this type with the runtime type system\n\t\tstatic __typeInfo = $.registerStructType(\n\t\t  'main.KV',\n\t\t  new KV(),\n\t\t  [],\n\t\t  KV,\n\t\t  {\"Key\": { kind: $.TypeKind.Interface, methods: [] }}\n\t\t);\n\t}\n\n\tlet list: $.Slice<null | any> = null\n\tlet kv = new KV({Key: \"string\"})\n\tlist = $.arrayToSlice<null | any>([kv])\n\tfor (let _i = 0; _i < $.len(list); _i++) {\n\t\tlet exp = list![_i]\n\t\t{\n\t\t\t$.typeSwitch(exp, [{ types: [{kind: $.TypeKind.Pointer, elemType: 'main.KV'}], body: (x) => {\n\t\t\t\tconst _temp_x = x\n\t\t\t\t{\n\t\t\t\t\tlet { value: x, ok: ok } = $.typeAssert<string>(_temp_x.Key, {kind: $.TypeKind.Basic, name: 'string'})\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t$.println(\"got string:\", x)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$.println(\"fail: should be string\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}}], () => {\n\t\t\t\t$.println(\"fail: should be KV\")\n\t\t\t})\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Expected: string\ngot string: string\n"
  },
  {
    "name": "import_interface",
    "goCode": "package main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// This test is intended for checking the .gs.ts that is generated\n// rather than the actual execution behavior or output.\n\n// This test demonstrates the issue where os.FileInfo gets expanded\n// to its full type definition instead of preserving the interface name\nfunc walkFunction(path string, info os.FileInfo, walkFn filepath.WalkFunc) error {\n\t// Simple test function that takes os.FileInfo as parameter\n\tif info != nil {\n\t\tprintln(\"File:\", info.Name())\n\t}\n\t_, _ = path, walkFn\n\treturn nil\n}\n\n// Also test as a return type\nfunc getFileInfo() (os.FileInfo, error) {\n\treturn nil, nil\n}\n\nfunc main() {\n\t// Test os.FileInfo interface is preserved in function signatures\n\tprintln(\"Testing os.FileInfo interface preservation\")\n\twalkFunction(\".\", nil, nil)\n\n\tinfo, err := getFileInfo()\n\tif err == nil && info != nil {\n\t\tprintln(\"Got FileInfo:\", info.Name())\n\t}\n}\n",
    "tsCode": "// Generated file based on import_interface.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nimport * as filepath from \"@goscript/path/filepath/index.js\"\n\n// This test demonstrates the issue where os.FileInfo gets expanded\n// to its full type definition instead of preserving the interface name\nexport function walkFunction(path: string, info: null | os.FileInfo, walkFn: filepath.WalkFunc | null): $.GoError {\n\t// Simple test function that takes os.FileInfo as parameter\n\tif (info != null) {\n\t\t$.println(\"File:\", info!.Name())\n\t}\n\t;[, ] = [path, walkFn]\n\treturn null\n}\n\n// Also test as a return type\nexport function getFileInfo(): [null | os.FileInfo, $.GoError] {\n\treturn [null, null]\n}\n\nexport async function main(): Promise<void> {\n\t// Test os.FileInfo interface is preserved in function signatures\n\t$.println(\"Testing os.FileInfo interface preservation\")\n\twalkFunction(\".\", null, null)\n\n\tlet [info, err] = getFileInfo()\n\tif (err == null && info != null) {\n\t\t$.println(\"Got FileInfo:\", info!.Name())\n\t}\n}\n\n",
    "expectedOutput": "Testing os.FileInfo interface preservation\n"
  },
  {
    "name": "import_type_methods",
    "goCode": "package main\n\nimport (\n\t\"github.com/aperturerobotics/goscript/tests/tests/import_type_methods/errlist\"\n)\n\ntype parser struct {\n\terrors errlist.ErrorList\n}\n\nfunc main() {\n\tvar p parser\n\tp.errors = p.errors.Add(\"error\")\n\tprintln(p.errors[0])\n}\n",
    "tsCode": "// Generated file based on import_type_methods.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as errlist from \"@goscript/github.com/aperturerobotics/goscript/tests/tests/import_type_methods/errlist/index.js\"\n\nexport class parser {\n\tpublic get errors(): errlist.ErrorList {\n\t\treturn this._fields.errors.value\n\t}\n\tpublic set errors(value: errlist.ErrorList) {\n\t\tthis._fields.errors.value = value\n\t}\n\n\tpublic _fields: {\n\t\terrors: $.VarRef<errlist.ErrorList>;\n\t}\n\n\tconstructor(init?: Partial<{errors?: errlist.ErrorList}>) {\n\t\tthis._fields = {\n\t\t\terrors: $.varRef(init?.errors ?? null as errlist.ErrorList)\n\t\t}\n\t}\n\n\tpublic clone(): parser {\n\t\tconst cloned = new parser()\n\t\tcloned._fields = {\n\t\t\terrors: $.varRef(this._fields.errors.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.parser',\n\t  new parser(),\n\t  [],\n\t  parser,\n\t  {\"errors\": \"ErrorList\"}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p: parser = new parser()\n\tp.errors = errlist.ErrorList_Add(p.errors, \"error\")\n\t$.println(p.errors![0])\n}\n\n",
    "expectedOutput": "error"
  },
  {
    "name": "index_expr_destructuring",
    "goCode": "package main\n\nfunc returnTwoInts() (int, int) {\n\treturn 42, 24\n}\n\nfunc returnIntAndString() (int, string) {\n\treturn 42, \"hello\"\n}\n\nfunc main() {\n\t// Create arrays/slices to test index expressions in destructuring\n\tvar intArray [2]int\n\tvar stringSlice []string = make([]string, 2)\n\n\t// This should trigger the \"unhandled LHS expression in destructuring: *ast.IndexExpr\" error\n\tintArray[0], stringSlice[1] = returnIntAndString()\n\n\tprintln(\"intArray[0]:\", intArray[0])\n\tprintln(\"stringSlice[1]:\", stringSlice[1])\n\n\t// Test with more complex index expressions\n\tvar matrix [2][2]int\n\tvar i, j int = 0, 1\n\n\tmatrix[i][j], intArray[1] = returnTwoInts()\n\n\tprintln(\"matrix[0][1]:\", matrix[0][1])\n\tprintln(\"intArray[1]:\", intArray[1])\n}\n",
    "tsCode": "// Generated file based on index_expr_destructuring.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function returnTwoInts(): [number, number] {\n\treturn [42, 24]\n}\n\nexport function returnIntAndString(): [number, string] {\n\treturn [42, \"hello\"]\n}\n\nexport async function main(): Promise<void> {\n\t// Create arrays/slices to test index expressions in destructuring\n\tlet intArray: number[] = [0, 0]\n\tlet stringSlice: $.Slice<string> = $.makeSlice<string>(2, undefined, 'string')\n\n\t// This should trigger the \"unhandled LHS expression in destructuring: *ast.IndexExpr\" error\n\t{\n\t  const _tmp = returnIntAndString()\n\t  intArray![0] = _tmp[0]\n\t  stringSlice![1] = _tmp[1]\n\t}\n\n\t$.println(\"intArray[0]:\", intArray![0])\n\t$.println(\"stringSlice[1]:\", stringSlice![1])\n\n\t// Test with more complex index expressions\n\tlet matrix: number[][] = [[0, 0], [0, 0]]\n\tlet [i, j] = [0, 1]\n\n\t{\n\t  const _tmp = returnTwoInts()\n\t  matrix![i]![j] = _tmp[0]\n\t  intArray![1] = _tmp[1]\n\t}\n\n\t$.println(\"matrix[0][1]:\", matrix![0]![1])\n\t$.println(\"intArray[1]:\", intArray![1])\n}\n\n",
    "expectedOutput": "intArray[0]: 42\nstringSlice[1]: hello\nmatrix[0][1]: 42\nintArray[1]: 24 "
  },
  {
    "name": "index_expr_type_assertion",
    "goCode": "package main\n\nfunc main() {\n\t// Test type assertion assignment with indexed LHS using regular assignment\n\tvar slice []interface{} = []interface{}{\"hello\", 42, true}\n\tvar results [2]interface{}\n\tvar ok bool\n\tresults[0], ok = slice[1].(int)\n\tif ok {\n\t\tprintln(\"slice[1] as int:\", results[0].(int))\n\t}\n\n\t// Test type assertion assignment with map indexed LHS using regular assignment\n\tvar m map[string]interface{} = make(map[string]interface{})\n\tm[\"key2\"] = 123\n\tvar mapResults map[string]interface{} = make(map[string]interface{})\n\tvar ok2 bool\n\tmapResults[\"result\"], ok2 = m[\"key2\"].(int)\n\tif ok2 {\n\t\tprintln(\"m[key2] as int:\", mapResults[\"result\"].(int))\n\t}\n}\n",
    "tsCode": "// Generated file based on index_expr_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test type assertion assignment with indexed LHS using regular assignment\n\tlet slice = $.arrayToSlice<null | any>([\"hello\", 42, true])\n\tlet results: null | any[] = [null, null]\n\tlet ok: boolean = false\n\tlet _gs_ta_val_cd3f: number\n\tlet _gs_ta_ok_cd3f: boolean\n\t({ value: _gs_ta_val_cd3f, ok: _gs_ta_ok_cd3f } = $.typeAssert<number>(slice![1], {kind: $.TypeKind.Basic, name: 'number'}))\n\tresults![0] = _gs_ta_val_cd3f\n\tok = _gs_ta_ok_cd3f\n\tif (ok) {\n\t\t$.println(\"slice[1] as int:\", $.mustTypeAssert<number>(results![0], {kind: $.TypeKind.Basic, name: 'number'}))\n\t}\n\n\t// Test type assertion assignment with map indexed LHS using regular assignment\n\tlet m: Map<string, null | any> | null = $.makeMap<string, null | any>()\n\t$.mapSet(m, \"key2\", 123)\n\tlet mapResults: Map<string, null | any> | null = $.makeMap<string, null | any>()\n\tlet ok2: boolean = false\n\tlet _gs_ta_val_4f04: number\n\tlet _gs_ta_ok_4f04: boolean\n\t({ value: _gs_ta_val_4f04, ok: _gs_ta_ok_4f04 } = $.typeAssert<number>($.mapGet(m, \"key2\", null)[0], {kind: $.TypeKind.Basic, name: 'number'}))\n\t$.mapSet(mapResults, \"result\", _gs_ta_val_4f04)\n\tok2 = _gs_ta_ok_4f04\n\tif (ok2) {\n\t\t$.println(\"m[key2] as int:\", $.mustTypeAssert<number>($.mapGet(mapResults, \"result\", null)[0], {kind: $.TypeKind.Basic, name: 'number'}))\n\t}\n}\n\n",
    "expectedOutput": "slice[1] as int: 42\nm[key2] as int: 123 "
  },
  {
    "name": "inline_function_type_cast",
    "goCode": "package main\n\n// 1. Create a type for a function\ntype Greeter func(name string) string\n\nfunc main() {\n\t// 2. Create an inline variable with the inline function satisfying that type.\n\ttheInlineVar := func(name string) string {\n\t\treturn \"Hello, \" + name\n\t}\n\n\t// 3. Use Greeter(theInlineVar) to cast to the Greeter declared function type.\n\tcastedGreeter := Greeter(theInlineVar)\n\n\t// 4. Call that\n\tprintln(castedGreeter(\"Inline World\"))\n\n\t// Test with a different signature\n\ttype Adder func(a, b int) int\n\ttheInlineAdder := func(a, b int) int {\n\t\treturn a + b\n\t}\n\tcastedAdder := Adder(theInlineAdder)\n\tprintln(castedAdder(5, 7))\n}\n",
    "tsCode": "// Generated file based on inline_function_type_cast.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type Greeter = ((name: string) => string) | null;\n\nexport async function main(): Promise<void> {\n\t// 2. Create an inline variable with the inline function satisfying that type.\n\tlet theInlineVar = (name: string): string => {\n\t\treturn \"Hello, \" + name\n\t}\n\n\t// 3. Use Greeter(theInlineVar) to cast to the Greeter declared function type.\n\tlet castedGreeter = Object.assign(theInlineVar, { __goTypeName: 'Greeter' })\n\n\t// 4. Call that\n\t$.println(castedGreeter!(\"Inline World\"))\n\n\t// Test with a different signature\n\ttype Adder = ((a: number, b: number) => number) | null;\n\tlet theInlineAdder = (a: number, b: number): number => {\n\t\treturn a + b\n\t}\n\tlet castedAdder = Object.assign(theInlineAdder, { __goTypeName: 'Adder' })\n\t$.println(castedAdder!(5, 7))\n}\n\n",
    "expectedOutput": "Hello, Inline World\n12"
  },
  {
    "name": "inline_interface_type_assertion",
    "goCode": "package main\n\ntype Greeter struct{}\n\nfunc (g Greeter) Greet() string {\n\treturn \"Hello from Greeter\"\n}\n\ntype Stringer interface {\n\tString() string\n}\n\ntype MyStringer struct{}\n\nfunc (ms MyStringer) String() string {\n\treturn \"MyStringer implementation\"\n}\n\nfunc main() {\n\tvar i interface{}\n\ti = Greeter{}\n\n\t// Successful type assertion to an inline interface\n\tg, ok := i.(interface{ Greet() string })\n\tif ok {\n\t\tprintln(\"Greet assertion successful:\", g.Greet())\n\t} else {\n\t\tprintln(\"Greet assertion failed\")\n\t}\n\n\t// Failing type assertion to a different inline interface\n\ts, ok2 := i.(interface{ NonExistentMethod() int })\n\tif ok2 {\n\t\tprintln(\"NonExistentMethod assertion successful (unexpected):\", s.NonExistentMethod())\n\t} else {\n\t\tprintln(\"NonExistentMethod assertion failed as expected\")\n\t}\n\n\t// Successful type assertion to a named interface, where the asserted value also implements an inline interface method\n\tvar j interface{}\n\tj = MyStringer{}\n\n\t// Assert 'j' (which holds MyStringer) to an inline interface that MyStringer satisfies.\n\tinlineMs, ok4 := j.(interface{ String() string })\n\tif ok4 {\n\t\tprintln(\"Inline String assertion successful:\", inlineMs.String())\n\t} else {\n\t\tprintln(\"Inline String assertion failed\")\n\t}\n\n\t// Test case: variable of named interface type, asserted to inline interface\n\tvar k Stringer\n\tk = MyStringer{}\n\n\tinlineK, ok5 := k.(interface{ String() string })\n\tif ok5 {\n\t\tprintln(\"k.(interface{ String() string }) successful:\", inlineK.String())\n\t} else {\n\t\tprintln(\"k.(interface{ String() string }) failed\")\n\t}\n\n\t// Test case: nil value of an inline interface type assigned to interface{}\n\tvar l any = (*struct {\n\t\tName string\n\t})(nil)\n\n\tptr, ok6 := l.(*struct{ Name string })\n\tif ok6 {\n\t\tif ptr == nil {\n\t\t\tprintln(\"l.(*struct{ Name string }) successful, ptr is nil as expected\")\n\t\t} else {\n\t\t\tprintln(\"l.(*struct{ Name string }) successful, but ptr is not nil (unexpected)\")\n\t\t}\n\t} else {\n\t\tprintln(\"l.(*struct{ Name string }) failed (unexpected)\")\n\t}\n}\n",
    "tsCode": "// Generated file based on inline_interface_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Greeter {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): Greeter {\n\t\tconst cloned = new Greeter()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Greet(): string {\n\t\treturn \"Hello from Greeter\"\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Greeter',\n\t  new Greeter(),\n\t  [{ name: \"Greet\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  Greeter,\n\t  {}\n\t);\n}\n\nexport class MyStringer {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MyStringer {\n\t\tconst cloned = new MyStringer()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic String(): string {\n\t\treturn \"MyStringer implementation\"\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStringer',\n\t  new MyStringer(),\n\t  [{ name: \"String\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  MyStringer,\n\t  {}\n\t);\n}\n\nexport type Stringer = null | {\n\tString(): string\n}\n\n$.registerInterfaceType(\n  'main.Stringer',\n  null, // Zero value for interface is null\n  [{ name: \"String\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport async function main(): Promise<void> {\n\tlet i: null | any = null\n\ti = $.markAsStructValue(new Greeter({}))\n\n\t// Successful type assertion to an inline interface\n\tlet { value: g, ok: ok } = $.typeAssert<null | {\n\t\tGreet(): string\n\t}>(i, {kind: $.TypeKind.Interface, methods: [{ name: 'Greet', args: [], returns: [{ type: {kind: $.TypeKind.Basic, name: 'string'} }] }]})\n\tif (ok) {\n\t\t$.println(\"Greet assertion successful:\", g!.Greet())\n\t} else {\n\t\t$.println(\"Greet assertion failed\")\n\t}\n\n\t// Failing type assertion to a different inline interface\n\tlet { value: s, ok: ok2 } = $.typeAssert<null | {\n\t\tNonExistentMethod(): number\n\t}>(i, {kind: $.TypeKind.Interface, methods: [{ name: 'NonExistentMethod', args: [], returns: [{ type: {kind: $.TypeKind.Basic, name: 'number'} }] }]})\n\tif (ok2) {\n\t\t$.println(\"NonExistentMethod assertion successful (unexpected):\", s!.NonExistentMethod())\n\t} else {\n\t\t$.println(\"NonExistentMethod assertion failed as expected\")\n\t}\n\n\t// Successful type assertion to a named interface, where the asserted value also implements an inline interface method\n\tlet j: null | any = null\n\tj = $.markAsStructValue(new MyStringer({}))\n\n\t// Assert 'j' (which holds MyStringer) to an inline interface that MyStringer satisfies.\n\tlet { value: inlineMs, ok: ok4 } = $.typeAssert<null | {\n\t\tString(): string\n\t}>(j, {kind: $.TypeKind.Interface, methods: [{ name: 'String', args: [], returns: [{ type: {kind: $.TypeKind.Basic, name: 'string'} }] }]})\n\tif (ok4) {\n\t\t$.println(\"Inline String assertion successful:\", inlineMs!.String())\n\t} else {\n\t\t$.println(\"Inline String assertion failed\")\n\t}\n\n\t// Test case: variable of named interface type, asserted to inline interface\n\tlet k: Stringer = null\n\tk = $.markAsStructValue(new MyStringer({}))\n\n\tlet { value: inlineK, ok: ok5 } = $.typeAssert<null | {\n\t\tString(): string\n\t}>(k, {kind: $.TypeKind.Interface, methods: [{ name: 'String', args: [], returns: [{ type: {kind: $.TypeKind.Basic, name: 'string'} }] }]})\n\tif (ok5) {\n\t\t$.println(\"k.(interface{ String() string }) successful:\", inlineK!.String())\n\t} else {\n\t\t$.println(\"k.(interface{ String() string }) failed\")\n\t}\n\n\t// Test case: nil value of an inline interface type assigned to interface{}\n\tlet l: null | any = $.typedNil(\"*struct{Name string}\")\n\n\tlet { value: ptr, ok: ok6 } = $.typeAssert<{ Name?: string } | null>(l, {kind: $.TypeKind.Pointer, elemType: {kind: $.TypeKind.Struct, fields: {'Name': {kind: $.TypeKind.Basic, name: 'string'}}, methods: []}})\n\tif (ok6) {\n\t\tif (ptr == null) {\n\t\t\t$.println(\"l.(*struct{ Name string }) successful, ptr is nil as expected\")\n\t\t} else {\n\t\t\t$.println(\"l.(*struct{ Name string }) successful, but ptr is not nil (unexpected)\")\n\t\t}\n\t} else {\n\t\t$.println(\"l.(*struct{ Name string }) failed (unexpected)\")\n\t}\n}\n\n",
    "expectedOutput": "Greet assertion successful: Hello from Greeter\nNonExistentMethod assertion failed as expected\nInline String assertion successful: MyStringer implementation\nk.(interface{ String() string }) successful: MyStringer implementation\nl.(*struct{ Name string }) successful, ptr is nil as expected"
  },
  {
    "name": "interface_async_method_call",
    "goCode": "package main\n\n// Interface with a method that will be async due to implementation\ntype AsyncProcessor interface {\n\tProcess(data int) int\n\tGetResult() int\n}\n\n// Implementation that uses channels, making Process async\ntype ChannelProcessor struct {\n\tch chan int\n}\n\nfunc (p *ChannelProcessor) Process(data int) int {\n\t// Channel operation makes this function async\n\tp.ch <- data\n\tresult := <-p.ch\n\treturn result * 2\n}\n\nfunc (p *ChannelProcessor) GetResult() int {\n\t// This method is sync\n\treturn 42\n}\n\n// Implementation that's naturally sync but must be async-compatible\ntype SimpleProcessor struct {\n\tvalue int\n}\n\nfunc (p *SimpleProcessor) Process(data int) int {\n\t// Simple operation, but must be async due to interface constraint\n\treturn data + 10\n}\n\nfunc (p *SimpleProcessor) GetResult() int {\n\treturn p.value\n}\n\n// Function that calls async method on interface\nfunc processViaInterface(processor AsyncProcessor, input int) int {\n\t// This call should be awaited in TypeScript since Process is async\n\tresult := processor.Process(input)\n\n\t// This call should NOT be awaited since GetResult is sync\n\tbaseResult := processor.GetResult()\n\n\treturn result + baseResult\n}\n\nfunc main() {\n\t// Create a buffered channel\n\tch := make(chan int, 1)\n\n\t// Test with ChannelProcessor (naturally async)\n\tchannelProc := &ChannelProcessor{ch: ch}\n\tresult1 := processViaInterface(channelProc, 5)\n\tprintln(\"ChannelProcessor result:\", result1) // Expected: 52 (5*2 + 42)\n\n\t// Test with SimpleProcessor (forced async for compatibility)\n\tsimpleProc := &SimpleProcessor{value: 100}\n\tresult2 := processViaInterface(simpleProc, 5)\n\tprintln(\"SimpleProcessor result:\", result2) // Expected: 115 (5+10 + 100)\n\n\tclose(ch)\n}\n",
    "tsCode": "// Generated file based on interface_async_method_call.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type AsyncProcessor = null | {\n\tGetResult(): number\n\tProcess(data: number): Promise<number>\n}\n\n$.registerInterfaceType(\n  'main.AsyncProcessor',\n  null, // Zero value for interface is null\n  [{ name: \"GetResult\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }, { name: \"Process\", args: [{ name: \"data\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }]\n);\n\nexport class ChannelProcessor {\n\tpublic get ch(): $.Channel<number> | null {\n\t\treturn this._fields.ch.value\n\t}\n\tpublic set ch(value: $.Channel<number> | null) {\n\t\tthis._fields.ch.value = value\n\t}\n\n\tpublic _fields: {\n\t\tch: $.VarRef<$.Channel<number> | null>;\n\t}\n\n\tconstructor(init?: Partial<{ch?: $.Channel<number> | null}>) {\n\t\tthis._fields = {\n\t\t\tch: $.varRef(init?.ch ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): ChannelProcessor {\n\t\tconst cloned = new ChannelProcessor()\n\t\tcloned._fields = {\n\t\t\tch: $.varRef(this._fields.ch.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic async Process(data: number): Promise<number> {\n\t\tconst p = this\n\t\tawait $.chanSend(p.ch, data)\n\t\tlet result = await $.chanRecv(p.ch)\n\t\treturn result * 2\n\t}\n\n\tpublic GetResult(): number {\n\t\treturn 42\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.ChannelProcessor',\n\t  new ChannelProcessor(),\n\t  [{ name: \"Process\", args: [{ name: \"data\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }, { name: \"GetResult\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  ChannelProcessor,\n\t  {\"ch\": { kind: $.TypeKind.Channel, direction: \"both\", elemType: { kind: $.TypeKind.Basic, name: \"int\" } }}\n\t);\n}\n\nexport class SimpleProcessor {\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{value?: number}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): SimpleProcessor {\n\t\tconst cloned = new SimpleProcessor()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic async Process(data: number): Promise<number> {\n\t\treturn data + 10\n\t}\n\n\tpublic GetResult(): number {\n\t\tconst p = this\n\t\treturn p.value\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.SimpleProcessor',\n\t  new SimpleProcessor(),\n\t  [{ name: \"Process\", args: [{ name: \"data\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }, { name: \"GetResult\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  SimpleProcessor,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\n// Function that calls async method on interface\nexport async function processViaInterface(processor: AsyncProcessor, input: number): Promise<number> {\n\t// This call should be awaited in TypeScript since Process is async\n\tlet result = await processor!.Process(input)\n\n\t// This call should NOT be awaited since GetResult is sync\n\tlet baseResult = processor!.GetResult()\n\n\treturn result + baseResult\n}\n\nexport async function main(): Promise<void> {\n\t// Create a buffered channel\n\tlet ch = $.makeChannel<number>(1, 0, 'both')\n\n\t// Test with ChannelProcessor (naturally async)\n\tlet channelProc = new ChannelProcessor({ch: ch})\n\tlet result1 = await processViaInterface(channelProc, 5)\n\t$.println(\"ChannelProcessor result:\", result1) // Expected: 52 (5*2 + 42)\n\n\t// Test with SimpleProcessor (forced async for compatibility)\n\tlet simpleProc = new SimpleProcessor({value: 100})\n\tlet result2 = await processViaInterface(simpleProc, 5)\n\t$.println(\"SimpleProcessor result:\", result2) // Expected: 115 (5+10 + 100)\n\n\tch.close()\n}\n\n",
    "expectedOutput": "ChannelProcessor result: 52\nSimpleProcessor result: 115\n"
  },
  {
    "name": "interface_embedding",
    "goCode": "package main\n\nimport (\n\t\"io\"\n\n\t\"github.com/aperturerobotics/goscript/tests/tests/interface_embedding/subpkg\"\n)\n\n// File represents a file interface similar to billy.File\ntype File interface {\n\t// Name returns the name of the file as presented to Open.\n\tName() string\n\tio.Writer\n\tio.Reader\n\tio.ReaderAt\n\tio.Seeker\n\tio.Closer\n\t// Lock locks the file like e.g. flock. It protects against access from\n\t// other processes.\n\tLock() error\n\t// Unlock unlocks the file.\n\tUnlock() error\n\t// Truncate the file.\n\tTruncate(size int64) error\n}\n\n// MockFile is a simple implementation of the File interface for testing\ntype MockFile struct {\n\tfilename string\n\tcontent  []byte\n\tposition int64\n}\n\nfunc (m *MockFile) Name() string {\n\treturn m.filename\n}\n\nfunc (m *MockFile) Write(p []byte) (int, error) {\n\tm.content = append(m.content, p...)\n\treturn len(p), nil\n}\n\nfunc (m *MockFile) Read(p []byte) (int, error) {\n\tremaining := len(m.content) - int(m.position)\n\tif remaining <= 0 {\n\t\treturn 0, io.EOF\n\t}\n\n\tn := copy(p, m.content[m.position:])\n\tm.position += int64(n)\n\treturn n, nil\n}\n\nfunc (m *MockFile) ReadAt(p []byte, off int64) (int, error) {\n\tif off >= int64(len(m.content)) {\n\t\treturn 0, io.EOF\n\t}\n\n\tn := copy(p, m.content[off:])\n\treturn n, nil\n}\n\nfunc (m *MockFile) Seek(offset int64, whence int) (int64, error) {\n\tswitch whence {\n\tcase 0: // io.SeekStart\n\t\tm.position = offset\n\tcase 1: // io.SeekCurrent\n\t\tm.position += offset\n\tcase 2: // io.SeekEnd\n\t\tm.position = int64(len(m.content)) + offset\n\t}\n\treturn m.position, nil\n}\n\nfunc (m *MockFile) Close() error {\n\treturn nil\n}\n\nfunc (m *MockFile) Lock() error {\n\treturn nil\n}\n\nfunc (m *MockFile) Unlock() error {\n\treturn nil\n}\n\nfunc (m *MockFile) Truncate(size int64) error {\n\tif size < int64(len(m.content)) {\n\t\tm.content = m.content[:size]\n\t}\n\treturn nil\n}\n\n// This is the struct that embeds the File interface\ntype file struct {\n\tFile\n\tname string\n}\n\nfunc (f *file) Name() string {\n\treturn f.name\n}\n\n// This struct embeds the qualified interface from subpkg to test qualified names\ntype qualifiedFile struct {\n\tsubpkg.File // This should generate: constructor(init?: Partial<{File?: subpkg.File, metadata?: string}>)\n\tmetadata    string\n}\n\nfunc main() {\n\t// Create a mock file implementation\n\tmockFile := &MockFile{\n\t\tfilename: \"test.txt\",\n\t\tcontent:  []byte(\"Hello, World!\"),\n\t\tposition: 0,\n\t}\n\n\t// Create our embedded file struct\n\tf := &file{\n\t\tFile: mockFile,\n\t\tname: \"custom_name.txt\",\n\t}\n\n\t// Test accessing the custom Name() method\n\tprintln(\"Custom name:\", f.Name())\n\n\t// Test accessing embedded interface methods - these should have null assertions\n\tprintln(\"File name:\", f.File.Name())\n\n\t// Test other embedded methods\n\terr := f.Lock()\n\tif err != nil {\n\t\tprintln(\"Lock error:\", err.Error())\n\t} else {\n\t\tprintln(\"Lock successful\")\n\t}\n\n\terr = f.Unlock()\n\tif err != nil {\n\t\tprintln(\"Unlock error:\", err.Error())\n\t} else {\n\t\tprintln(\"Unlock successful\")\n\t}\n\n\t// Test Write\n\tdata := []byte(\"test data\")\n\tn, err := f.Write(data)\n\tif err != nil {\n\t\tprintln(\"Write error:\", err.Error())\n\t} else {\n\t\tprintln(\"Wrote bytes:\", n)\n\t}\n\n\t// Test Read\n\tbuf := make([]byte, 5)\n\tn, err = f.Read(buf)\n\tif err != nil {\n\t\tprintln(\"Read error:\", err.Error())\n\t} else {\n\t\tprintln(\"Read bytes:\", n)\n\t}\n\n\t// Test ReadAt\n\tbuf2 := make([]byte, 5)\n\tn, err = f.ReadAt(buf2, 0)\n\tif err != nil {\n\t\tprintln(\"ReadAt error:\", err.Error())\n\t} else {\n\t\tprintln(\"ReadAt bytes:\", n)\n\t}\n\n\t// Test Seek\n\tpos, err := f.Seek(0, 0)\n\tif err != nil {\n\t\tprintln(\"Seek error:\", err.Error())\n\t} else {\n\t\tprintln(\"Seek position:\", pos)\n\t}\n\n\t// Test Truncate\n\terr = f.Truncate(5)\n\tif err != nil {\n\t\tprintln(\"Truncate error:\", err.Error())\n\t} else {\n\t\tprintln(\"Truncate successful\")\n\t}\n\n\t// Test Close\n\terr = f.Close()\n\tif err != nil {\n\t\tprintln(\"Close error:\", err.Error())\n\t} else {\n\t\tprintln(\"Close successful\")\n\t}\n\n\t// Test the qualified interface embedding\n\tqualifiedMock := subpkg.NewMockFile(\"qualified.txt\")\n\tqf := &qualifiedFile{\n\t\tFile:     qualifiedMock,\n\t\tmetadata: \"test metadata\",\n\t}\n\n\tprintln(\"Qualified file name:\", qf.Name())\n\n\terr = qf.Close()\n\tif err != nil {\n\t\tprintln(\"Qualified close error:\", err.Error())\n\t} else {\n\t\tprintln(\"Qualified close successful\")\n\t}\n\n\t// Test qualified write\n\tqn, err := qf.Write([]byte(\"qualified data\"))\n\tif err != nil {\n\t\tprintln(\"Qualified write error:\", err.Error())\n\t} else {\n\t\tprintln(\"Qualified wrote bytes:\", qn)\n\t}\n}\n",
    "tsCode": "// Generated file based on interface_embedding.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as io from \"@goscript/io/index.js\"\n\nimport * as subpkg from \"@goscript/github.com/aperturerobotics/goscript/tests/tests/interface_embedding/subpkg/index.js\"\n\nexport type File = null | {\n\t// Lock locks the file like e.g. flock. It protects against access from\n\t// other processes.\n\tLock(): $.GoError\n\t// Name returns the name of the file as presented to Open.\n\tName(): string\n\t// Truncate the file.\n\tTruncate(size: number): $.GoError\n\t// Unlock unlocks the file.\n\tUnlock(): $.GoError\n} & io.Writer & io.Reader & io.ReaderAt & io.Seeker & io.Closer\n\n$.registerInterfaceType(\n  'main.File',\n  null, // Zero value for interface is null\n  [{ name: \"Lock\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Truncate\", args: [{ name: \"size\", type: { kind: $.TypeKind.Basic, name: \"int64\" } }], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Unlock\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class MockFile {\n\tpublic get filename(): string {\n\t\treturn this._fields.filename.value\n\t}\n\tpublic set filename(value: string) {\n\t\tthis._fields.filename.value = value\n\t}\n\n\tpublic get content(): $.Bytes {\n\t\treturn this._fields.content.value\n\t}\n\tpublic set content(value: $.Bytes) {\n\t\tthis._fields.content.value = value\n\t}\n\n\tpublic get position(): number {\n\t\treturn this._fields.position.value\n\t}\n\tpublic set position(value: number) {\n\t\tthis._fields.position.value = value\n\t}\n\n\tpublic _fields: {\n\t\tfilename: $.VarRef<string>;\n\t\tcontent: $.VarRef<$.Bytes>;\n\t\tposition: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{content?: $.Bytes, filename?: string, position?: number}>) {\n\t\tthis._fields = {\n\t\t\tfilename: $.varRef(init?.filename ?? \"\"),\n\t\t\tcontent: $.varRef(init?.content ?? new Uint8Array(0)),\n\t\t\tposition: $.varRef(init?.position ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MockFile {\n\t\tconst cloned = new MockFile()\n\t\tcloned._fields = {\n\t\t\tfilename: $.varRef(this._fields.filename.value),\n\t\t\tcontent: $.varRef(this._fields.content.value),\n\t\t\tposition: $.varRef(this._fields.position.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Name(): string {\n\t\tconst m = this\n\t\treturn m.filename\n\t}\n\n\tpublic Write(p: $.Bytes): [number, $.GoError] {\n\t\tconst m = this\n\t\tm.content = $.append(m.content, ...(p || []))\n\t\treturn [$.len(p), null]\n\t}\n\n\tpublic Read(p: $.Bytes): [number, $.GoError] {\n\t\tconst m = this\n\t\tlet remaining = $.len(m.content) - $.int(m.position)\n\t\tif (remaining <= 0) {\n\t\t\treturn [0, io.EOF]\n\t\t}\n\t\tlet n = $.copy(p, $.goSlice(m.content, m.position, undefined))\n\t\tm.position += (n as number)\n\t\treturn [n, null]\n\t}\n\n\tpublic ReadAt(p: $.Bytes, off: number): [number, $.GoError] {\n\t\tconst m = this\n\t\tif (off >= ($.len(m.content) as number)) {\n\t\t\treturn [0, io.EOF]\n\t\t}\n\t\tlet n = $.copy(p, $.goSlice(m.content, off, undefined))\n\t\treturn [n, null]\n\t}\n\n\tpublic Seek(offset: number, whence: number): [number, $.GoError] {\n\t\tconst m = this\n\t\tswitch (whence) {\n\t\t\tcase 0: {\n\t\t\t\tm.position = offset\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\tm.position += offset\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tm.position = ($.len(m.content) as number) + offset\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn [m.position, null]\n\t}\n\n\tpublic Close(): $.GoError {\n\t\treturn null\n\t}\n\n\tpublic Lock(): $.GoError {\n\t\treturn null\n\t}\n\n\tpublic Unlock(): $.GoError {\n\t\treturn null\n\t}\n\n\tpublic Truncate(size: number): $.GoError {\n\t\tconst m = this\n\t\tif (size < ($.len(m.content) as number)) {\n\t\t\tm.content = $.goSlice(m.content, undefined, size)\n\t\t}\n\t\treturn null\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MockFile',\n\t  new MockFile(),\n\t  [{ name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Write\", args: [{ name: \"p\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Read\", args: [{ name: \"p\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"ReadAt\", args: [{ name: \"p\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }, { name: \"off\", type: { kind: $.TypeKind.Basic, name: \"int64\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Seek\", args: [{ name: \"offset\", type: { kind: $.TypeKind.Basic, name: \"int64\" } }, { name: \"whence\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Close\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Lock\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Unlock\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Truncate\", args: [{ name: \"size\", type: { kind: $.TypeKind.Basic, name: \"int64\" } }], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  MockFile,\n\t  {\"filename\": { kind: $.TypeKind.Basic, name: \"string\" }, \"content\": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } }, \"position\": { kind: $.TypeKind.Basic, name: \"int64\" }}\n\t);\n}\n\nexport class qualifiedFile {\n\tpublic get metadata(): string {\n\t\treturn this._fields.metadata.value\n\t}\n\tpublic set metadata(value: string) {\n\t\tthis._fields.metadata.value = value\n\t}\n\n\tpublic get File(): subpkg.File {\n\t\treturn this._fields.File.value\n\t}\n\tpublic set File(value: subpkg.File) {\n\t\tthis._fields.File.value = value\n\t}\n\n\tpublic _fields: {\n\t\tFile: $.VarRef<subpkg.File>;\n\t\tmetadata: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{File?: subpkg.File, metadata?: string}>) {\n\t\tthis._fields = {\n\t\t\tFile: $.varRef(init?.File ?? null),\n\t\t\tmetadata: $.varRef(init?.metadata ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): qualifiedFile {\n\t\tconst cloned = new qualifiedFile()\n\t\tcloned._fields = {\n\t\t\tFile: $.varRef(this._fields.File.value),\n\t\t\tmetadata: $.varRef(this._fields.metadata.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Close(): $.GoError {\n\t\treturn this.File!.Close()\n\t}\n\n\tpublic Name(): string {\n\t\treturn this.File!.Name()\n\t}\n\n\tpublic Write(data: $.Bytes): [number, $.GoError] {\n\t\treturn this.File!.Write(data)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.qualifiedFile',\n\t  new qualifiedFile(),\n\t  [],\n\t  qualifiedFile,\n\t  {\"File\": \"File\", \"metadata\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport class file {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic get File(): File {\n\t\treturn this._fields.File.value\n\t}\n\tpublic set File(value: File) {\n\t\tthis._fields.File.value = value\n\t}\n\n\tpublic _fields: {\n\t\tFile: $.VarRef<File>;\n\t\tname: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{File?: File, name?: string}>) {\n\t\tthis._fields = {\n\t\t\tFile: $.varRef(init?.File ?? null),\n\t\t\tname: $.varRef(init?.name ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): file {\n\t\tconst cloned = new file()\n\t\tcloned._fields = {\n\t\t\tFile: $.varRef(this._fields.File.value),\n\t\t\tname: $.varRef(this._fields.name.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Name(): string {\n\t\tconst f = this\n\t\treturn f.name\n\t}\n\n\tpublic Close(): $.GoError {\n\t\treturn this.File!.Close()\n\t}\n\n\tpublic Lock(): $.GoError {\n\t\treturn this.File!.Lock()\n\t}\n\n\tpublic Read(p: $.Bytes): [number, $.GoError] {\n\t\treturn this.File!.Read(p)\n\t}\n\n\tpublic ReadAt(p: $.Bytes, off: number): [number, $.GoError] {\n\t\treturn this.File!.ReadAt(p, off)\n\t}\n\n\tpublic Seek(offset: number, whence: number): [number, $.GoError] {\n\t\treturn this.File!.Seek(offset, whence)\n\t}\n\n\tpublic Truncate(size: number): $.GoError {\n\t\treturn this.File!.Truncate(size)\n\t}\n\n\tpublic Unlock(): $.GoError {\n\t\treturn this.File!.Unlock()\n\t}\n\n\tpublic Write(p: $.Bytes): [number, $.GoError] {\n\t\treturn this.File!.Write(p)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.file',\n\t  new file(),\n\t  [{ name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  file,\n\t  {\"File\": \"File\", \"name\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Create a mock file implementation\n\tlet mockFile = new MockFile({content: $.stringToBytes(\"Hello, World!\"), filename: \"test.txt\", position: 0})\n\n\t// Create our embedded file struct\n\tlet f = new file({name: \"custom_name.txt\", File: mockFile})\n\n\t// Test accessing the custom Name() method\n\t$.println(\"Custom name:\", f!.Name())\n\n\t// Test accessing embedded interface methods - these should have null assertions\n\t$.println(\"File name:\", f!.File!.Name())\n\n\t// Test other embedded methods\n\tlet err = f!.Lock()\n\tif (err != null) {\n\t\t$.println(\"Lock error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Lock successful\")\n\t}\n\n\terr = f!.Unlock()\n\tif (err != null) {\n\t\t$.println(\"Unlock error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Unlock successful\")\n\t}\n\n\t// Test Write\n\tlet data = $.stringToBytes(\"test data\")\n\tlet n: number\n\t[n, err] = f!.Write(data)\n\tif (err != null) {\n\t\t$.println(\"Write error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Wrote bytes:\", n)\n\t}\n\n\t// Test Read\n\tlet buf = new Uint8Array(5)\n\t;[n, err] = f!.Read(buf)\n\tif (err != null) {\n\t\t$.println(\"Read error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Read bytes:\", n)\n\t}\n\n\t// Test ReadAt\n\tlet buf2 = new Uint8Array(5)\n\t;[n, err] = f!.ReadAt(buf2, 0)\n\tif (err != null) {\n\t\t$.println(\"ReadAt error:\", err!.Error())\n\t} else {\n\t\t$.println(\"ReadAt bytes:\", n)\n\t}\n\n\t// Test Seek\n\tlet pos: number\n\t[pos, err] = f!.Seek(0, 0)\n\tif (err != null) {\n\t\t$.println(\"Seek error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Seek position:\", pos)\n\t}\n\n\t// Test Truncate\n\terr = f!.Truncate(5)\n\tif (err != null) {\n\t\t$.println(\"Truncate error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Truncate successful\")\n\t}\n\n\t// Test Close\n\terr = f!.Close()\n\tif (err != null) {\n\t\t$.println(\"Close error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Close successful\")\n\t}\n\n\t// Test the qualified interface embedding\n\tlet qualifiedMock = subpkg.NewMockFile(\"qualified.txt\")\n\tlet qf = new qualifiedFile({metadata: \"test metadata\", File: qualifiedMock})\n\n\t$.println(\"Qualified file name:\", qf!.Name())\n\n\terr = qf!.Close()\n\tif (err != null) {\n\t\t$.println(\"Qualified close error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Qualified close successful\")\n\t}\n\n\t// Test qualified write\n\tlet qn: number\n\t[qn, err] = qf!.Write($.stringToBytes(\"qualified data\"))\n\tif (err != null) {\n\t\t$.println(\"Qualified write error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Qualified wrote bytes:\", qn)\n\t}\n}\n\n",
    "expectedOutput": "Custom name: custom_name.txt\nFile name: test.txt\nLock successful\nUnlock successful\nWrote bytes: 9\nRead bytes: 5\nReadAt bytes: 5\nSeek position: 0\nTruncate successful\nClose successful\nQualified file name: qualified.txt\nQualified close successful\nQualified wrote bytes: 14\n"
  },
  {
    "name": "interface_method_comments",
    "goCode": "package main\n\ntype MyInterface interface {\n\t// MyMethod is a method with a comment\n\tMyMethod()\n}\n\nfunc main() {\n\t// This test verifies that comments on interface methods are preserved.\n\tprintln(\"Test started\")\n\t// No actual execution needed, just compilation check.\n\tprintln(\"Test finished\")\n}\n",
    "tsCode": "// Generated file based on interface_method_comments.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyInterface = null | {\n\t// MyMethod is a method with a comment\n\tMyMethod(): void\n}\n\n$.registerInterfaceType(\n  'main.MyInterface',\n  null, // Zero value for interface is null\n  [{ name: \"MyMethod\", args: [], returns: [] }]\n);\n\nexport async function main(): Promise<void> {\n\t// This test verifies that comments on interface methods are preserved.\n\t$.println(\"Test started\")\n\t// No actual execution needed, just compilation check.\n\t$.println(\"Test finished\")\n}\n\n",
    "expectedOutput": "Test started\nTest finished"
  },
  {
    "name": "interface_multi_param_return",
    "goCode": "package main\n\ntype MultiParamReturner interface {\n\tProcess(data []byte, count int, _ string) (bool, error)\n}\n\ntype MyProcessor struct{}\n\nfunc (p MyProcessor) Process(data []byte, count int, _ string) (bool, error) {\n\t// Dummy implementation\n\tif count > 0 && len(data) > 0 {\n\t\tprintln(\"Processing successful\")\n\t\treturn true, nil // Use nil for error type\n\t}\n\tprintln(\"Processing failed\")\n\treturn false, nil // Use nil for error type\n}\n\nfunc main() {\n\tvar processor MultiParamReturner = MyProcessor{}\n\n\tdata := []byte{1, 2, 3}\n\tsuccess, _ := processor.Process(data, 5, \"unused\")\n\n\tif success {\n\t\tprintln(\"Main: Success reported\")\n\t} else {\n\t\tprintln(\"Main: Failure reported\")\n\t}\n\n\t// test case: re-use success variable, ignore second variable\n\tsuccess, _ = processor.Process(data, 5, \"unused\")\n\tif success {\n\t\tprintln(\"Main: Success reported\")\n\t} else {\n\t\tprintln(\"Main: Failure reported\")\n\t}\n}\n",
    "tsCode": "// Generated file based on interface_multi_param_return.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MultiParamReturner = null | {\n\tProcess(data: $.Bytes, count: number, _p2: string): [boolean, $.GoError]\n}\n\n$.registerInterfaceType(\n  'main.MultiParamReturner',\n  null, // Zero value for interface is null\n  [{ name: \"Process\", args: [{ name: \"data\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }, { name: \"count\", type: { kind: $.TypeKind.Basic, name: \"int\" } }, { name: \"_\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class MyProcessor {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MyProcessor {\n\t\tconst cloned = new MyProcessor()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Process(data: $.Bytes, count: number, _: string): [boolean, $.GoError] {\n\t\tif (count > 0 && $.len(data) > 0) {\n\t\t\t$.println(\"Processing successful\")\n\t\t\treturn [true, null]\n\t\t}\n\t\t$.println(\"Processing failed\")\n\t\treturn [false, null]\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyProcessor',\n\t  new MyProcessor(),\n\t  [{ name: \"Process\", args: [{ name: \"data\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }, { name: \"count\", type: { kind: $.TypeKind.Basic, name: \"int\" } }, { name: \"_\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  MyProcessor,\n\t  {}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet processor: MultiParamReturner = $.markAsStructValue(new MyProcessor({}))\n\n\tlet data = new Uint8Array([1, 2, 3])\n\tlet [success, ] = processor!.Process(data, 5, \"unused\")\n\n\tif (success) {\n\t\t$.println(\"Main: Success reported\")\n\t} else {\n\t\t$.println(\"Main: Failure reported\")\n\t}\n\n\t// test case: re-use success variable, ignore second variable\n\t;[success] = processor!.Process(data, 5, \"unused\")\n\tif (success) {\n\t\t$.println(\"Main: Success reported\")\n\t} else {\n\t\t$.println(\"Main: Failure reported\")\n\t}\n}\n\n",
    "expectedOutput": "Processing successful\nMain: Success reported\nProcessing successful\nMain: Success reported"
  },
  {
    "name": "interface_pointer_assignment",
    "goCode": "package main\n\ntype MyStruct struct {\n\tValue int\n}\n\nfunc main() {\n\t// Scenario 1: Composite literal pointers (should work correctly)\n\tvar i1 interface{} = &MyStruct{Value: 10}\n\t_, ok1 := i1.(*MyStruct)\n\tprintln(\"Scenario 1 - Composite literal pointer assertion:\", ok1)\n\n\t// Scenario 2: Variable aliasing (fixed by our change)\n\toriginal := MyStruct{Value: 30}\n\tpAlias := &original\n\tvar i2 interface{} = pAlias\n\t_, ok2 := i2.(*MyStruct)\n\tprintln(\"Scenario 2 - Variable pointer assertion:\", ok2)\n\n\t// Scenario 3: Multiple pointer variables\n\ts1 := MyStruct{Value: 40}\n\ts2 := MyStruct{Value: 50}\n\tp1 := &s1\n\tp2 := &s2\n\tvar i3a interface{} = p1\n\tvar i3b interface{} = p2\n\t_, ok3a := i3a.(*MyStruct)\n\t_, ok3b := i3b.(*MyStruct)\n\tprintln(\"Scenario 3a - Multiple pointer 1 assertion:\", ok3a)\n\tprintln(\"Scenario 3b - Multiple pointer 2 assertion:\", ok3b)\n\n\t// Scenario 4: Mixed patterns\n\ts4 := MyStruct{Value: 60}\n\tp4 := &s4\n\tvar i4a interface{} = &MyStruct{Value: 70} // composite literal pointer\n\tvar i4b interface{} = p4                   // variable pointer\n\t_, ok4a := i4a.(*MyStruct)\n\t_, ok4b := i4b.(*MyStruct)\n\tprintln(\"Scenario 4a - Mixed composite literal assertion:\", ok4a)\n\tprintln(\"Scenario 4b - Mixed variable pointer assertion:\", ok4b)\n\n\t// Scenario 5: Nested pointer assignment\n\ts5 := MyStruct{Value: 80}\n\tp5a := &s5\n\tp5b := p5a // p5b points to same varref as p5a\n\tvar i5 interface{} = p5b\n\t_, ok5 := i5.(*MyStruct)\n\tprintln(\"Scenario 5 - Nested pointer assignment assertion:\", ok5)\n\n\t// Scenario 6: Struct value vs pointer distinction\n\ts6 := MyStruct{Value: 90}\n\tp6 := &s6\n\ts6copy := s6                 // struct value copy\n\tvar i6a interface{} = s6copy // struct value (should fail pointer assertion)\n\tvar i6b interface{} = p6     // struct pointer (should succeed)\n\t_, ok6a := i6a.(*MyStruct)   // should be false\n\t_, ok6b := i6b.(*MyStruct)   // should be true\n\t_, ok6c := i6a.(MyStruct)    // should be true\n\tprintln(\"Scenario 6a - Struct value to pointer assertion (should be false):\", ok6a)\n\tprintln(\"Scenario 6b - Struct pointer to pointer assertion (should be true):\", ok6b)\n\tprintln(\"Scenario 6c - Struct value to value assertion (should be true):\", ok6c)\n}\n",
    "tsCode": "// Generated file based on interface_pointer_assignment.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Scenario 1: Composite literal pointers (should work correctly)\n\tlet i1: null | any = new MyStruct({Value: 10})\n\tlet { ok: ok1 } = $.typeAssert<MyStruct | null>(i1, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"Scenario 1 - Composite literal pointer assertion:\", ok1)\n\n\t// Scenario 2: Variable aliasing (fixed by our change)\n\tlet original = $.varRef($.markAsStructValue(new MyStruct({Value: 30})))\n\tlet pAlias = original\n\tlet i2: null | any = pAlias\n\tlet { ok: ok2 } = $.typeAssert<MyStruct | null>(i2, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"Scenario 2 - Variable pointer assertion:\", ok2)\n\n\t// Scenario 3: Multiple pointer variables\n\tlet s1 = $.varRef($.markAsStructValue(new MyStruct({Value: 40})))\n\tlet s2 = $.varRef($.markAsStructValue(new MyStruct({Value: 50})))\n\tlet p1 = s1\n\tlet p2 = s2\n\tlet i3a: null | any = p1\n\tlet i3b: null | any = p2\n\tlet { ok: ok3a } = $.typeAssert<MyStruct | null>(i3a, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\tlet { ok: ok3b } = $.typeAssert<MyStruct | null>(i3b, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"Scenario 3a - Multiple pointer 1 assertion:\", ok3a)\n\t$.println(\"Scenario 3b - Multiple pointer 2 assertion:\", ok3b)\n\n\t// Scenario 4: Mixed patterns\n\tlet s4 = $.varRef($.markAsStructValue(new MyStruct({Value: 60})))\n\tlet p4 = s4\n\t// composite literal pointer\n\tlet i4a: null | any = new MyStruct({Value: 70})\n\t// variable pointer\n\tlet i4b: null | any = p4\n\tlet { ok: ok4a } = $.typeAssert<MyStruct | null>(i4a, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\tlet { ok: ok4b } = $.typeAssert<MyStruct | null>(i4b, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"Scenario 4a - Mixed composite literal assertion:\", ok4a)\n\t$.println(\"Scenario 4b - Mixed variable pointer assertion:\", ok4b)\n\n\t// Scenario 5: Nested pointer assignment\n\tlet s5 = $.varRef($.markAsStructValue(new MyStruct({Value: 80})))\n\tlet p5a = s5\n\tlet p5b = p5a // p5b points to same varref as p5a\n\tlet i5: null | any = p5b\n\tlet { ok: ok5 } = $.typeAssert<MyStruct | null>(i5, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"Scenario 5 - Nested pointer assignment assertion:\", ok5)\n\n\t// Scenario 6: Struct value vs pointer distinction\n\tlet s6 = $.varRef($.markAsStructValue(new MyStruct({Value: 90})))\n\tlet p6 = s6\n\tlet s6copy = $.markAsStructValue(s6!.value.clone()) // struct value copy\n\t// struct value (should fail pointer assertion)\n\tlet i6a: null | any = $.markAsStructValue(s6copy.clone())\n\t// struct pointer (should succeed)\n\tlet i6b: null | any = p6\n\tlet { ok: ok6a } = $.typeAssert<MyStruct | null>(i6a, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\tlet { ok: ok6b } = $.typeAssert<MyStruct | null>(i6b, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\tlet { ok: ok6c } = $.typeAssert<MyStruct>(i6a, 'main.MyStruct')\n\t$.println(\"Scenario 6a - Struct value to pointer assertion (should be false):\", ok6a)\n\t$.println(\"Scenario 6b - Struct pointer to pointer assertion (should be true):\", ok6b)\n\t$.println(\"Scenario 6c - Struct value to value assertion (should be true):\", ok6c)\n}\n\n",
    "expectedOutput": "Scenario 1 - Composite literal pointer assertion: true\nScenario 2 - Variable pointer assertion: true\nScenario 3a - Multiple pointer 1 assertion: true\nScenario 3b - Multiple pointer 2 assertion: true\nScenario 4a - Mixed composite literal assertion: true\nScenario 4b - Mixed variable pointer assertion: true\nScenario 5 - Nested pointer assignment assertion: true\nScenario 6a - Struct value to pointer assertion (should be false): false\nScenario 6b - Struct pointer to pointer assertion (should be true): true\nScenario 6c - Struct value to value assertion (should be true): true\n"
  },
  {
    "name": "interface_subset_cast",
    "goCode": "package main\n\ntype MyInterface1 interface {\n\tMyString1() string\n\tMyString2() string\n}\n\ntype MyInterface2 interface {\n\tMyString1() string\n}\n\ntype MyStruct struct {\n\tValue1 string\n\tValue2 string\n}\n\nfunc (m MyStruct) MyString1() string {\n\treturn m.Value1\n}\n\nfunc (m MyStruct) MyString2() string {\n\treturn m.Value2\n}\n\nfunc main() {\n\ts := MyStruct{Value1: \"hello\", Value2: \"world\"}\n\tvar i1 MyInterface1 = s\n\n\t// Cast from larger interface to smaller interface (subset)\n\tvar i2 MyInterface2 = i1\n\n\tprintln(\"i1.MyString1():\", i1.MyString1())\n\tprintln(\"i1.MyString2():\", i1.MyString2())\n\tprintln(\"i2.MyString1():\", i2.MyString1())\n\n\t// Type assertion from larger to smaller interface\n\ti3, ok := i1.(MyInterface2)\n\tif ok {\n\t\tprintln(\"Type assertion successful\")\n\t\tprintln(\"i3.MyString1():\", i3.MyString1())\n\t} else {\n\t\tprintln(\"Type assertion failed\")\n\t}\n}\n",
    "tsCode": "// Generated file based on interface_subset_cast.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyInterface1 = null | {\n\tMyString1(): string\n\tMyString2(): string\n}\n\n$.registerInterfaceType(\n  'main.MyInterface1',\n  null, // Zero value for interface is null\n  [{ name: \"MyString1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"MyString2\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport type MyInterface2 = null | {\n\tMyString1(): string\n}\n\n$.registerInterfaceType(\n  'main.MyInterface2',\n  null, // Zero value for interface is null\n  [{ name: \"MyString1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport class MyStruct {\n\tpublic get Value1(): string {\n\t\treturn this._fields.Value1.value\n\t}\n\tpublic set Value1(value: string) {\n\t\tthis._fields.Value1.value = value\n\t}\n\n\tpublic get Value2(): string {\n\t\treturn this._fields.Value2.value\n\t}\n\tpublic set Value2(value: string) {\n\t\tthis._fields.Value2.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue1: $.VarRef<string>;\n\t\tValue2: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{Value1?: string, Value2?: string}>) {\n\t\tthis._fields = {\n\t\t\tValue1: $.varRef(init?.Value1 ?? \"\"),\n\t\t\tValue2: $.varRef(init?.Value2 ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue1: $.varRef(this._fields.Value1.value),\n\t\t\tValue2: $.varRef(this._fields.Value2.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic MyString1(): string {\n\t\tconst m = this\n\t\treturn m.Value1\n\t}\n\n\tpublic MyString2(): string {\n\t\tconst m = this\n\t\treturn m.Value2\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"MyString1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"MyString2\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  MyStruct,\n\t  {\"Value1\": { kind: $.TypeKind.Basic, name: \"string\" }, \"Value2\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet s = $.markAsStructValue(new MyStruct({Value1: \"hello\", Value2: \"world\"}))\n\tlet i1: MyInterface1 = $.markAsStructValue(s.clone())\n\n\t// Cast from larger interface to smaller interface (subset)\n\tlet i2: MyInterface2 = i1\n\n\t$.println(\"i1.MyString1():\", i1!.MyString1())\n\t$.println(\"i1.MyString2():\", i1!.MyString2())\n\t$.println(\"i2.MyString1():\", i2!.MyString1())\n\n\t// Type assertion from larger to smaller interface\n\tlet { value: i3, ok: ok } = $.typeAssert<MyInterface2>(i1, 'main.MyInterface2')\n\tif (ok) {\n\t\t$.println(\"Type assertion successful\")\n\t\t$.println(\"i3.MyString1():\", i3!.MyString1())\n\t} else {\n\t\t$.println(\"Type assertion failed\")\n\t}\n}\n\n",
    "expectedOutput": "i1.MyString1(): hello\ni1.MyString2(): world\ni2.MyString1(): hello\nType assertion successful\ni3.MyString1(): hello\n"
  },
  {
    "name": "interface_subset_type_switch",
    "goCode": "package main\n\ntype MyInterface1 interface {\n\tMyString1() string\n\tMyString2() string\n}\n\ntype MyInterface2 interface {\n\tMyString1() string\n}\n\ntype MyStruct struct {\n\tValue1 string\n\tValue2 string\n}\n\nfunc (m MyStruct) MyString1() string {\n\treturn m.Value1\n}\n\nfunc (m MyStruct) MyString2() string {\n\treturn m.Value2\n}\n\nfunc processInterface(i any) {\n\tswitch v := i.(type) {\n\tcase MyInterface1:\n\t\tprintln(\"MyInterface1:\", v.MyString1(), v.MyString2())\n\tcase MyInterface2:\n\t\tprintln(\"MyInterface2:\", v.MyString1())\n\tdefault:\n\t\tprintln(\"Unknown type\")\n\t}\n}\n\nfunc main() {\n\ts := MyStruct{Value1: \"hello\", Value2: \"world\"}\n\n\t// Test with MyInterface1\n\tvar i1 MyInterface1 = s\n\tprocessInterface(i1)\n\n\t// Test with MyInterface2\n\tvar i2 MyInterface2 = s\n\tprocessInterface(i2)\n\n\t// Test with concrete type\n\tprocessInterface(s)\n\n\t// Type switch with subset casting\n\tvar i3 any = i1\n\tswitch v := i3.(type) {\n\tcase MyInterface2:\n\t\tprintln(\"Matched MyInterface2 from i1:\", v.MyString1())\n\tcase MyInterface1:\n\t\tprintln(\"Matched MyInterface1 from i1:\", v.MyString1(), v.MyString2())\n\tdefault:\n\t\tprintln(\"No match\")\n\t}\n}\n",
    "tsCode": "// Generated file based on interface_subset_type_switch.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyInterface1 = null | {\n\tMyString1(): string\n\tMyString2(): string\n}\n\n$.registerInterfaceType(\n  'main.MyInterface1',\n  null, // Zero value for interface is null\n  [{ name: \"MyString1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"MyString2\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport type MyInterface2 = null | {\n\tMyString1(): string\n}\n\n$.registerInterfaceType(\n  'main.MyInterface2',\n  null, // Zero value for interface is null\n  [{ name: \"MyString1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport class MyStruct {\n\tpublic get Value1(): string {\n\t\treturn this._fields.Value1.value\n\t}\n\tpublic set Value1(value: string) {\n\t\tthis._fields.Value1.value = value\n\t}\n\n\tpublic get Value2(): string {\n\t\treturn this._fields.Value2.value\n\t}\n\tpublic set Value2(value: string) {\n\t\tthis._fields.Value2.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue1: $.VarRef<string>;\n\t\tValue2: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{Value1?: string, Value2?: string}>) {\n\t\tthis._fields = {\n\t\t\tValue1: $.varRef(init?.Value1 ?? \"\"),\n\t\t\tValue2: $.varRef(init?.Value2 ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue1: $.varRef(this._fields.Value1.value),\n\t\t\tValue2: $.varRef(this._fields.Value2.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic MyString1(): string {\n\t\tconst m = this\n\t\treturn m.Value1\n\t}\n\n\tpublic MyString2(): string {\n\t\tconst m = this\n\t\treturn m.Value2\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"MyString1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"MyString2\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  MyStruct,\n\t  {\"Value1\": { kind: $.TypeKind.Basic, name: \"string\" }, \"Value2\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport function processInterface(i: null | any): void {\n\t$.typeSwitch(i, [{ types: ['main.MyInterface1'], body: (v) => {\n\t\t$.println(\"MyInterface1:\", v!.MyString1(), v!.MyString2())\n\t}},\n\t{ types: ['main.MyInterface2'], body: (v) => {\n\t\t$.println(\"MyInterface2:\", v!.MyString1())\n\t}}], () => {\n\t\t$.println(\"Unknown type\")\n\t})\n}\n\nexport async function main(): Promise<void> {\n\tlet s = $.markAsStructValue(new MyStruct({Value1: \"hello\", Value2: \"world\"}))\n\n\t// Test with MyInterface1\n\tlet i1: MyInterface1 = $.markAsStructValue(s.clone())\n\tprocessInterface(i1)\n\n\t// Test with MyInterface2\n\tlet i2: MyInterface2 = $.markAsStructValue(s.clone())\n\tprocessInterface(i2)\n\n\t// Test with concrete type\n\tprocessInterface(s)\n\n\t// Type switch with subset casting\n\tlet i3: null | any = i1\n\t$.typeSwitch(i3, [{ types: ['main.MyInterface2'], body: (v) => {\n\t\t$.println(\"Matched MyInterface2 from i1:\", v!.MyString1())\n\t}},\n\t{ types: ['main.MyInterface1'], body: (v) => {\n\t\t$.println(\"Matched MyInterface1 from i1:\", v!.MyString1(), v!.MyString2())\n\t}}], () => {\n\t\t$.println(\"No match\")\n\t})\n}\n\n",
    "expectedOutput": "MyInterface1: hello world\nMyInterface1: hello world\nMyInterface1: hello world\nMatched MyInterface2 from i1: hello\n"
  },
  {
    "name": "interface_to_interface_type_assertion",
    "goCode": "package main\n\ntype MyInterface interface {\n\tMethod1() int\n}\n\ntype MyStruct struct {\n\tValue int\n}\n\nfunc (m MyStruct) Method1() int {\n\treturn m.Value\n}\n\ntype MyOtherInterface interface {\n\tMethod1() int\n}\n\nfunc main() {\n\tvar i MyInterface\n\ts := MyStruct{Value: 10}\n\ti = s\n\n\t_, ok := i.(MyOtherInterface)\n\tif ok {\n\t\tprintln(\"Type assertion successful\")\n\t} else {\n\t\tprintln(\"Type assertion failed\")\n\t}\n}\n",
    "tsCode": "// Generated file based on interface_to_interface_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyInterface = null | {\n\tMethod1(): number\n}\n\n$.registerInterfaceType(\n  'main.MyInterface',\n  null, // Zero value for interface is null\n  [{ name: \"Method1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }]\n);\n\nexport type MyOtherInterface = null | {\n\tMethod1(): number\n}\n\n$.registerInterfaceType(\n  'main.MyOtherInterface',\n  null, // Zero value for interface is null\n  [{ name: \"Method1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }]\n);\n\nexport class MyStruct {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Method1(): number {\n\t\tconst m = this\n\t\treturn m.Value\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"Method1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  MyStruct,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet i: MyInterface = null\n\tlet s = $.markAsStructValue(new MyStruct({Value: 10}))\n\ti = $.markAsStructValue(s.clone())\n\n\tlet { ok: ok } = $.typeAssert<MyOtherInterface>(i, 'main.MyOtherInterface')\n\tif (ok) {\n\t\t$.println(\"Type assertion successful\")\n\t} else {\n\t\t$.println(\"Type assertion failed\")\n\t}\n}\n\n",
    "expectedOutput": "Type assertion successful"
  },
  {
    "name": "interface_type_assertion",
    "goCode": "package main\n\ntype MyInterface interface {\n\tMethod1() int\n}\n\n/* MyStruct is a sample struct */\ntype MyStruct struct {\n\tValue int\n}\n\nfunc (m MyStruct) Method1() int {\n\treturn m.Value\n}\n\nfunc main() {\n\tvar i MyInterface\n\ts := MyStruct{Value: 10}\n\ti = s\n\n\t_, ok := i.(MyStruct)\n\tif ok {\n\t\tprintln(\"Type assertion successful\")\n\t} else {\n\t\tprintln(\"Type assertion failed\")\n\t}\n\n\t// try a second time since this generates something different when using = and not :=\n\t_, ok = i.(*MyStruct)\n\tif ok {\n\t\tprintln(\"Type assertion successful\")\n\t} else {\n\t\t// expected\n\t\tprintln(\"Type assertion failed\")\n\t}\n\n\t// assign result to a variable\n\tval, ok2 := i.(MyStruct)\n\tif !ok2 {\n\t\tprintln(\"type assertion failed\")\n\t} else {\n\t\tprintln(\"type assertion success\", val.Value)\n\t}\n}\n",
    "tsCode": "// Generated file based on interface_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyInterface = null | {\n\tMethod1(): number\n}\n\n$.registerInterfaceType(\n  'main.MyInterface',\n  null, // Zero value for interface is null\n  [{ name: \"Method1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }]\n);\n\nexport class MyStruct {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Method1(): number {\n\t\tconst m = this\n\t\treturn m.Value\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"Method1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  MyStruct,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet i: MyInterface = null\n\tlet s = $.markAsStructValue(new MyStruct({Value: 10}))\n\ti = $.markAsStructValue(s.clone())\n\n\tlet { ok: ok } = $.typeAssert<MyStruct>(i, 'main.MyStruct')\n\tif (ok) {\n\t\t$.println(\"Type assertion successful\")\n\t} else {\n\t\t$.println(\"Type assertion failed\")\n\t}\n\n\t// try a second time since this generates something different when using = and not :=\n\t({ ok: ok } = $.typeAssert<MyStruct | null>(i, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'}))\n\n\t// expected\n\tif (ok) {\n\t\t$.println(\"Type assertion successful\")\n\t} else {\n\t\t// expected\n\t\t$.println(\"Type assertion failed\")\n\t}\n\n\t// assign result to a variable\n\tlet { value: val, ok: ok2 } = $.typeAssert<MyStruct>(i, 'main.MyStruct')\n\tif (!ok2) {\n\t\t$.println(\"type assertion failed\")\n\t} else {\n\t\t$.println(\"type assertion success\", val.Value)\n\t}\n}\n\n",
    "expectedOutput": "Type assertion successful\nType assertion failed\ntype assertion success 10"
  },
  {
    "name": "interface_type_reference",
    "goCode": "package main\n\nimport \"os\"\n\n// Basic abstract the basic operations in a storage-agnostic interface as\n// an extension to the Basic interface.\ntype Basic interface {\n\t// Stat returns a FileInfo describing the named file.\n\tStat(filename string) (os.FileInfo, error)\n}\n\ntype MyStorage struct{}\n\nfunc (s MyStorage) Stat(filename string) (os.FileInfo, error) {\n\treturn nil, nil\n}\n\nfunc main() {\n\tvar b Basic = MyStorage{}\n\t_, err := b.Stat(\"test.txt\")\n\tif err == nil {\n\t\tprintln(\"Stat call successful\")\n\t}\n}\n",
    "tsCode": "// Generated file based on interface_type_reference.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nexport type Basic = null | {\n\t// Stat returns a FileInfo describing the named file.\n\tStat(filename: string): [null | os.FileInfo, $.GoError]\n}\n\n$.registerInterfaceType(\n  'main.Basic',\n  null, // Zero value for interface is null\n  [{ name: \"Stat\", args: [{ name: \"filename\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Interface, methods: [{ name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"ModTime\", args: [], returns: [{ type: \"Time\" }] }, { name: \"Mode\", args: [], returns: [{ type: \"FileMode\" }] }, { name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }, { name: \"Sys\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }] } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class MyStorage {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MyStorage {\n\t\tconst cloned = new MyStorage()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Stat(filename: string): [null | os.FileInfo, $.GoError] {\n\t\treturn [null, null]\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStorage',\n\t  new MyStorage(),\n\t  [{ name: \"Stat\", args: [{ name: \"filename\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Interface, methods: [{ name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"ModTime\", args: [], returns: [{ type: \"Time\" }] }, { name: \"Mode\", args: [], returns: [{ type: \"FileMode\" }] }, { name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }, { name: \"Sys\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }] }] } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  MyStorage,\n\t  {}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet b: Basic = $.markAsStructValue(new MyStorage({}))\n\tlet [, err] = b!.Stat(\"test.txt\")\n\tif (err == null) {\n\t\t$.println(\"Stat call successful\")\n\t}\n}\n\n",
    "expectedOutput": "Stat call successful\n"
  },
  {
    "name": "iterator_simple",
    "goCode": "package main\n\nfunc simpleIterator(yield func(int) bool) {\n\tfor i := 0; i < 3; i++ {\n\t\tif !yield(i) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc keyValueIterator(yield func(int, string) bool) {\n\tvalues := []string{\"a\", \"b\", \"c\"}\n\tfor i, v := range values {\n\t\tif !yield(i, v) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tprintln(\"Testing single value iterator:\")\n\tfor v := range simpleIterator {\n\t\tprintln(\"value:\", v)\n\t}\n\n\tprintln(\"Testing key-value iterator:\")\n\tfor k, v := range keyValueIterator {\n\t\tprintln(\"key:\", k, \"value:\", v)\n\t}\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on iterator_simple.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function simpleIterator(_yield: ((p0: number) => boolean) | null): void {\n\tfor (let i = 0; i < 3; i++) {\n\t\tif (!_yield!(i)) {\n\t\t\treturn \n\t\t}\n\t}\n}\n\nexport function keyValueIterator(_yield: ((p0: number, p1: string) => boolean) | null): void {\n\tlet values = $.arrayToSlice<string>([\"a\", \"b\", \"c\"])\n\tfor (let i = 0; i < $.len(values); i++) {\n\t\tlet v = values![i]\n\t\t{\n\t\t\tif (!_yield!(i, v)) {\n\t\t\t\treturn \n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function main(): Promise<void> {\n\t$.println(\"Testing single value iterator:\")\n\t;(() => {\n\t\tlet shouldContinue = true\n\t\tsimpleIterator!((v) => {\n\t\t\t{\n\t\t\t\t$.println(\"value:\", v)\n\t\t\t}\n\t\t\treturn shouldContinue\n\t\t})\n\t})()\n\n\t$.println(\"Testing key-value iterator:\")\n\t;(() => {\n\t\tlet shouldContinue = true\n\t\tkeyValueIterator!((k, v) => {\n\t\t\t{\n\t\t\t\t$.println(\"key:\", k, \"value:\", v)\n\t\t\t}\n\t\t\treturn shouldContinue\n\t\t})\n\t})()\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Testing single value iterator:\nvalue: 0\nvalue: 1\nvalue: 2\nTesting key-value iterator:\nkey: 0 value: a\nkey: 1 value: b\nkey: 2 value: c\ntest finished\n"
  },
  {
    "name": "json_debug",
    "goCode": "package main\n\nimport (\n\t\"reflect\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\nfunc main() {\n\tp := Person{Name: \"Alice\", Age: 30, Active: true}\n\tt := reflect.TypeOf(p)\n\n\t// Simulate what typeFields does\n\tprintln(\"NumField:\", t.NumField())\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tsf := t.Field(i)\n\t\tprintln(\"Field\", i)\n\t\tprintln(\"  Name:\", sf.Name)\n\t\tprintln(\"  Anonymous:\", sf.Anonymous)\n\t\tprintln(\"  IsExported:\", sf.IsExported())\n\n\t\ttag := sf.Tag.Get(\"json\")\n\t\tprintln(\"  Tag.Get(json):\", tag)\n\n\t\tif tag == \"-\" {\n\t\t\tprintln(\"  Skipping (tag is -)\")\n\t\t\tcontinue\n\t\t}\n\n\t\t// Simple tag parsing (similar to parseTag)\n\t\tname := tag\n\t\tif idx := 0; idx < len(tag) {\n\t\t\tfor i := 0; i < len(tag); i++ {\n\t\t\t\tif tag[i] == ',' {\n\t\t\t\t\tname = tag[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(\"  Parsed name:\", name)\n\t}\n}\n",
    "tsCode": "// Generated file based on json_debug.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p = $.markAsStructValue(new Person({Active: true, Age: 30, Name: \"Alice\"}))\n\tlet t = reflect.TypeOf(p)\n\n\t// Simulate what typeFields does\n\t$.println(\"NumField:\", t!.NumField())\n\n\t// Simple tag parsing (similar to parseTag)\n\tfor (let i = 0; i < t!.NumField(); i++) {\n\t\tlet sf = $.markAsStructValue(t!.Field(i).clone())\n\t\t$.println(\"Field\", i)\n\t\t$.println(\"  Name:\", sf.Name)\n\t\t$.println(\"  Anonymous:\", sf.Anonymous)\n\t\t$.println(\"  IsExported:\", sf.IsExported())\n\n\t\tlet tag = reflect.StructTag_Get(sf.Tag, \"json\")\n\t\t$.println(\"  Tag.Get(json):\", tag)\n\n\t\tif (tag == \"-\") {\n\t\t\t$.println(\"  Skipping (tag is -)\")\n\t\t\tcontinue\n\t\t}\n\n\t\t// Simple tag parsing (similar to parseTag)\n\t\tlet name = tag\n\t\t{\n\t\t\tlet idx = 0\n\t\t\tif (idx < $.len(tag)) {\n\t\t\t\tfor (let i = 0; i < $.len(tag); i++) {\n\t\t\t\t\tif ($.indexString(tag, i) == 44) {\n\t\t\t\t\t\tname = $.sliceString(tag, undefined, i)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$.println(\"  Parsed name:\", name)\n\t}\n}\n\n",
    "expectedOutput": "NumField: 3\nField 0\n  Name: Name\n  Anonymous: false\n  IsExported: true\n  Tag.Get(json): name\n  Parsed name: name\nField 1\n  Name: Age\n  Anonymous: false\n  IsExported: true\n  Tag.Get(json): age\n  Parsed name: age\nField 2\n  Name: Active\n  Anonymous: false\n  IsExported: true\n  Tag.Get(json): active\n  Parsed name: active\n"
  },
  {
    "name": "json_encoder_debug",
    "goCode": "package main\n\nimport (\n\t\"reflect\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\n// Simplified version of what encoding/json typeFields does\nfunc main() {\n\tt := reflect.TypeOf(Person{})\n\tprintln(\"Type:\", t.Name(), \"Kind:\", t.Kind().String(), \"NumField:\", t.NumField())\n\n\t// Iterate over fields like typeFields does\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tsf := t.Field(i)\n\t\tprintln(\"Field\", i, \":\", sf.Name)\n\t\tprintln(\"  Anonymous:\", sf.Anonymous)\n\t\tprintln(\"  IsExported:\", sf.IsExported())\n\n\t\t// Get the json tag like typeFields does\n\t\ttag := sf.Tag.Get(\"json\")\n\t\tprintln(\"  Tag.Get(\\\"json\\\"):\", tag)\n\n\t\t// Skip if unexported non-embedded field\n\t\tif !sf.Anonymous && !sf.IsExported() {\n\t\t\tprintln(\"  -> Skipped (unexported)\")\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip if tag is \"-\"\n\t\tif tag == \"-\" {\n\t\t\tprintln(\"  -> Skipped (tag is -)\")\n\t\t\tcontinue\n\t\t}\n\n\t\t// Parse the tag to extract the name\n\t\tname := tag\n\t\tfor j := 0; j < len(tag); j++ {\n\t\t\tif tag[j] == ',' {\n\t\t\t\tname = tag[:j]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif name == \"\" {\n\t\t\tname = sf.Name\n\t\t}\n\t\tprintln(\"  -> Name after parsing:\", name)\n\t}\n}\n",
    "tsCode": "// Generated file based on json_encoder_debug.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\n// Simplified version of what encoding/json typeFields does\nexport async function main(): Promise<void> {\n\tlet t = reflect.TypeOf($.markAsStructValue(new Person({})))\n\t$.println(\"Type:\", t!.Name(), \"Kind:\", reflect.Kind_String(t!.Kind()), \"NumField:\", t!.NumField())\n\n\t// Iterate over fields like typeFields does\n\n\t// Get the json tag like typeFields does\n\n\t// Skip if unexported non-embedded field\n\n\t// Skip if tag is \"-\"\n\n\t// Parse the tag to extract the name\n\tfor (let i = 0; i < t!.NumField(); i++) {\n\t\tlet sf = $.markAsStructValue(t!.Field(i).clone())\n\t\t$.println(\"Field\", i, \":\", sf.Name)\n\t\t$.println(\"  Anonymous:\", sf.Anonymous)\n\t\t$.println(\"  IsExported:\", sf.IsExported())\n\n\t\t// Get the json tag like typeFields does\n\t\tlet tag = reflect.StructTag_Get(sf.Tag, \"json\")\n\t\t$.println(\"  Tag.Get(\\\"json\\\"):\", tag)\n\n\t\t// Skip if unexported non-embedded field\n\t\tif (!sf.Anonymous && !sf.IsExported()) {\n\t\t\t$.println(\"  -> Skipped (unexported)\")\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip if tag is \"-\"\n\t\tif (tag == \"-\") {\n\t\t\t$.println(\"  -> Skipped (tag is -)\")\n\t\t\tcontinue\n\t\t}\n\n\t\t// Parse the tag to extract the name\n\t\tlet name = tag\n\t\tfor (let j = 0; j < $.len(tag); j++) {\n\t\t\tif ($.indexString(tag, j) == 44) {\n\t\t\t\tname = $.sliceString(tag, undefined, j)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (name == \"\") {\n\t\t\tname = sf.Name\n\t\t}\n\t\t$.println(\"  -> Name after parsing:\", name)\n\t}\n}\n\n",
    "expectedOutput": "Type: Person Kind: struct NumField: 3\nField 0 : Name\n  Anonymous: false\n  IsExported: true\n  Tag.Get(\"json\"): name\n  -> Name after parsing: name\nField 1 : Age\n  Anonymous: false\n  IsExported: true\n  Tag.Get(\"json\"): age\n  -> Name after parsing: age\nField 2 : Active\n  Anonymous: false\n  IsExported: true\n  Tag.Get(\"json\"): active\n  -> Name after parsing: active\n"
  },
  {
    "name": "json_marshal_basic",
    "goCode": "package main\n\nimport (\n\t\"encoding/json\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\nfunc main() {\n\tp := Person{Name: \"Alice\", Age: 30, Active: true}\n\tb, err := json.Marshal(p)\n\tif err != nil {\n\t\tprintln(\"Marshal error:\", err.Error())\n\t} else {\n\t\tprintln(\"Marshal:\", string(b))\n\t}\n}\n",
    "tsCode": "// Generated file based on json_marshal_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as json from \"@goscript/encoding/json/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p = $.markAsStructValue(new Person({Active: true, Age: 30, Name: \"Alice\"}))\n\tlet [b, err] = await json.Marshal(p)\n\tif (err != null) {\n\t\t$.println(\"Marshal error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Marshal:\", $.bytesToString(b))\n\t}\n}\n\n",
    "expectedOutput": "Marshal: {\"name\":\"Alice\",\"age\":30,\"active\":true}\n"
  },
  {
    "name": "json_numfield",
    "goCode": "package main\n\nimport (\n\t\"reflect\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\nfunc main() {\n\tvar p Person\n\tt := reflect.TypeOf(p)\n\tprintln(\"TypeOf(Person{}):\")\n\tprintln(\"  Name:\", t.Name())\n\tprintln(\"  Kind:\", t.Kind().String())\n\tprintln(\"  NumField:\", t.NumField())\n\n\t// This is closer to what json encoder does\n\t// - it gets the type from ValueOf(v).Type()\n\tv := reflect.ValueOf(p)\n\tt2 := v.Type()\n\tprintln(\"ValueOf(Person{}).Type():\")\n\tprintln(\"  Name:\", t2.Name())\n\tprintln(\"  Kind:\", t2.Kind().String())\n\tprintln(\"  NumField:\", t2.NumField())\n}\n",
    "tsCode": "// Generated file based on json_numfield.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p: Person = new Person()\n\tlet t = reflect.TypeOf(p)\n\t$.println(\"TypeOf(Person{}):\")\n\t$.println(\"  Name:\", t!.Name())\n\t$.println(\"  Kind:\", reflect.Kind_String(t!.Kind()))\n\t$.println(\"  NumField:\", t!.NumField())\n\n\t// This is closer to what json encoder does\n\t// - it gets the type from ValueOf(v).Type()\n\tlet v = $.markAsStructValue(reflect.ValueOf(p).clone())\n\tlet t2 = v.Type()\n\t$.println(\"ValueOf(Person{}).Type():\")\n\t$.println(\"  Name:\", t2!.Name())\n\t$.println(\"  Kind:\", reflect.Kind_String(t2!.Kind()))\n\t$.println(\"  NumField:\", t2!.NumField())\n}\n\n",
    "expectedOutput": "TypeOf(Person{}):\n  Name: Person\n  Kind: struct\n  NumField: 3\nValueOf(Person{}).Type():\n  Name: Person\n  Kind: struct\n  NumField: 3\n"
  },
  {
    "name": "json_simple",
    "goCode": "package main\n\nimport (\n\t\"encoding/json\"\n)\n\ntype Simple struct {\n\tX int `json:\"x\"`\n}\n\nfunc main() {\n\ts := Simple{X: 42}\n\tb, err := json.Marshal(s)\n\tif err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t} else {\n\t\tprintln(\"Result:\", string(b))\n\t}\n}\n",
    "tsCode": "// Generated file based on json_simple.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as json from \"@goscript/encoding/json/index.js\"\n\nexport class Simple {\n\tpublic get X(): number {\n\t\treturn this._fields.X.value\n\t}\n\tpublic set X(value: number) {\n\t\tthis._fields.X.value = value\n\t}\n\n\tpublic _fields: {\n\t\tX: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{X?: number}>) {\n\t\tthis._fields = {\n\t\t\tX: $.varRef(init?.X ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Simple {\n\t\tconst cloned = new Simple()\n\t\tcloned._fields = {\n\t\t\tX: $.varRef(this._fields.X.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Simple',\n\t  new Simple(),\n\t  [],\n\t  Simple,\n\t  {\"X\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"x\\\"\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet s = $.markAsStructValue(new Simple({X: 42}))\n\tlet [b, err] = await json.Marshal(s)\n\tif (err != null) {\n\t\t$.println(\"Error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Result:\", $.bytesToString(b))\n\t}\n}\n\n",
    "expectedOutput": "Result: {\"x\":42}\n"
  },
  {
    "name": "json_typefields",
    "goCode": "package main\n\nimport (\n\t\"reflect\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\n// Simulate what encoding/json typeFields does\nfunc main() {\n\tt := reflect.TypeOf(Person{})\n\tprintln(\"Type:\", t.Name())\n\n\t// Simulate typeFields logic\n\ttype field struct {\n\t\tname string\n\t\ttag  bool\n\t}\n\n\tvar fields []field\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tsf := t.Field(i)\n\t\tprintln(\"Processing field\", i, \":\", sf.Name)\n\t\tprintln(\"  Anonymous:\", sf.Anonymous)\n\t\tprintln(\"  IsExported:\", sf.IsExported())\n\n\t\tif sf.Anonymous {\n\t\t\tprintln(\"  Skipping: Anonymous field\")\n\t\t\tcontinue\n\t\t}\n\t\tif !sf.IsExported() {\n\t\t\tprintln(\"  Skipping: Unexported non-embedded field\")\n\t\t\tcontinue\n\t\t}\n\n\t\ttag := sf.Tag.Get(\"json\")\n\t\tprintln(\"  Tag.Get(json):\", tag)\n\n\t\tif tag == \"-\" {\n\t\t\tprintln(\"  Skipping: Tag is -\")\n\t\t\tcontinue\n\t\t}\n\n\t\tname := tag\n\t\t// Parse tag to extract name before comma\n\t\tfor j := 0; j < len(tag); j++ {\n\t\t\tif tag[j] == ',' {\n\t\t\t\tname = tag[:j]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif name == \"\" {\n\t\t\tname = sf.Name\n\t\t}\n\t\tprintln(\"  Final name:\", name)\n\n\t\tfields = append(fields, field{name: name, tag: tag != \"\"})\n\t}\n\n\tprintln(\"=== Fields found ===\")\n\tfor i, f := range fields {\n\t\tprintln(\"Field\", i, \"name:\", f.name, \"tagged:\", f.tag)\n\t}\n}\n",
    "tsCode": "// Generated file based on json_typefields.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\n// Simulate what encoding/json typeFields does\nexport async function main(): Promise<void> {\n\tlet t = reflect.TypeOf($.markAsStructValue(new Person({})))\n\t$.println(\"Type:\", t!.Name())\n\n\t// Simulate typeFields logic\n\tclass field {\n\t\tpublic get name(): string {\n\t\t\treturn this._fields.name.value\n\t\t}\n\t\tpublic set name(value: string) {\n\t\t\tthis._fields.name.value = value\n\t\t}\n\n\t\tpublic get tag(): boolean {\n\t\t\treturn this._fields.tag.value\n\t\t}\n\t\tpublic set tag(value: boolean) {\n\t\t\tthis._fields.tag.value = value\n\t\t}\n\n\t\tpublic _fields: {\n\t\t\tname: $.VarRef<string>;\n\t\t\ttag: $.VarRef<boolean>;\n\t\t}\n\n\t\tconstructor(init?: Partial<{name?: string, tag?: boolean}>) {\n\t\t\tthis._fields = {\n\t\t\t\tname: $.varRef(init?.name ?? \"\"),\n\t\t\t\ttag: $.varRef(init?.tag ?? false)\n\t\t\t}\n\t\t}\n\n\t\tpublic clone(): field {\n\t\t\tconst cloned = new field()\n\t\t\tcloned._fields = {\n\t\t\t\tname: $.varRef(this._fields.name.value),\n\t\t\t\ttag: $.varRef(this._fields.tag.value)\n\t\t\t}\n\t\t\treturn cloned\n\t\t}\n\n\t\t// Register this type with the runtime type system\n\t\tstatic __typeInfo = $.registerStructType(\n\t\t  'main.field',\n\t\t  new field(),\n\t\t  [],\n\t\t  field,\n\t\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"tag\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t\t);\n\t}\n\n\tlet fields: $.Slice<field> = null\n\n\t// Parse tag to extract name before comma\n\tfor (let i = 0; i < t!.NumField(); i++) {\n\t\tlet sf = $.markAsStructValue(t!.Field(i).clone())\n\t\t$.println(\"Processing field\", i, \":\", sf.Name)\n\t\t$.println(\"  Anonymous:\", sf.Anonymous)\n\t\t$.println(\"  IsExported:\", sf.IsExported())\n\n\t\tif (sf.Anonymous) {\n\t\t\t$.println(\"  Skipping: Anonymous field\")\n\t\t\tcontinue\n\t\t}\n\t\tif (!sf.IsExported()) {\n\t\t\t$.println(\"  Skipping: Unexported non-embedded field\")\n\t\t\tcontinue\n\t\t}\n\n\t\tlet tag = reflect.StructTag_Get(sf.Tag, \"json\")\n\t\t$.println(\"  Tag.Get(json):\", tag)\n\n\t\tif (tag == \"-\") {\n\t\t\t$.println(\"  Skipping: Tag is -\")\n\t\t\tcontinue\n\t\t}\n\n\t\tlet name = tag\n\t\t// Parse tag to extract name before comma\n\t\tfor (let j = 0; j < $.len(tag); j++) {\n\t\t\tif ($.indexString(tag, j) == 44) {\n\t\t\t\tname = $.sliceString(tag, undefined, j)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (name == \"\") {\n\t\t\tname = sf.Name\n\t\t}\n\t\t$.println(\"  Final name:\", name)\n\n\t\tfields = $.append(fields, $.markAsStructValue(new field({name: name, tag: tag != \"\"})))\n\t}\n\n\t$.println(\"=== Fields found ===\")\n\tfor (let i = 0; i < $.len(fields); i++) {\n\t\tlet f = fields![i]\n\t\t{\n\t\t\t$.println(\"Field\", i, \"name:\", f.name, \"tagged:\", f.tag)\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Type: Person\nProcessing field 0 : Name\n  Anonymous: false\n  IsExported: true\n  Tag.Get(json): name\n  Final name: name\nProcessing field 1 : Age\n  Anonymous: false\n  IsExported: true\n  Tag.Get(json): age\n  Final name: age\nProcessing field 2 : Active\n  Anonymous: false\n  IsExported: true\n  Tag.Get(json): active\n  Final name: active\n=== Fields found ===\nField 0 name: name tagged: true\nField 1 name: age tagged: true\nField 2 name: active tagged: true\n"
  },
  {
    "name": "json_typefields_flow",
    "goCode": "package main\n\nimport (\n\t\"reflect\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\ntype field struct {\n\tname string\n\ttyp  reflect.Type\n}\n\nfunc main() {\n\tt := reflect.TypeOf(Person{})\n\n\t// Mimic the exact flow of typeFields\n\tnext := []field{{typ: t}}\n\tprintln(\"Initial next len:\", len(next))\n\tprintln(\"next[0].typ:\", next[0].typ.Name())\n\tprintln(\"next[0].typ.NumField():\", next[0].typ.NumField())\n\n\tfor len(next) > 0 {\n\t\tcurrent := next\n\t\tnext = nil\n\n\t\tprintln(\"Loop iteration, current len:\", len(current))\n\n\t\tfor _, f := range current {\n\t\t\tprintln(\"Processing field, typ:\", f.typ.Name())\n\t\t\tprintln(\"  NumField:\", f.typ.NumField())\n\n\t\t\tfor i := 0; i < f.typ.NumField(); i++ {\n\t\t\t\tsf := f.typ.Field(i)\n\t\t\t\tprintln(\"  Struct field\", i, \":\", sf.Name)\n\t\t\t\ttag := sf.Tag.Get(\"json\")\n\t\t\t\tprintln(\"    Tag:\", tag)\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "tsCode": "// Generated file based on json_typefields_flow.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\nexport class field {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic get typ(): null | reflect.Type {\n\t\treturn this._fields.typ.value\n\t}\n\tpublic set typ(value: null | reflect.Type) {\n\t\tthis._fields.typ.value = value\n\t}\n\n\tpublic _fields: {\n\t\tname: $.VarRef<string>;\n\t\ttyp: $.VarRef<null | reflect.Type>;\n\t}\n\n\tconstructor(init?: Partial<{name?: string, typ?: null | reflect.Type}>) {\n\t\tthis._fields = {\n\t\t\tname: $.varRef(init?.name ?? \"\"),\n\t\t\ttyp: $.varRef(init?.typ ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): field {\n\t\tconst cloned = new field()\n\t\tcloned._fields = {\n\t\t\tname: $.varRef(this._fields.name.value),\n\t\t\ttyp: $.varRef(this._fields.typ.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.field',\n\t  new field(),\n\t  [],\n\t  field,\n\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"typ\": \"Type\"}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet t = reflect.TypeOf($.markAsStructValue(new Person({})))\n\n\t// Mimic the exact flow of typeFields\n\tlet next = $.arrayToSlice<field>([$.markAsStructValue(new field({typ: t}))])\n\t$.println(\"Initial next len:\", $.len(next))\n\t$.println(\"next[0].typ:\", next![0].typ!.Name())\n\t$.println(\"next[0].typ.NumField():\", next![0].typ!.NumField())\n\n\tfor (; $.len(next) > 0; ) {\n\t\tlet current = next\n\t\tnext = null\n\n\t\t$.println(\"Loop iteration, current len:\", $.len(current))\n\n\t\tfor (let _i = 0; _i < $.len(current); _i++) {\n\t\t\tlet f = current![_i]\n\t\t\t{\n\t\t\t\t$.println(\"Processing field, typ:\", f.typ!.Name())\n\t\t\t\t$.println(\"  NumField:\", f.typ!.NumField())\n\n\t\t\t\tfor (let i = 0; i < f.typ!.NumField(); i++) {\n\t\t\t\t\tlet sf = $.markAsStructValue(f.typ!.Field(i).clone())\n\t\t\t\t\t$.println(\"  Struct field\", i, \":\", sf.Name)\n\t\t\t\t\tlet tag = reflect.StructTag_Get(sf.Tag, \"json\")\n\t\t\t\t\t$.println(\"    Tag:\", tag)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Initial next len: 1\nnext[0].typ: Person\nnext[0].typ.NumField(): 3\nLoop iteration, current len: 1\nProcessing field, typ: Person\n  NumField: 3\n  Struct field 0 : Name\n    Tag: name\n  Struct field 1 : Age\n    Tag: age\n  Struct field 2 : Active\n    Tag: active\n"
  },
  {
    "name": "json_value",
    "goCode": "package main\n\nimport (\n\t\"reflect\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\nfunc main() {\n\tp := Person{Name: \"Alice\", Age: 30, Active: true}\n\tv := reflect.ValueOf(p)\n\tt := v.Type()\n\n\tprintln(\"Type:\", t.Name())\n\tprintln(\"Kind:\", t.Kind().String())\n\tprintln(\"NumField:\", t.NumField())\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tsf := t.Field(i)\n\t\tfv := v.Field(i)\n\n\t\tprintln(\"Field\", i, \":\", sf.Name)\n\t\tprintln(\"  FieldValue Kind:\", fv.Kind().String())\n\t\tprintln(\"  FieldValue CanInterface:\", fv.CanInterface())\n\n\t\tswitch fv.Kind() {\n\t\tcase reflect.String:\n\t\t\tprintln(\"  Value:\", fv.String())\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\tprintln(\"  Value:\", fv.Int())\n\t\tcase reflect.Bool:\n\t\t\tprintln(\"  Value:\", fv.Bool())\n\t\t}\n\t}\n}\n",
    "tsCode": "// Generated file based on json_value.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p = $.markAsStructValue(new Person({Active: true, Age: 30, Name: \"Alice\"}))\n\tlet v = $.markAsStructValue(reflect.ValueOf(p).clone())\n\tlet t = v.Type()\n\n\t$.println(\"Type:\", t!.Name())\n\t$.println(\"Kind:\", reflect.Kind_String(t!.Kind()))\n\t$.println(\"NumField:\", t!.NumField())\n\n\tfor (let i = 0; i < t!.NumField(); i++) {\n\t\tlet sf = $.markAsStructValue(t!.Field(i).clone())\n\t\tlet fv = $.markAsStructValue(v.Field(i).clone())\n\n\t\t$.println(\"Field\", i, \":\", sf.Name)\n\t\t$.println(\"  FieldValue Kind:\", reflect.Kind_String(fv.Kind()))\n\t\t$.println(\"  FieldValue CanInterface:\", fv.CanInterface())\n\n\t\tswitch (fv.Kind()) {\n\t\t\tcase reflect.String: {\n\t\t\t\t$.println(\"  Value:\", fv.String())\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase reflect.Int:\n\t\t\tcase reflect.Int8:\n\t\t\tcase reflect.Int16:\n\t\t\tcase reflect.Int32:\n\t\t\tcase reflect.Int64: {\n\t\t\t\t$.println(\"  Value:\", fv.Int())\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase reflect.Bool: {\n\t\t\t\t$.println(\"  Value:\", fv.Bool())\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Type: Person\nKind: struct\nNumField: 3\nField 0 : Name\n  FieldValue Kind: string\n  FieldValue CanInterface: true\n  Value: Alice\nField 1 : Age\n  FieldValue Kind: int\n  FieldValue CanInterface: true\n  Value: 30\nField 2 : Active\n  FieldValue Kind: bool\n  FieldValue CanInterface: true\n  Value: true\n"
  },
  {
    "name": "keyed_array_literal",
    "goCode": "package main\n\nfunc main() {\n\t// Test simple keyed array literal with integer keys\n\tarr1 := [5]string{\n\t\t1: \"first\",\n\t\t3: \"third\",\n\t}\n\tprintln(\"arr1[0]:\", arr1[0])\n\tprintln(\"arr1[1]:\", arr1[1])\n\tprintln(\"arr1[2]:\", arr1[2])\n\tprintln(\"arr1[3]:\", arr1[3])\n\tprintln(\"arr1[4]:\", arr1[4])\n\n\t// Test keyed array literal with expression keys (this likely causes the issue)\n\tconst offset = 10\n\tarr2 := [15]string{\n\t\toffset + 1: \"at index 11\",\n\t\toffset + 3: \"at index 13\",\n\t}\n\tprintln(\"arr2[10]:\", arr2[10])\n\tprintln(\"arr2[11]:\", arr2[11])\n\tprintln(\"arr2[12]:\", arr2[12])\n\tprintln(\"arr2[13]:\", arr2[13])\n\tprintln(\"arr2[14]:\", arr2[14])\n\n\t// Test mixed keyed and unkeyed elements\n\tarr3 := [8]int{\n\t\t1, 2, // unkeyed (indices 0, 1)\n\t\t5:   100, // keyed (index 5)\n\t\t200, // unkeyed (index 6)\n\t}\n\tprintln(\"arr3[0]:\", arr3[0])\n\tprintln(\"arr3[1]:\", arr3[1])\n\tprintln(\"arr3[2]:\", arr3[2])\n\tprintln(\"arr3[5]:\", arr3[5])\n\tprintln(\"arr3[6]:\", arr3[6])\n\tprintln(\"arr3[7]:\", arr3[7])\n\n\t// Test slice with keyed elements\n\tslice1 := []string{\n\t\t2: \"second\",\n\t\t4: \"fourth\",\n\t}\n\tprintln(\"slice1[0]:\", slice1[0])\n\tprintln(\"slice1[1]:\", slice1[1])\n\tprintln(\"slice1[2]:\", slice1[2])\n\tprintln(\"slice1[3]:\", slice1[3])\n\tprintln(\"slice1[4]:\", slice1[4])\n\n\tprintln(\"keyed array literal test completed\")\n}\n",
    "tsCode": "// Generated file based on keyed_array_literal.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test simple keyed array literal with integer keys\n\tlet arr1 = $.arrayToSlice<string>([\"\", \"first\", \"\", \"third\", \"\"])\n\t$.println(\"arr1[0]:\", arr1![0])\n\t$.println(\"arr1[1]:\", arr1![1])\n\t$.println(\"arr1[2]:\", arr1![2])\n\t$.println(\"arr1[3]:\", arr1![3])\n\t$.println(\"arr1[4]:\", arr1![4])\n\n\t// Test keyed array literal with expression keys (this likely causes the issue)\n\tlet offset: number = 10\n\tlet arr2 = $.arrayToSlice<string>([\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"at index 11\", \"\", \"at index 13\", \"\"])\n\t$.println(\"arr2[10]:\", arr2![10])\n\t$.println(\"arr2[11]:\", arr2![11])\n\t$.println(\"arr2[12]:\", arr2![12])\n\t$.println(\"arr2[13]:\", arr2![13])\n\t$.println(\"arr2[14]:\", arr2![14])\n\n\t// Test mixed keyed and unkeyed elements\n\n\t// unkeyed (indices 0, 1)\n\t// keyed (index 5)\n\t// unkeyed (index 6)\n\tlet arr3 = $.arrayToSlice<number>([1, 2, 0, 0, 0, 100, 200, 0])\n\t$.println(\"arr3[0]:\", arr3![0])\n\t$.println(\"arr3[1]:\", arr3![1])\n\t$.println(\"arr3[2]:\", arr3![2])\n\t$.println(\"arr3[5]:\", arr3![5])\n\t$.println(\"arr3[6]:\", arr3![6])\n\t$.println(\"arr3[7]:\", arr3![7])\n\n\t// Test slice with keyed elements\n\tlet slice1 = $.arrayToSlice<string>([\"\", \"\", \"second\", \"\", \"fourth\"])\n\t$.println(\"slice1[0]:\", slice1![0])\n\t$.println(\"slice1[1]:\", slice1![1])\n\t$.println(\"slice1[2]:\", slice1![2])\n\t$.println(\"slice1[3]:\", slice1![3])\n\t$.println(\"slice1[4]:\", slice1![4])\n\n\t$.println(\"keyed array literal test completed\")\n}\n\n",
    "expectedOutput": "arr1[0]: \narr1[1]: first\narr1[2]: \narr1[3]: third\narr1[4]: \narr2[10]: \narr2[11]: at index 11\narr2[12]: \narr2[13]: at index 13\narr2[14]: \narr3[0]: 1\narr3[1]: 2\narr3[2]: 0\narr3[5]: 100\narr3[6]: 200\narr3[7]: 0\nslice1[0]: \nslice1[1]: \nslice1[2]: second\nslice1[3]: \nslice1[4]: fourth\nkeyed array literal test completed\n"
  },
  {
    "name": "labeled_statement",
    "goCode": "package main\n\nfunc main() {\n\t// Test labeled statements with different statement types\n\n\t// Label with a for loop and continue\nlabel1:\n\tfor i := 0; i < 3; i++ {\n\t\tif i == 1 {\n\t\t\tcontinue label1\n\t\t}\n\t\tprintln(\"continue test i:\", i)\n\t}\n\n\t// Label with a variable declaration (this was causing the TypeScript error)\n\tvar x int = 42\n\tprintln(\"x:\", x)\n\n\t// Label with a block statement and goto\n\tgoto label2\n\tprintln(\"this should be skipped\")\n\nlabel2:\n\t{\n\t\tvar y int = 100\n\t\tprintln(\"y:\", y)\n\t}\n\n\t// Label with a for loop and break\nlabel3:\n\tfor i := 0; i < 5; i++ {\n\t\tif i == 3 {\n\t\t\tbreak label3\n\t\t}\n\t\tprintln(\"i:\", i)\n\t}\n\n\t// Nested labels\nouter:\n\tfor i := 0; i < 3; i++ {\n\tinner:\n\t\tfor j := 0; j < 3; j++ {\n\t\t\tif i == 1 && j == 1 {\n\t\t\t\tbreak outer\n\t\t\t}\n\t\t\tif j == 1 {\n\t\t\t\tcontinue inner\n\t\t\t}\n\t\t\tprintln(\"nested:\", i, j)\n\t\t}\n\t}\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on labeled_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/builtin.js\";\n\nexport async function main(): Promise<void> {\n\t// Test labeled statements with different statement types\n\n\t// Label with a for loop and continue\n\tlabel1: for (let i = 0; i < 3; i++) {\n\t\tif (i == 1) {\n\t\t\tcontinue\n\t\t}\n\t\tconsole.log(\"continue test i:\", i)\n\t}\n\n\t// Label with a variable declaration (this was causing the TypeScript error)\n\tlet x: number = 42\n\tconsole.log(\"x:\", x)\n\n\t// Label with a block statement and goto\n\t// unhandled branch statement token: goto\n\tconsole.log(\"this should be skipped\")\n\n\tlabel2: {\n\t\tlet y: number = 100\n\t\tconsole.log(\"y:\", y)\n\t}\n\n\t// Label with a for loop and break\n\tlabel3: for (let i = 0; i < 5; i++) {\n\t\tif (i == 3) {\n\t\t\tbreak\n\t\t}\n\t\tconsole.log(\"i:\", i)\n\t}\n\n\t// Nested labels\n\touter: for (let i = 0; i < 3; i++) {\n\t\tinner: for (let j = 0; j < 3; j++) {\n\t\t\tif (i == 1 && j == 1) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (j == 1) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconsole.log(\"nested:\", i, j)\n\t\t}\n\t}\n\n\tconsole.log(\"test finished\")\n}\n\n",
    "expectedOutput": "continue test i: 0\ncontinue test i: 2\nx: 42\ny: 100\ni: 0\ni: 1\ni: 2\nnested: 0 0\nnested: 0 2\nnested: 1 0\ntest finished\n"
  },
  {
    "name": "linkname",
    "goCode": "//go:build linkname\n\npackage main\n\nimport (\n\t\"time\"\n\t_ \"unsafe\"\n)\n\n//go:linkname timeNow time.Now\nfunc timeNow() time.Time {\n\treturn time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)\n}\n\nfunc main() {\n\tnow := time.Now()\n\tprintln(\"overridden time now\", now.String())\n}\n",
    "tsCode": "// Generated file based on linkname.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/builtin.js\";\n\nimport * as os from \"@goscript/os/index.js\"\n\nimport * as _ from \"@goscript/unsafe/index.js\"\n\nexport function osOpen(name: string): [os.File | null, $.GoError] {}\n\nexport async function main(): Promise<void> {\n\tusing __defer = new $.DisposableStack();\n\t// Test basic os package functionality\n\tlet [file, err] = os.Open(\"/dev/null\")\n\tif (err != null) {\n\t\tconsole.log(\"error opening file:\", err!.Error())\n\t\treturn \n\t}\n\t__defer.defer(() => {\n\t\tfile!.Close()\n\t});\n\n\t// Test the linkname function - this should be equivalent to os.Open\n\tlet [file2, err2] = osOpen(\"/dev/null\")\n\tif (err2 != null) {\n\t\tconsole.log(\"error opening file with linkname:\", err2!.Error())\n\t\treturn \n\t}\n\t__defer.defer(() => {\n\t\tfile2!.Close()\n\t});\n\n\tconsole.log(\"linkname directive compiled successfully\")\n\tconsole.log(\"test finished\")\n}\n\n",
    "expectedOutput": ""
  },
  {
    "name": "make_generic_type",
    "goCode": "package main\n\n// This test reproduces the \"unhandled make call\" error\n// when using make() with generic types like set.Ints[int64]\n\n// Simulate the set.Ints generic type from gonum\ntype Ints[T comparable] map[T]struct{}\n\nfunc main() {\n\t// This should trigger the unhandled make call error\n\t// Similar to: seen := make(set.Ints[int64])\n\tseen := make(Ints[int64])\n\n\t// Test basic operations\n\tseen[42] = struct{}{}\n\t_, exists := seen[42]\n\tprintln(\"Value exists:\", exists)\n\n\t// Test with string type parameter\n\tstringSet := make(Ints[string])\n\tstringSet[\"hello\"] = struct{}{}\n\t_, exists2 := stringSet[\"hello\"]\n\tprintln(\"String exists:\", exists2)\n}\n",
    "tsCode": "// Generated file based on make_generic_type.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type Ints<T extends $.Comparable> = Map<T, {  }> | null;\n\nexport async function main(): Promise<void> {\n\t// This should trigger the unhandled make call error\n\t// Similar to: seen := make(set.Ints[int64])\n\tlet seen = $.makeMap<number, {  }>()\n\n\t// Test basic operations\n\t$.mapSet(seen, 42, {})\n\tlet [, exists] = $.mapGet(seen, 42, {})\n\t$.println(\"Value exists:\", exists)\n\n\t// Test with string type parameter\n\tlet stringSet = $.makeMap<string, {  }>()\n\t$.mapSet(stringSet, \"hello\", {})\n\tlet [, exists2] = $.mapGet(stringSet, \"hello\", {})\n\t$.println(\"String exists:\", exists2)\n}\n\n",
    "expectedOutput": "Value exists: true\nString exists: true\n"
  },
  {
    "name": "make_named_types",
    "goCode": "package main\n\nfunc main() {\n\t// Test make() calls with named types as the first argument\n\t// This tests the compiler's ability to handle make() with type aliases/named types\n\t// rather than direct type expressions like []int or map[string]int\n\n\ttype MySlice []int\n\tvar s MySlice = make(MySlice, 5)\n\tprintln(\"Length:\", len(s))\n\n\t// Test make() with named map type\n\ttype MyMap map[string]int\n\tvar m MyMap = make(MyMap)\n\tm[\"test\"] = 42\n\tprintln(\"Value:\", m[\"test\"])\n}\n",
    "tsCode": "// Generated file based on make_named_types.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test make() calls with named types as the first argument\n\t// This tests the compiler's ability to handle make() with type aliases/named types\n\t// rather than direct type expressions like []int or map[string]int\n\n\ttype MySlice = $.Slice<number>;\n\tlet s: MySlice = $.makeSlice<number>(5, undefined, 'number')\n\t$.println(\"Length:\", $.len(s))\n\n\t// Test make() with named map type\n\ttype MyMap = Map<string, number> | null;\n\tlet m: MyMap = $.makeMap<string, number>()\n\t$.mapSet(m, \"test\", 42)\n\t$.println(\"Value:\", $.mapGet(m, \"test\", 0)[0])\n}\n\n",
    "expectedOutput": "Length: 5\nValue: 42 "
  },
  {
    "name": "make_selector_type",
    "goCode": "package main\n\nfunc main() {\n\t// Test make() with a map type\n\t// This verifies that our fix for selector expressions in make() calls works\n\t// The original issue was \"unhandled make call\" when using selector expressions\n\n\tmfs := make(map[string][]byte)\n\tmfs[\"test.txt\"] = []byte(\"hello world\")\n\tprintln(\"Created map:\", len(mfs))\n\tprintln(\"Content:\", string(mfs[\"test.txt\"]))\n}\n",
    "tsCode": "// Generated file based on make_selector_type.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test make() with a map type\n\t// This verifies that our fix for selector expressions in make() calls works\n\t// The original issue was \"unhandled make call\" when using selector expressions\n\n\tlet mfs = $.makeMap<string, $.Bytes>()\n\t$.mapSet(mfs, \"test.txt\", $.stringToBytes(\"hello world\"))\n\t$.println(\"Created map:\", $.len(mfs))\n\t$.println(\"Content:\", $.bytesToString($.mapGet(mfs, \"test.txt\", new Uint8Array(0))[0]))\n}\n\n",
    "expectedOutput": "Created map: 1\nContent: hello world\n"
  },
  {
    "name": "make_slice",
    "goCode": "package main\n\nfunc main() {\n\tprintln(\"--- Testing make() with slices ---\")\n\n\t// Test 1: Basic make with length only\n\tprintln(\"--- Basic make with length only ---\")\n\ts1 := make([]int, 5)\n\tprintln(\"len(s1):\", len(s1)) // 5\n\tprintln(\"cap(s1):\", cap(s1)) // 5\n\n\t// Test 2: Make with length and capacity\n\tprintln(\"--- Make with length and capacity ---\")\n\ts2 := make([]int, 3, 10)\n\tprintln(\"len(s2):\", len(s2)) // 3\n\tprintln(\"cap(s2):\", cap(s2)) // 10\n\n\t// Test 3: Make bytes with zero length, large capacity\n\tprintln(\"--- Make bytes with zero length, large capacity ---\")\n\tb1 := make([]byte, 0, 100000)\n\tprintln(\"len(b1):\", len(b1)) // 0\n\tprintln(\"cap(b1):\", cap(b1)) // 100000\n\n\t// Test 4: Make bytes with length and capacity\n\tprintln(\"--- Make bytes with length and capacity ---\")\n\tb2 := make([]byte, 10, 50)\n\tprintln(\"len(b2):\", len(b2)) // 10\n\tprintln(\"cap(b2):\", cap(b2)) // 50\n\n\t// Test 5: Make with zero capacity\n\tprintln(\"--- Make with zero capacity ---\")\n\ts3 := make([]int, 0, 0)\n\tprintln(\"len(s3):\", len(s3)) // 0\n\tprintln(\"cap(s3):\", cap(s3)) // 0\n\n\t// Test 6: Make with equal length and capacity\n\tprintln(\"--- Make with equal length and capacity ---\")\n\ts4 := make([]string, 7, 7)\n\tprintln(\"len(s4):\", len(s4)) // 7\n\tprintln(\"cap(s4):\", cap(s4)) // 7\n\n\t// Test 7: Append to slice with extra capacity\n\tprintln(\"--- Append to slice with extra capacity ---\")\n\ts5 := make([]int, 2, 5)\n\ts5[0] = 10\n\ts5[1] = 20\n\tprintln(\"Before append - len:\", len(s5), \"cap:\", cap(s5)) // len: 2, cap: 5\n\ts5 = append(s5, 30)\n\tprintln(\"After append - len:\", len(s5), \"cap:\", cap(s5)) // len: 3, cap: 5\n\tprintln(\"s5[2]:\", s5[2])                                 // 30\n\n\t// Test 8: Append to bytes with extra capacity\n\tprintln(\"--- Append to bytes with extra capacity ---\")\n\tb3 := make([]byte, 1, 10)\n\tb3[0] = 65                                                // 'A'\n\tprintln(\"Before append - len:\", len(b3), \"cap:\", cap(b3)) // len: 1, cap: 10\n\tb3 = append(b3, 66)                                       // 'B'\n\tprintln(\"After append - len:\", len(b3), \"cap:\", cap(b3))  // len: 2, cap: 10\n\tprintln(\"b3[0]:\", b3[0])                                  // 65\n\tprintln(\"b3[1]:\", b3[1])                                  // 66\n\n\t// Test 9: Large capacity slice\n\tprintln(\"--- Large capacity slice ---\")\n\tlarge := make([]int, 5, 1000000)\n\tprintln(\"len(large):\", len(large)) // 5\n\tprintln(\"cap(large):\", cap(large)) // 1000000\n\n\t// Test 10: Zero length, various capacities\n\tprintln(\"--- Zero length, various capacities ---\")\n\tz1 := make([]byte, 0, 1)\n\tz2 := make([]byte, 0, 100)\n\tz3 := make([]byte, 0, 10000)\n\tprintln(\"z1 - len:\", len(z1), \"cap:\", cap(z1)) // len: 0, cap: 1\n\tprintln(\"z2 - len:\", len(z2), \"cap:\", cap(z2)) // len: 0, cap: 100\n\tprintln(\"z3 - len:\", len(z3), \"cap:\", cap(z3)) // len: 0, cap: 10000\n\n\t// Test 11: Slice operations on made slices\n\tprintln(\"--- Slice operations on made slices ---\")\n\ts6 := make([]int, 10, 20)\n\tfor i := 0; i < 10; i++ {\n\t\ts6[i] = i * 10\n\t}\n\tsub := s6[2:5]                                    // Should have len=3, cap=18 (20-2)\n\tprintln(\"sub - len:\", len(sub), \"cap:\", cap(sub)) // len: 3, cap: 18\n\tprintln(\"sub[0]:\", sub[0])                        // 20\n\tprintln(\"sub[2]:\", sub[2])                        // 40\n\n\t// Test 12: String slices with capacity\n\tprintln(\"--- String slices with capacity ---\")\n\tstr := make([]string, 3, 8)\n\tstr[0] = \"hello\"\n\tstr[1] = \"world\"\n\tstr[2] = \"test\"\n\tprintln(\"str - len:\", len(str), \"cap:\", cap(str)) // len: 3, cap: 8\n\tprintln(\"str[1]:\", str[1])                        // world\n\n\tprintln(\"--- All tests completed ---\")\n}\n",
    "tsCode": "// Generated file based on make_slice.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t$.println(\"--- Testing make() with slices ---\")\n\n\t// Test 1: Basic make with length only\n\t$.println(\"--- Basic make with length only ---\")\n\tlet s1 = $.makeSlice<number>(5, undefined, 'number')\n\t$.println(\"len(s1):\", $.len(s1)) // 5\n\t$.println(\"cap(s1):\", $.cap(s1)) // 5\n\n\t// Test 2: Make with length and capacity\n\t$.println(\"--- Make with length and capacity ---\")\n\tlet s2 = $.makeSlice<number>(3, 10, 'number')\n\t$.println(\"len(s2):\", $.len(s2)) // 3\n\t$.println(\"cap(s2):\", $.cap(s2)) // 10\n\n\t// Test 3: Make bytes with zero length, large capacity\n\t$.println(\"--- Make bytes with zero length, large capacity ---\")\n\tlet b1 = $.makeSlice<number>(0, 100000, 'byte')\n\t$.println(\"len(b1):\", $.len(b1)) // 0\n\t$.println(\"cap(b1):\", $.cap(b1)) // 100000\n\n\t// Test 4: Make bytes with length and capacity\n\t$.println(\"--- Make bytes with length and capacity ---\")\n\tlet b2 = $.makeSlice<number>(10, 50, 'byte')\n\t$.println(\"len(b2):\", $.len(b2)) // 10\n\t$.println(\"cap(b2):\", $.cap(b2)) // 50\n\n\t// Test 5: Make with zero capacity\n\t$.println(\"--- Make with zero capacity ---\")\n\tlet s3 = $.makeSlice<number>(0, 0, 'number')\n\t$.println(\"len(s3):\", $.len(s3)) // 0\n\t$.println(\"cap(s3):\", $.cap(s3)) // 0\n\n\t// Test 6: Make with equal length and capacity\n\t$.println(\"--- Make with equal length and capacity ---\")\n\tlet s4 = $.makeSlice<string>(7, 7, 'string')\n\t$.println(\"len(s4):\", $.len(s4)) // 7\n\t$.println(\"cap(s4):\", $.cap(s4)) // 7\n\n\t// Test 7: Append to slice with extra capacity\n\t$.println(\"--- Append to slice with extra capacity ---\")\n\tlet s5 = $.makeSlice<number>(2, 5, 'number')\n\ts5![0] = 10\n\ts5![1] = 20\n\t$.println(\"Before append - len:\", $.len(s5), \"cap:\", $.cap(s5)) // len: 2, cap: 5\n\ts5 = $.append(s5, 30)\n\t$.println(\"After append - len:\", $.len(s5), \"cap:\", $.cap(s5)) // len: 3, cap: 5\n\t$.println(\"s5[2]:\", s5![2]) // 30\n\n\t// Test 8: Append to bytes with extra capacity\n\t$.println(\"--- Append to bytes with extra capacity ---\")\n\tlet b3 = $.makeSlice<number>(1, 10, 'byte')\n\tb3![0] = 65 // 'A'\n\t$.println(\"Before append - len:\", $.len(b3), \"cap:\", $.cap(b3)) // len: 1, cap: 10\n\tb3 = $.append(b3, 66) // 'B'\n\t$.println(\"After append - len:\", $.len(b3), \"cap:\", $.cap(b3)) // len: 2, cap: 10\n\t$.println(\"b3[0]:\", b3![0]) // 65\n\t$.println(\"b3[1]:\", b3![1]) // 66\n\n\t// Test 9: Large capacity slice\n\t$.println(\"--- Large capacity slice ---\")\n\tlet large = $.makeSlice<number>(5, 1000000, 'number')\n\t$.println(\"len(large):\", $.len(large)) // 5\n\t$.println(\"cap(large):\", $.cap(large)) // 1000000\n\n\t// Test 10: Zero length, various capacities\n\t$.println(\"--- Zero length, various capacities ---\")\n\tlet z1 = $.makeSlice<number>(0, 1, 'byte')\n\tlet z2 = $.makeSlice<number>(0, 100, 'byte')\n\tlet z3 = $.makeSlice<number>(0, 10000, 'byte')\n\t$.println(\"z1 - len:\", $.len(z1), \"cap:\", $.cap(z1)) // len: 0, cap: 1\n\t$.println(\"z2 - len:\", $.len(z2), \"cap:\", $.cap(z2)) // len: 0, cap: 100\n\t$.println(\"z3 - len:\", $.len(z3), \"cap:\", $.cap(z3)) // len: 0, cap: 10000\n\n\t// Test 11: Slice operations on made slices\n\t$.println(\"--- Slice operations on made slices ---\")\n\tlet s6 = $.makeSlice<number>(10, 20, 'number')\n\tfor (let i = 0; i < 10; i++) {\n\t\ts6![i] = i * 10\n\t}\n\tlet sub = $.goSlice(s6, 2, 5) // Should have len=3, cap=18 (20-2)\n\t$.println(\"sub - len:\", $.len(sub), \"cap:\", $.cap(sub)) // len: 3, cap: 18\n\t$.println(\"sub[0]:\", sub![0]) // 20\n\t$.println(\"sub[2]:\", sub![2]) // 40\n\n\t// Test 12: String slices with capacity\n\t$.println(\"--- String slices with capacity ---\")\n\tlet str = $.makeSlice<string>(3, 8, 'string')\n\tstr![0] = \"hello\"\n\tstr![1] = \"world\"\n\tstr![2] = \"test\"\n\t$.println(\"str - len:\", $.len(str), \"cap:\", $.cap(str)) // len: 3, cap: 8\n\t$.println(\"str[1]:\", str![1]) // world\n\n\t$.println(\"--- All tests completed ---\")\n}\n\n",
    "expectedOutput": "--- Testing make() with slices ---\n--- Basic make with length only ---\nlen(s1): 5\ncap(s1): 5\n--- Make with length and capacity ---\nlen(s2): 3\ncap(s2): 10\n--- Make bytes with zero length, large capacity ---\nlen(b1): 0\ncap(b1): 100000\n--- Make bytes with length and capacity ---\nlen(b2): 10\ncap(b2): 50\n--- Make with zero capacity ---\nlen(s3): 0\ncap(s3): 0\n--- Make with equal length and capacity ---\nlen(s4): 7\ncap(s4): 7\n--- Append to slice with extra capacity ---\nBefore append - len: 2 cap: 5\nAfter append - len: 3 cap: 5\ns5[2]: 30\n--- Append to bytes with extra capacity ---\nBefore append - len: 1 cap: 10\nAfter append - len: 2 cap: 10\nb3[0]: 65\nb3[1]: 66\n--- Large capacity slice ---\nlen(large): 5\ncap(large): 1000000\n--- Zero length, various capacities ---\nz1 - len: 0 cap: 1\nz2 - len: 0 cap: 100\nz3 - len: 0 cap: 10000\n--- Slice operations on made slices ---\nsub - len: 3 cap: 18\nsub[0]: 20\nsub[2]: 40\n--- String slices with capacity ---\nstr - len: 3 cap: 8\nstr[1]: world\n--- All tests completed ---\n"
  },
  {
    "name": "map_assign_blank_both",
    "goCode": "package main\n\nfunc main() {\n\tm := make(map[string]int)\n\tm[\"one\"] = 1\n\tprintln(\"Assigning m[\\\"one\\\"] to _, _ (key exists)\")\n\t_, _ = m[\"one\"]\n\tprintln(\"Assigning m[\\\"two\\\"] to _, _ (key does not exist)\")\n\t_, _ = m[\"two\"]\n\tprintln(\"done\")\n}\n",
    "tsCode": "// Generated file based on map_assign_blank_both.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet m = $.makeMap<string, number>()\n\t$.mapSet(m, \"one\", 1)\n\t$.println(\"Assigning m[\\\"one\\\"] to _, _ (key exists)\")\n\t;[, ] = $.mapGet(m, \"one\", 0)\n\t$.println(\"Assigning m[\\\"two\\\"] to _, _ (key does not exist)\")\n\t;[, ] = $.mapGet(m, \"two\", 0)\n\t$.println(\"done\")\n}\n\n",
    "expectedOutput": "Assigning m[\"one\"] to _, _ (key exists)\nAssigning m[\"two\"] to _, _ (key does not exist)\ndone"
  },
  {
    "name": "map_support",
    "goCode": "package main\n\nfunc main() {\n\t// Create map using make\n\tscores := make(map[string]int)\n\tprintln(\"Empty map created: Expected: true, Actual:\", len(scores) == 0)\n\n\t// Add key-value pairs\n\tscores[\"Alice\"] = 90\n\tscores[\"Bob\"] = 85\n\tscores[\"Charlie\"] = 92\n\n\t// Map size\n\tprintln(\"Map size after adding 3 items: Expected: 3, Actual:\", len(scores))\n\n\t// Access values\n\tprintln(\"Alice's score: Expected: 90, Actual:\", scores[\"Alice\"])\n\tprintln(\"Bob's score: Expected: 85, Actual:\", scores[\"Bob\"])\n\n\t// Modify a value\n\tscores[\"Bob\"] = 88\n\tprintln(\"Bob's updated score: Expected: 88, Actual:\", scores[\"Bob\"])\n\n\t// Check if key exists (comma-ok idiom)\n\tvalue, exists := scores[\"David\"]\n\tprintln(\"Does David exist in map? Expected: false, Actual:\", exists)\n\tprintln(\"Value for non-existent key: Expected: 0, Actual:\", value)\n\n\t// Delete a key\n\tdelete(scores, \"Charlie\")\n\t_, exists = scores[\"Charlie\"]\n\tprintln(\"After delete, does Charlie exist? Expected: false, Actual:\", exists)\n\n\t// Create map with literal syntax\n\tcolors := map[string]string{\n\t\t\"red\":   \"#ff0000\",\n\t\t\"green\": \"#00ff00\",\n\t\t\"blue\":  \"#0000ff\",\n\t}\n\tprintln(\"Map literal size: Expected: 3, Actual:\", len(colors))\n\tprintln(\"Color code for red: Expected: #ff0000, Actual:\", colors[\"red\"])\n\n\t// Iterate over a map with range\n\tprintln(\"Iterating over scores map:\")\n\n\t// Create a new map with string keys and string values for testing iteration\n\tstringMap := map[string]string{\n\t\t\"Alice\":   \"A+\",\n\t\t\"Bob\":     \"B+\",\n\t\t\"Charlie\": \"A\",\n\t}\n\n\t// Note: Map iteration is not ordered in Go, so we will collect the results and sort them for consistent test output.\n\tvar scoreResults []string\n\tfor name, grade := range stringMap {\n\t\t// Using string concatenation to build the output string\n\t\tresult := \"  - Name: \" + name + \" Grade: \" + grade\n\t\tscoreResults = append(scoreResults, result)\n\t}\n\n\t// Inline bubble sort for string slice\n\t// (avoid importing sort package yet)\n\tn := len(scoreResults)\n\tfor i := 0; i < n-1; i++ {\n\t\tfor j := 0; j < n-i-1; j++ {\n\t\t\tif scoreResults[j] > scoreResults[j+1] {\n\t\t\t\tscoreResults[j], scoreResults[j+1] = scoreResults[j+1], scoreResults[j]\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, result := range scoreResults {\n\t\tprintln(result)\n\t}\n}\n",
    "tsCode": "// Generated file based on map_support.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Create map using make\n\tlet scores = $.makeMap<string, number>()\n\t$.println(\"Empty map created: Expected: true, Actual:\", $.len(scores) == 0)\n\n\t// Add key-value pairs\n\t$.mapSet(scores, \"Alice\", 90)\n\t$.mapSet(scores, \"Bob\", 85)\n\t$.mapSet(scores, \"Charlie\", 92)\n\n\t// Map size\n\t$.println(\"Map size after adding 3 items: Expected: 3, Actual:\", $.len(scores))\n\n\t// Access values\n\t$.println(\"Alice's score: Expected: 90, Actual:\", $.mapGet(scores, \"Alice\", 0)[0])\n\t$.println(\"Bob's score: Expected: 85, Actual:\", $.mapGet(scores, \"Bob\", 0)[0])\n\n\t// Modify a value\n\t$.mapSet(scores, \"Bob\", 88)\n\t$.println(\"Bob's updated score: Expected: 88, Actual:\", $.mapGet(scores, \"Bob\", 0)[0])\n\n\t// Check if key exists (comma-ok idiom)\n\tlet [value, exists] = $.mapGet(scores, \"David\", 0)\n\t$.println(\"Does David exist in map? Expected: false, Actual:\", exists)\n\t$.println(\"Value for non-existent key: Expected: 0, Actual:\", value)\n\n\t// Delete a key\n\t$.deleteMapEntry(scores, \"Charlie\")\n\t;[, exists] = $.mapGet(scores, \"Charlie\", 0)\n\t$.println(\"After delete, does Charlie exist? Expected: false, Actual:\", exists)\n\n\t// Create map with literal syntax\n\tlet colors = new Map([[\"red\", \"#ff0000\"], [\"green\", \"#00ff00\"], [\"blue\", \"#0000ff\"]])\n\t$.println(\"Map literal size: Expected: 3, Actual:\", $.len(colors))\n\t$.println(\"Color code for red: Expected: #ff0000, Actual:\", $.mapGet(colors, \"red\", \"\")[0])\n\n\t// Iterate over a map with range\n\t$.println(\"Iterating over scores map:\")\n\n\t// Create a new map with string keys and string values for testing iteration\n\tlet stringMap = new Map([[\"Alice\", \"A+\"], [\"Bob\", \"B+\"], [\"Charlie\", \"A\"]])\n\n\t// Note: Map iteration is not ordered in Go, so we will collect the results and sort them for consistent test output.\n\tlet scoreResults: $.Slice<string> = null\n\n\t// Using string concatenation to build the output string\n\tfor (const [name, grade] of stringMap?.entries() ?? []) {\n\t\t{\n\t\t\t// Using string concatenation to build the output string\n\t\t\tlet result = \"  - Name: \" + name + \" Grade: \" + grade\n\t\t\tscoreResults = $.append(scoreResults, result)\n\t\t}\n\t}\n\n\t// Inline bubble sort for string slice\n\t// (avoid importing sort package yet)\n\tlet n = $.len(scoreResults)\n\tfor (let i = 0; i < n - 1; i++) {\n\t\tfor (let j = 0; j < n - i - 1; j++) {\n\t\t\tif (scoreResults![j] > scoreResults![j + 1]) {\n\t\t\t\t;[scoreResults![j], scoreResults![j + 1]] = [scoreResults![j + 1], scoreResults![j]]\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (let _i = 0; _i < $.len(scoreResults); _i++) {\n\t\tlet result = scoreResults![_i]\n\t\t{\n\t\t\t$.println(result)\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Empty map created: Expected: true, Actual: true\nMap size after adding 3 items: Expected: 3, Actual: 3\nAlice's score: Expected: 90, Actual: 90\nBob's score: Expected: 85, Actual: 85\nBob's updated score: Expected: 88, Actual: 88\nDoes David exist in map? Expected: false, Actual: false\nValue for non-existent key: Expected: 0, Actual: 0\nAfter delete, does Charlie exist? Expected: false, Actual: false\nMap literal size: Expected: 3, Actual: 3\nColor code for red: Expected: #ff0000, Actual: #ff0000\nIterating over scores map:\n  - Name: Alice Grade: A+\n  - Name: Bob Grade: B+\n  - Name: Charlie Grade: A"
  },
  {
    "name": "map_type_assertion",
    "goCode": "package main\n\nfunc main() {\n\tvar i interface{}\n\ti = map[string]int{\"age\": 30}\n\n\tm, ok := i.(map[string]int)\n\tif ok {\n\t\tprintln(\"Age:\", m[\"age\"])\n\t} else {\n\t\tprintln(\"Type assertion failed\")\n\t}\n\n\t_, ok2 := i.(map[string]string) // Different value type\n\tif ok2 {\n\t\t// This block should not be reached if the assertion fails as expected.\n\t\t// Depending on how Go handles failed assertions with incorrect types,\n\t\t// accessing n[\"key\"] might panic if n is nil.\n\t\t// For safety and clarity, we'll just print a generic message if it passes unexpectedly.\n\t\tprintln(\"Unexpected success for map[string]string assertion\")\n\t} else {\n\t\tprintln(\"Second type assertion (map[string]string) failed as expected\")\n\t}\n\n\t_, ok3 := i.(map[int]int) // Different key type\n\tif ok3 {\n\t\t// Similar to the above, this block should not be reached.\n\t\tprintln(\"Unexpected success for map[int]int assertion\")\n\t} else {\n\t\tprintln(\"Third type assertion (map[int]int) failed as expected\")\n\t}\n}\n",
    "tsCode": "// Generated file based on map_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet i: null | any = null\n\ti = new Map([[\"age\", 30]])\n\n\tlet { value: m, ok: ok } = $.typeAssert<Map<string, number> | null>(i, {kind: $.TypeKind.Map, keyType: {kind: $.TypeKind.Basic, name: 'string'}, elemType: {kind: $.TypeKind.Basic, name: 'number'}})\n\tif (ok) {\n\t\t$.println(\"Age:\", $.mapGet(m, \"age\", 0)[0])\n\t} else {\n\t\t$.println(\"Type assertion failed\")\n\t}\n\n\tlet { ok: ok2 } = $.typeAssert<Map<string, string> | null>(i, {kind: $.TypeKind.Map, keyType: {kind: $.TypeKind.Basic, name: 'string'}, elemType: {kind: $.TypeKind.Basic, name: 'string'}})\n\n\t// This block should not be reached if the assertion fails as expected.\n\t// Depending on how Go handles failed assertions with incorrect types,\n\t// accessing n[\"key\"] might panic if n is nil.\n\t// For safety and clarity, we'll just print a generic message if it passes unexpectedly.\n\tif (ok2) {\n\t\t// This block should not be reached if the assertion fails as expected.\n\t\t// Depending on how Go handles failed assertions with incorrect types,\n\t\t// accessing n[\"key\"] might panic if n is nil.\n\t\t// For safety and clarity, we'll just print a generic message if it passes unexpectedly.\n\t\t$.println(\"Unexpected success for map[string]string assertion\")\n\t} else {\n\t\t$.println(\"Second type assertion (map[string]string) failed as expected\")\n\t}\n\n\tlet { ok: ok3 } = $.typeAssert<Map<number, number> | null>(i, {kind: $.TypeKind.Map, keyType: {kind: $.TypeKind.Basic, name: 'number'}, elemType: {kind: $.TypeKind.Basic, name: 'number'}})\n\n\t// Similar to the above, this block should not be reached.\n\tif (ok3) {\n\t\t// Similar to the above, this block should not be reached.\n\t\t$.println(\"Unexpected success for map[int]int assertion\")\n\t} else {\n\t\t$.println(\"Third type assertion (map[int]int) failed as expected\")\n\t}\n}\n\n",
    "expectedOutput": "Age: 30\nSecond type assertion (map[string]string) failed as expected\nThird type assertion (map[int]int) failed as expected"
  },
  {
    "name": "method_async_call",
    "goCode": "package main\n\nimport \"sync\"\n\ntype FileTracker struct {\n\tmutex sync.Mutex\n\tlines []int\n}\n\n// AddLine is async because it uses a mutex\nfunc (f *FileTracker) AddLine(offset int) {\n\tf.mutex.Lock()\n\tf.lines = append(f.lines, offset)\n\tf.mutex.Unlock()\n}\n\ntype Scanner struct {\n\tfile *FileTracker\n}\n\n// next() calls an async method but itself is not marked async\nfunc (s *Scanner) next() {\n\ts.file.AddLine(10)\n}\n\nfunc main() {\n\ttracker := &FileTracker{lines: []int{}}\n\tscanner := &Scanner{file: tracker}\n\tscanner.next()\n\tprintln(len(tracker.lines))\n}\n",
    "tsCode": "// Generated file based on method_async_call.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as sync from \"@goscript/sync/index.js\"\n\nexport class FileTracker {\n\tpublic get mutex(): sync.Mutex {\n\t\treturn this._fields.mutex.value\n\t}\n\tpublic set mutex(value: sync.Mutex) {\n\t\tthis._fields.mutex.value = value\n\t}\n\n\tpublic get lines(): $.Slice<number> {\n\t\treturn this._fields.lines.value\n\t}\n\tpublic set lines(value: $.Slice<number>) {\n\t\tthis._fields.lines.value = value\n\t}\n\n\tpublic _fields: {\n\t\tmutex: $.VarRef<sync.Mutex>;\n\t\tlines: $.VarRef<$.Slice<number>>;\n\t}\n\n\tconstructor(init?: Partial<{lines?: $.Slice<number>, mutex?: sync.Mutex}>) {\n\t\tthis._fields = {\n\t\t\tmutex: $.varRef(init?.mutex ? $.markAsStructValue(init.mutex.clone()) : new sync.Mutex()),\n\t\t\tlines: $.varRef(init?.lines ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): FileTracker {\n\t\tconst cloned = new FileTracker()\n\t\tcloned._fields = {\n\t\t\tmutex: $.varRef($.markAsStructValue(this._fields.mutex.value.clone())),\n\t\t\tlines: $.varRef(this._fields.lines.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// AddLine is async because it uses a mutex\n\tpublic async AddLine(offset: number): Promise<void> {\n\t\tconst f = this\n\t\tawait f.mutex.Lock()\n\t\tf.lines = $.append(f.lines, offset)\n\t\tf.mutex.Unlock()\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.FileTracker',\n\t  new FileTracker(),\n\t  [{ name: \"AddLine\", args: [{ name: \"offset\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [] }],\n\t  FileTracker,\n\t  {\"mutex\": \"Mutex\", \"lines\": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"int\" } }}\n\t);\n}\n\nexport class Scanner {\n\tpublic get file(): FileTracker | null {\n\t\treturn this._fields.file.value\n\t}\n\tpublic set file(value: FileTracker | null) {\n\t\tthis._fields.file.value = value\n\t}\n\n\tpublic _fields: {\n\t\tfile: $.VarRef<FileTracker | null>;\n\t}\n\n\tconstructor(init?: Partial<{file?: FileTracker | null}>) {\n\t\tthis._fields = {\n\t\t\tfile: $.varRef(init?.file ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): Scanner {\n\t\tconst cloned = new Scanner()\n\t\tcloned._fields = {\n\t\t\tfile: $.varRef(this._fields.file.value ? $.markAsStructValue(this._fields.file.value.clone()) : null)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// next() calls an async method but itself is not marked async\n\tpublic async next(): Promise<void> {\n\t\tconst s = this\n\t\tawait s.file!.AddLine(10)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Scanner',\n\t  new Scanner(),\n\t  [{ name: \"next\", args: [], returns: [] }],\n\t  Scanner,\n\t  {\"file\": { kind: $.TypeKind.Pointer, elemType: \"FileTracker\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet tracker = new FileTracker({lines: $.arrayToSlice<number>([])})\n\tlet scanner = new Scanner({file: tracker})\n\tawait scanner!.next()\n\t$.println($.len(tracker!.lines))\n}\n\n",
    "expectedOutput": "1\n"
  },
  {
    "name": "method_async_dependency",
    "goCode": "package main\n\ntype Decoder struct{}\n\n// value is async because it uses channels\nfunc (d *Decoder) value() error {\n\tch := make(chan int, 1) // Buffered channel to avoid deadlock\n\tch <- 42\n\treturn nil\n}\n\n// array calls value, so it should also be async\nfunc (d *Decoder) array() error {\n\tif err := d.value(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\td := &Decoder{}\n\tif err := d.array(); err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t} else {\n\t\tprintln(\"Success\")\n\t}\n}\n",
    "tsCode": "// Generated file based on method_async_dependency.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Decoder {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): Decoder {\n\t\tconst cloned = new Decoder()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// value is async because it uses channels\n\tpublic async value(): Promise<$.GoError> {\n\t\tlet ch = $.makeChannel<number>(1, 0, 'both') // Buffered channel to avoid deadlock\n\t\tawait $.chanSend(ch, 42)\n\t\treturn null\n\t}\n\n\t// array calls value, so it should also be async\n\tpublic async array(): Promise<$.GoError> {\n\t\tconst d = this\n\t\t{\n\t\t\tlet err = await d.value()\n\t\t\tif (err != null) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Decoder',\n\t  new Decoder(),\n\t  [{ name: \"value\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"array\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  Decoder,\n\t  {}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet d = new Decoder({})\n\t{\n\t\tlet err = await d!.array()\n\t\tif (err != null) {\n\t\t\t$.println(\"Error:\", err!.Error())\n\t\t} else {\n\t\t\t$.println(\"Success\")\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Success\n"
  },
  {
    "name": "method_binding",
    "goCode": "package main\n\ntype Counter struct {\n\tvalue int\n}\n\nfunc (c *Counter) Increment() {\n\tc.value++\n}\n\nfunc (c *Counter) GetValue() int {\n\treturn c.value\n}\n\nfunc (c Counter) IncrementValue() {\n\tc.value++\n}\n\nfunc (c Counter) GetValueByValue() int {\n\treturn c.value\n}\n\nfunc callFunction(fn func()) {\n\tfn()\n}\n\nfunc callFunctionWithReturn(fn func() int) int {\n\treturn fn()\n}\n\nfunc main() {\n\t// Test with pointer receiver methods\n\tcounter := &Counter{value: 0}\n\n\tprintln(\"Initial value:\", counter.GetValue())\n\n\t// Test method binding when passed as parameter\n\tcallFunction(counter.Increment)\n\tprintln(\"After calling Increment via parameter:\", counter.GetValue())\n\n\t// Test method binding when assigned to variable\n\tincrementFunc := counter.Increment\n\tincrementFunc()\n\tprintln(\"After calling Increment via variable:\", counter.GetValue())\n\n\t// Test method with return value\n\tgetValueFunc := counter.GetValue\n\tvalue := getValueFunc()\n\tprintln(\"Value from assigned method:\", value)\n\n\t// Test with return value via parameter\n\tvalue2 := callFunctionWithReturn(counter.GetValue)\n\tprintln(\"Value from method via parameter:\", value2)\n\n\t// Test with value receiver methods\n\tcounter2 := Counter{value: 10}\n\n\tprintln(\"Initial value2:\", counter2.GetValueByValue())\n\n\t// This should NOT modify the original counter2 since it's a value receiver\n\tcallFunction(counter2.IncrementValue)\n\tprintln(\"After calling IncrementValue via parameter (should be unchanged):\", counter2.GetValueByValue())\n\n\t// This should also NOT modify the original counter2\n\tincrementValueFunc := counter2.IncrementValue\n\tincrementValueFunc()\n\tprintln(\"After calling IncrementValue via variable (should be unchanged):\", counter2.GetValueByValue())\n\n\t// Test method with return value on value receiver\n\tgetValueByValueFunc := counter2.GetValueByValue\n\tvalue3 := getValueByValueFunc()\n\tprintln(\"Value from assigned value method:\", value3)\n}\n",
    "tsCode": "// Generated file based on method_binding.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Counter {\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{value?: number}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Counter {\n\t\tconst cloned = new Counter()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Increment(): void {\n\t\tconst c = this\n\t\tc.value++\n\t}\n\n\tpublic GetValue(): number {\n\t\tconst c = this\n\t\treturn c.value\n\t}\n\n\tpublic IncrementValue(): void {\n\t\tconst c = this\n\t\tc.value++\n\t}\n\n\tpublic GetValueByValue(): number {\n\t\tconst c = this\n\t\treturn c.value\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Counter',\n\t  new Counter(),\n\t  [{ name: \"Increment\", args: [], returns: [] }, { name: \"GetValue\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }, { name: \"IncrementValue\", args: [], returns: [] }, { name: \"GetValueByValue\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  Counter,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport function callFunction(fn: (() => void) | null): void {\n\tfn!()\n}\n\nexport function callFunctionWithReturn(fn: (() => number) | null): number {\n\treturn fn!()\n}\n\nexport async function main(): Promise<void> {\n\t// Test with pointer receiver methods\n\tlet counter = new Counter({value: 0})\n\n\t$.println(\"Initial value:\", counter!.GetValue())\n\n\t// Test method binding when passed as parameter\n\tcallFunction(counter!.Increment.bind(counter!))\n\t$.println(\"After calling Increment via parameter:\", counter!.GetValue())\n\n\t// Test method binding when assigned to variable\n\tlet incrementFunc = counter!.Increment.bind(counter!)\n\tincrementFunc!()\n\t$.println(\"After calling Increment via variable:\", counter!.GetValue())\n\n\t// Test method with return value\n\tlet getValueFunc = counter!.GetValue.bind(counter!)\n\tlet value = getValueFunc!()\n\t$.println(\"Value from assigned method:\", value)\n\n\t// Test with return value via parameter\n\tlet value2 = callFunctionWithReturn(counter!.GetValue.bind(counter!))\n\t$.println(\"Value from method via parameter:\", value2)\n\n\t// Test with value receiver methods\n\tlet counter2 = $.markAsStructValue(new Counter({value: 10}))\n\n\t$.println(\"Initial value2:\", counter2.GetValueByValue())\n\n\t// This should NOT modify the original counter2 since it's a value receiver\n\tcallFunction(counter2.IncrementValue.bind($.markAsStructValue(counter2.clone())))\n\t$.println(\"After calling IncrementValue via parameter (should be unchanged):\", counter2.GetValueByValue())\n\n\t// This should also NOT modify the original counter2\n\tlet incrementValueFunc = counter2.IncrementValue.bind($.markAsStructValue(counter2.clone()))\n\tincrementValueFunc!()\n\t$.println(\"After calling IncrementValue via variable (should be unchanged):\", counter2.GetValueByValue())\n\n\t// Test method with return value on value receiver\n\tlet getValueByValueFunc = counter2.GetValueByValue.bind($.markAsStructValue(counter2.clone()))\n\tlet value3 = getValueByValueFunc!()\n\t$.println(\"Value from assigned value method:\", value3)\n}\n\n",
    "expectedOutput": "Initial value: 0\nAfter calling Increment via parameter: 1\nAfter calling Increment via variable: 2\nValue from assigned method: 2\nValue from method via parameter: 2\nInitial value2: 10\nAfter calling IncrementValue via parameter (should be unchanged): 10\nAfter calling IncrementValue via variable (should be unchanged): 10\nValue from assigned value method: 10\n"
  },
  {
    "name": "method_call_on_pointer_receiver",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\n// GetMyString returns the MyString field.\nfunc (m *MyStruct) GetMyString() string {\n\treturn m.MyString\n}\n\nfunc main() {\n\tstructPointer := &MyStruct{MyInt: 4, MyString: \"hello world\"}\n\t// === Method Call on Pointer Receiver ===\n\t// Calling a method with a pointer receiver (*MyStruct) using a pointer variable.\n\tprintln(\"Method call on pointer (structPointer): Expected: hello world, Actual: \" + structPointer.GetMyString())\n}\n",
    "tsCode": "// Generated file based on method_call_on_pointer_receiver.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// GetMyString returns the MyString field.\n\tpublic GetMyString(): string {\n\t\tconst m = this\n\t\treturn m.MyString\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"GetMyString\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet structPointer = new MyStruct({MyInt: 4, MyString: \"hello world\"})\n\t// === Method Call on Pointer Receiver ===\n\t// Calling a method with a pointer receiver (*MyStruct) using a pointer variable.\n\t$.println(\"Method call on pointer (structPointer): Expected: hello world, Actual: \" + structPointer!.GetMyString())\n}\n\n",
    "expectedOutput": "Method call on pointer (structPointer): Expected: hello world, Actual: hello world"
  },
  {
    "name": "method_call_on_pointer_via_value",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt int\n}\n\n// SetValue sets the MyInt field (pointer receiver).\nfunc (m *MyStruct) SetValue(v int) {\n\tm.MyInt = v\n}\n\n// GetValue returns the MyInt field (value receiver for verification).\nfunc (m MyStruct) GetValue() int {\n\treturn m.MyInt\n}\n\nfunc main() {\n\t// Create a struct value\n\tmsValue := MyStruct{MyInt: 100}\n\n\t// === Method Call on Pointer Receiver via Value ===\n\t// Call the pointer-receiver method using the value variable.\n\t// Go implicitly takes the address of msValue (&msValue) to call SetValue.\n\tmsValue.SetValue(200)\n\n\t// Verify the value was modified through the method call.\n\t// Expected: 200\n\tprintln(\"Value after pointer method call via value: Expected: 200, Actual:\", msValue.GetValue())\n}\n",
    "tsCode": "// Generated file based on method_call_on_pointer_via_value.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// SetValue sets the MyInt field (pointer receiver).\n\tpublic SetValue(v: number): void {\n\t\tconst m = this\n\t\tm.MyInt = v\n\t}\n\n\t// GetValue returns the MyInt field (value receiver for verification).\n\tpublic GetValue(): number {\n\t\tconst m = this\n\t\treturn m.MyInt\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"SetValue\", args: [{ name: \"v\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [] }, { name: \"GetValue\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Create a struct value\n\tlet msValue = $.varRef($.markAsStructValue(new MyStruct({MyInt: 100})))\n\n\t// === Method Call on Pointer Receiver via Value ===\n\t// Call the pointer-receiver method using the value variable.\n\t// Go implicitly takes the address of msValue (&msValue) to call SetValue.\n\tmsValue!.value.SetValue(200)\n\n\t// Verify the value was modified through the method call.\n\t// Expected: 200\n\t$.println(\"Value after pointer method call via value: Expected: 200, Actual:\", msValue!.value.GetValue())\n}\n\n",
    "expectedOutput": "Value after pointer method call via value: Expected: 200, Actual: 200"
  },
  {
    "name": "method_call_on_value_receiver",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\n// GetMyString returns the MyString field.\nfunc (m MyStruct) GetMyString() string {\n\treturn m.MyString\n}\n\nfunc main() {\n\tms := MyStruct{MyInt: 1, MyString: \"bar\"}\n\tprintln(\"Method call on value: Expected: bar, Actual:\", ms.GetMyString())\n}\n",
    "tsCode": "// Generated file based on method_call_on_value_receiver.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// GetMyString returns the MyString field.\n\tpublic GetMyString(): string {\n\t\tconst m = this\n\t\treturn m.MyString\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"GetMyString\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet ms = $.markAsStructValue(new MyStruct({MyInt: 1, MyString: \"bar\"}))\n\t$.println(\"Method call on value: Expected: bar, Actual:\", ms.GetMyString())\n}\n\n",
    "expectedOutput": "Method call on value: Expected: bar, Actual: bar"
  },
  {
    "name": "method_call_on_value_via_pointer",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt int\n}\n\n// GetValue returns the MyInt field (value receiver).\nfunc (m MyStruct) GetValue() int {\n\treturn m.MyInt\n}\n\nfunc main() {\n\t// Create a struct value\n\tmsValue := MyStruct{MyInt: 100}\n\t// Create a pointer to the struct value\n\tmsPointer := &msValue\n\n\t// === Method Call on Value Receiver via Pointer ===\n\t// Call the value-receiver method using the pointer variable.\n\t// Go implicitly dereferences msPointer to call GetValue on the value.\n\t// Expected: 100\n\tprintln(\"Value via pointer call: Expected: 100, Actual:\", msPointer.GetValue())\n\n\t// Modify the value through the original value variable\n\tmsValue.MyInt = 200\n\n\t// The pointer still points to the modified value\n\t// Expected: 200\n\tprintln(\"Value via pointer call after modification: Expected: 200, Actual:\", msPointer.GetValue())\n}\n",
    "tsCode": "// Generated file based on method_call_on_value_via_pointer.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// GetValue returns the MyInt field (value receiver).\n\tpublic GetValue(): number {\n\t\tconst m = this\n\t\treturn m.MyInt\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"GetValue\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Create a struct value\n\tlet msValue = $.varRef($.markAsStructValue(new MyStruct({MyInt: 100})))\n\t// Create a pointer to the struct value\n\tlet msPointer = msValue\n\n\t// === Method Call on Value Receiver via Pointer ===\n\t// Call the value-receiver method using the pointer variable.\n\t// Go implicitly dereferences msPointer to call GetValue on the value.\n\t// Expected: 100\n\t$.println(\"Value via pointer call: Expected: 100, Actual:\", msPointer!.value!.GetValue())\n\n\t// Modify the value through the original value variable\n\tmsValue!.value.MyInt = 200\n\n\t// The pointer still points to the modified value\n\t// Expected: 200\n\t$.println(\"Value via pointer call after modification: Expected: 200, Actual:\", msPointer!.value!.GetValue())\n}\n\n",
    "expectedOutput": "Value via pointer call: Expected: 100, Actual: 100\nValue via pointer call after modification: Expected: 200, Actual: 200"
  },
  {
    "name": "method_call_slice_type",
    "goCode": "package main\n\ntype MySlice []int\n\nfunc (s *MySlice) Add(val int) {\n\t*s = append(*s, val)\n}\n\nfunc main() {\n\tvar myList MySlice\n\tmyList.Add(10)\n\tmyList.Add(20)\n\tprintln(\"length:\", len(myList))\n\tprintln(\"first:\", myList[0])\n\tprintln(\"second:\", myList[1])\n}\n",
    "tsCode": "// Generated file based on method_call_slice_type.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MySlice = $.Slice<number>;\n\nexport function MySlice_Add(s: $.VarRef<MySlice>, val: number): void {\n\ts!.value = $.append(s!.value, val)\n}\n\n\nexport async function main(): Promise<void> {\n\tlet myList: $.VarRef<MySlice> = $.varRef(null)\n\tMySlice_Add(myList, 10)\n\tMySlice_Add(myList, 20)\n\t$.println(\"length:\", $.len(myList!.value))\n\t$.println(\"first:\", myList!.value![0])\n\t$.println(\"second:\", myList!.value![1])\n}\n\n",
    "expectedOutput": "length: 2\nfirst: 10\nsecond: 20\n"
  },
  {
    "name": "method_receiver_async_paren",
    "goCode": "package main\n\ntype Thing struct {\n\tvalue int\n}\n\nfunc getFunc() func(*Thing, int) {\n\treturn func(t *Thing, x int) {\n\t\tt.value += x\n\t}\n}\n\n// Use channels to make this async\nfunc (t *Thing) callIt(x int) {\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tgetFunc()(t, x)\n\t\tclose(done)\n\t}()\n\t<-done\n}\n\nfunc main() {\n\tthing := &Thing{value: 10}\n\tthing.callIt(32)\n\tprintln(\"Result:\", thing.value)\n}\n",
    "tsCode": "// Generated file based on method_receiver_async_paren.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Thing {\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{value?: number}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Thing {\n\t\tconst cloned = new Thing()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Use channels to make this async\n\tpublic async callIt(x: number): Promise<void> {\n\t\tconst t = this\n\t\tlet done = $.makeChannel<{  }>(0, {}, 'both')\n\t\tqueueMicrotask(() => {\n\t\t\t;getFunc()!(t, x)\n\t\t\tdone.close()\n\t\t})\n\t\tawait $.chanRecv(done)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Thing',\n\t  new Thing(),\n\t  [{ name: \"callIt\", args: [{ name: \"x\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [] }],\n\t  Thing,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport function getFunc(): ((p0: Thing | null, p1: number) => void) | null {\n\treturn (t: Thing | null, x: number): void => {\n\t\tt!.value += x\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet thing = new Thing({value: 10})\n\tawait thing!.callIt(32)\n\t$.println(\"Result:\", thing!.value)\n}\n\n",
    "expectedOutput": "Result: 42\n"
  },
  {
    "name": "method_receiver_await_paren",
    "goCode": "package main\n\ntype Thing struct {\n\tvalue int\n}\n\nfunc getFunc() func(*Thing, int) {\n\treturn func(t *Thing, x int) {\n\t\tt.value += x\n\t}\n}\n\nfunc (t *Thing) callIt(x int) {\n\tdone := make(chan func(*Thing, int))\n\tgo func() {\n\t\tdone <- getFunc()\n\t\tclose(done)\n\t}()\n\tfn := <-done\n\tfn(t, x)\n}\n\nfunc main() {\n\tthing := &Thing{value: 10}\n\tthing.callIt(32)\n\tprintln(\"Result:\", thing.value)\n}\n",
    "tsCode": "// Generated file based on method_receiver_await_paren.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Thing {\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{value?: number}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Thing {\n\t\tconst cloned = new Thing()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic async callIt(x: number): Promise<void> {\n\t\tconst t = this\n\t\tlet done = $.makeChannel<((p0: Thing | null, p1: number) => void) | null>(0, null, 'both')\n\t\tqueueMicrotask(async () => {\n\t\t\tawait $.chanSend(done, getFunc())\n\t\t\tdone.close()\n\t\t})\n\t\tlet fn = await $.chanRecv(done)\n\t\tfn!(t, x)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Thing',\n\t  new Thing(),\n\t  [{ name: \"callIt\", args: [{ name: \"x\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [] }],\n\t  Thing,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport function getFunc(): ((p0: Thing | null, p1: number) => void) | null {\n\treturn (t: Thing | null, x: number): void => {\n\t\tt!.value += x\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet thing = new Thing({value: 10})\n\tawait thing!.callIt(32)\n\t$.println(\"Result:\", thing!.value)\n}\n\n",
    "expectedOutput": "Result: 42\n"
  },
  {
    "name": "method_receiver_call_return",
    "goCode": "package main\n\ntype Thing struct {\n\tvalue int\n}\n\nfunc getFunc() func(*Thing, int) int {\n\treturn func(t *Thing, x int) int {\n\t\treturn t.value + x\n\t}\n}\n\nfunc (t *Thing) callIt(x int) int {\n\treturn getFunc()(t, x)\n}\n\nfunc main() {\n\tthing := &Thing{value: 10}\n\tresult := thing.callIt(32)\n\tprintln(\"Result:\", result)\n}\n",
    "tsCode": "// Generated file based on method_receiver_call_return.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Thing {\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{value?: number}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Thing {\n\t\tconst cloned = new Thing()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic callIt(x: number): number {\n\t\tconst t = this\n\t\treturn getFunc()!(t, x)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Thing',\n\t  new Thing(),\n\t  [{ name: \"callIt\", args: [{ name: \"x\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  Thing,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport function getFunc(): ((p0: Thing | null, p1: number) => number) | null {\n\treturn (t: Thing | null, x: number): number => {\n\t\treturn t!.value + x\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet thing = new Thing({value: 10})\n\tlet result = thing!.callIt(32)\n\t$.println(\"Result:\", result)\n}\n\n",
    "expectedOutput": "Result: 42\n"
  },
  {
    "name": "method_receiver_paren_line",
    "goCode": "package main\n\ntype Thing struct {\n\tvalue int\n}\n\nfunc getFunc() func(*Thing, int) {\n\treturn func(t *Thing, x int) {\n\t\tt.value += x\n\t}\n}\n\nfunc (t *Thing) callIt(x int) {\n\tgetFunc()(t, x)\n}\n\nfunc main() {\n\tthing := &Thing{value: 10}\n\tthing.callIt(32)\n\tprintln(\"Result:\", thing.value)\n}\n",
    "tsCode": "// Generated file based on method_receiver_paren_line.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Thing {\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{value?: number}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Thing {\n\t\tconst cloned = new Thing()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic callIt(x: number): void {\n\t\tconst t = this\n\t\t;getFunc()!(t, x)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Thing',\n\t  new Thing(),\n\t  [{ name: \"callIt\", args: [{ name: \"x\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [] }],\n\t  Thing,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport function getFunc(): ((p0: Thing | null, p1: number) => void) | null {\n\treturn (t: Thing | null, x: number): void => {\n\t\tt!.value += x\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet thing = new Thing({value: 10})\n\tthing!.callIt(32)\n\t$.println(\"Result:\", thing!.value)\n}\n\n",
    "expectedOutput": "Result: 42\n"
  },
  {
    "name": "method_receiver_shadowing",
    "goCode": "package main\n\ntype Thing struct {\n\tvalue int\n}\n\nfunc getValue() func(*Thing) int {\n\treturn func(t *Thing) int {\n\t\treturn t.value\n\t}\n}\n\nfunc (t *Thing) callFunc() int {\n\treturn getValue()(t)\n}\n\nfunc main() {\n\tt := &Thing{value: 42}\n\tresult := t.callFunc()\n\tprintln(\"Result:\", result)\n}\n",
    "tsCode": "// Generated file based on method_receiver_shadowing.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Thing {\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{value?: number}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Thing {\n\t\tconst cloned = new Thing()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic callFunc(): number {\n\t\tconst t = this\n\t\treturn getValue()!(t)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Thing',\n\t  new Thing(),\n\t  [{ name: \"callFunc\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  Thing,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport function getValue(): ((p0: Thing | null) => number) | null {\n\treturn (t: Thing | null): number => {\n\t\treturn t!.value\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet t = new Thing({value: 42})\n\tlet result = t!.callFunc()\n\t$.println(\"Result:\", result)\n}\n\n",
    "expectedOutput": "Result: 42\n"
  },
  {
    "name": "method_receiver_with_call_expr",
    "goCode": "package main\n\ntype State struct {\n\tvalue int\n}\n\nfunc (s *State) Process() {\n\t// This should generate:\n\t// const s = this\n\t// ;(getProcessor())!(s)\n\t// The semicolon is important to prevent: const s = this(getProcessor())!(s)\n\tgetProcessor()(s)\n}\n\nfunc getProcessor() func(*State) {\n\treturn func(s *State) {\n\t\ts.value = 42\n\t}\n}\n\nfunc main() {\n\tstate := &State{}\n\tstate.Process()\n\tprintln(\"value:\", state.value)\n}\n",
    "tsCode": "// Generated file based on method_receiver_with_call_expr.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class State {\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{value?: number}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): State {\n\t\tconst cloned = new State()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Process(): void {\n\t\tconst s = this\n\t\t;getProcessor()!(s)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.State',\n\t  new State(),\n\t  [{ name: \"Process\", args: [], returns: [] }],\n\t  State,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport function getProcessor(): ((p0: State | null) => void) | null {\n\treturn (s: State | null): void => {\n\t\ts!.value = 42\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet state = new State({})\n\tstate!.Process()\n\t$.println(\"value:\", state!.value)\n}\n\n",
    "expectedOutput": "value: 42\n"
  },
  {
    "name": "method_value_primitive",
    "goCode": "package main\n\n// myInt is a primitive type with a method\ntype myInt int\n\nfunc (m myInt) add(x int) int {\n\treturn int(m) + x\n}\n\nfunc (m myInt) multiply(x, y int) int {\n\treturn int(m) * x * y\n}\n\nfunc main() {\n\tvar n myInt = 5\n\n\t// Method value: binding the receiver to create a function\n\taddFn := n.add\n\tprintln(\"addFn(3):\", addFn(3)) // Should print 8\n\n\tmulFn := n.multiply\n\tprintln(\"mulFn(2, 3):\", mulFn(2, 3)) // Should print 30\n\n\t// Test with different receiver value\n\tvar m myInt = 10\n\taddFn2 := m.add\n\tprintln(\"addFn2(7):\", addFn2(7)) // Should print 17\n}\n",
    "tsCode": "// Generated file based on method_value_primitive.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type myInt = number;\n\nexport function myInt_add(m: myInt, x: number): number {\n\treturn m + x\n}\n\nexport function myInt_multiply(m: myInt, x: number, y: number): number {\n\treturn m * x * y\n}\n\n\nexport async function main(): Promise<void> {\n\tlet n: myInt = 5\n\n\t// Method value: binding the receiver to create a function\n\tlet addFn = ((_p0: number) => myInt_add(n, _p0))\n\t$.println(\"addFn(3):\", addFn!(3)) // Should print 8\n\n\tlet mulFn = ((_p0: number, _p1: number) => myInt_multiply(n, _p0, _p1))\n\t$.println(\"mulFn(2, 3):\", mulFn!(2, 3)) // Should print 30\n\n\t// Test with different receiver value\n\tlet m: myInt = 10\n\tlet addFn2 = ((_p0: number) => myInt_add(m, _p0))\n\t$.println(\"addFn2(7):\", addFn2!(7)) // Should print 17\n}\n\n",
    "expectedOutput": "addFn(3): 8\nmulFn(2, 3): 30\naddFn2(7): 17\n"
  },
  {
    "name": "missing_valueof_error",
    "goCode": "package main\n\n// Test case that replicates the missing valueOf error\n// The issue: if ($.cap(p!.buf) > 64 * 1024) should be if ($.cap(p!.buf.valueOf()) > 64 * 1024)\n\ntype buffer struct {\n\tdata []byte\n}\n\ntype printer struct {\n\tbuf *buffer\n}\n\nfunc (p *printer) free() {\n\t// This should generate: if ($.cap(p!.buf.valueOf()) > 64 * 1024)\n\t// But incorrectly generates: if ($.cap(p!.buf) > 64 * 1024)\n\tif cap(p.buf.data) > 64*1024 {\n\t\tp.buf = nil\n\t} else {\n\t\t// Reset buffer\n\t\tp.buf.data = p.buf.data[:0]\n\t}\n}\n\nfunc (p *printer) checkCapacity() int {\n\t// Another case where valueOf should be used\n\treturn cap(p.buf.data)\n}\n\nfunc (p *printer) getLength() int {\n\t// Another case where valueOf should be used\n\treturn len(p.buf.data)\n}\n\nfunc main() {\n\tbuf := &buffer{data: make([]byte, 0, 100000)}\n\tp := &printer{buf: buf}\n\n\tprintln(\"Initial capacity:\", p.checkCapacity())\n\tprintln(\"Initial length:\", p.getLength())\n\n\t// Add some data\n\tp.buf.data = append(p.buf.data, \"hello world\"...)\n\tprintln(\"After append length:\", p.getLength())\n\n\t// Test free\n\tp.free()\n\tif p.buf != nil {\n\t\tprintln(\"Buffer not freed, capacity:\", p.checkCapacity())\n\t} else {\n\t\tprintln(\"Buffer was freed\")\n\t}\n}\n",
    "tsCode": "// Generated file based on missing_valueof_error.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class buffer {\n\tpublic get data(): $.Bytes {\n\t\treturn this._fields.data.value\n\t}\n\tpublic set data(value: $.Bytes) {\n\t\tthis._fields.data.value = value\n\t}\n\n\tpublic _fields: {\n\t\tdata: $.VarRef<$.Bytes>;\n\t}\n\n\tconstructor(init?: Partial<{data?: $.Bytes}>) {\n\t\tthis._fields = {\n\t\t\tdata: $.varRef(init?.data ?? new Uint8Array(0))\n\t\t}\n\t}\n\n\tpublic clone(): buffer {\n\t\tconst cloned = new buffer()\n\t\tcloned._fields = {\n\t\t\tdata: $.varRef(this._fields.data.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.buffer',\n\t  new buffer(),\n\t  [],\n\t  buffer,\n\t  {\"data\": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } }}\n\t);\n}\n\nexport class printer {\n\tpublic get buf(): buffer | null {\n\t\treturn this._fields.buf.value\n\t}\n\tpublic set buf(value: buffer | null) {\n\t\tthis._fields.buf.value = value\n\t}\n\n\tpublic _fields: {\n\t\tbuf: $.VarRef<buffer | null>;\n\t}\n\n\tconstructor(init?: Partial<{buf?: buffer | null}>) {\n\t\tthis._fields = {\n\t\t\tbuf: $.varRef(init?.buf ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): printer {\n\t\tconst cloned = new printer()\n\t\tcloned._fields = {\n\t\t\tbuf: $.varRef(this._fields.buf.value ? $.markAsStructValue(this._fields.buf.value.clone()) : null)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic free(): void {\n\t\tconst p = this\n\t\tif ($.cap(p.buf!.data) > 64 * 1024) {\n\t\t\tp.buf = null\n\t\t} else {\n\t\t\t// Reset buffer\n\t\t\tp.buf!.data = $.goSlice(p.buf!.data, undefined, 0)\n\t\t}\n\t}\n\n\tpublic checkCapacity(): number {\n\t\tconst p = this\n\t\treturn $.cap(p.buf!.data)\n\t}\n\n\tpublic getLength(): number {\n\t\tconst p = this\n\t\treturn $.len(p.buf!.data)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.printer',\n\t  new printer(),\n\t  [{ name: \"free\", args: [], returns: [] }, { name: \"checkCapacity\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }, { name: \"getLength\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  printer,\n\t  {\"buf\": { kind: $.TypeKind.Pointer, elemType: \"buffer\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet buf = new buffer({data: $.makeSlice<number>(0, 100000, 'byte')})\n\tlet p = new printer({buf: buf})\n\n\t$.println(\"Initial capacity:\", p!.checkCapacity())\n\t$.println(\"Initial length:\", p!.getLength())\n\n\t// Add some data\n\tp!.buf!.data = $.append(p!.buf!.data, ...$.stringToBytes(\"hello world\"))\n\t$.println(\"After append length:\", p!.getLength())\n\n\t// Test free\n\tp!.free()\n\tif (p!.buf != null) {\n\t\t$.println(\"Buffer not freed, capacity:\", p!.checkCapacity())\n\t} else {\n\t\t$.println(\"Buffer was freed\")\n\t}\n}\n\n",
    "expectedOutput": "Initial capacity: 100000\nInitial length: 0\nAfter append length: 11\nBuffer was freed\n"
  },
  {
    "name": "multi_return_same_type",
    "goCode": "package main\n\n// addSub returns sum and difference with named returns of same type\nfunc addSub(a, b int) (sum, diff int) {\n\tsum = a + b\n\tdiff = a - b\n\treturn\n}\n\n// swap returns two values of the same type\nfunc swap(a, b int) (x, y int) {\n\treturn b, a\n}\n\n// minmax returns min and max from two values\nfunc minmax(a, b int) (min, max int) {\n\tif a < b {\n\t\treturn a, b\n\t}\n\treturn b, a\n}\n\nfunc main() {\n\tsum, diff := addSub(17, 5)\n\tprintln(\"addSub(17, 5):\", sum, diff) // 22, 12\n\n\tx, y := swap(10, 20)\n\tprintln(\"swap(10, 20):\", x, y) // 20, 10\n\n\tmin, max := minmax(7, 3)\n\tprintln(\"minmax(7, 3):\", min, max) // 3, 7\n}\n",
    "tsCode": "// Generated file based on multi_return_same_type.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\n// addSub returns sum and difference with named returns of same type\nexport function addSub(a: number, b: number): [number, number] {\n\tlet sum: number = 0\n\tlet diff: number = 0\n\t{\n\t\tsum = a + b\n\t\tdiff = a - b\n\t\treturn [sum, diff]\n\t}\n}\n\n// swap returns two values of the same type\nexport function swap(a: number, b: number): [number, number] {\n\tlet x: number = 0\n\tlet y: number = 0\n\t{\n\t\treturn [b, a]\n\t}\n}\n\n// minmax returns min and max from two values\nexport function minmax(a: number, b: number): [number, number] {\n\tlet min: number = 0\n\tlet max: number = 0\n\t{\n\t\tif (a < b) {\n\t\t\treturn [a, b]\n\t\t}\n\t\treturn [b, a]\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet [sum, diff] = addSub(17, 5)\n\t$.println(\"addSub(17, 5):\", sum, diff) // 22, 12\n\n\tlet [x, y] = swap(10, 20)\n\t$.println(\"swap(10, 20):\", x, y) // 20, 10\n\n\tlet [min, max] = minmax(7, 3)\n\t$.println(\"minmax(7, 3):\", min, max) // 3, 7\n}\n\n",
    "expectedOutput": "addSub(17, 5): 22 12\nswap(10, 20): 20 10\nminmax(7, 3): 3 7\n"
  },
  {
    "name": "multiple_return_values",
    "goCode": "package main\n\nfunc multipleReturnValues() (int, string, bool) {\n\treturn 42, \"hello\", true\n}\n\nfunc main() {\n\ta, b, c := multipleReturnValues()\n\tprintln(a)\n\tprintln(b)\n\tprintln(c)\n\n\tx, _, z := multipleReturnValues()\n\tprintln(x)\n\tprintln(z)\n\n\t_, y, _ := multipleReturnValues()\n\tprintln(y)\n}\n",
    "tsCode": "// Generated file based on multiple_return_values.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function multipleReturnValues(): [number, string, boolean] {\n\treturn [42, \"hello\", true]\n}\n\nexport async function main(): Promise<void> {\n\tlet [a, b, c] = multipleReturnValues()\n\t$.println(a)\n\t$.println(b)\n\t$.println(c)\n\n\tlet [x, , z] = multipleReturnValues()\n\t$.println(x)\n\t$.println(z)\n\n\tlet [, y, ] = multipleReturnValues()\n\t$.println(y)\n}\n\n",
    "expectedOutput": "42\nhello\ntrue\n42\ntrue\nhello"
  },
  {
    "name": "named_function_type_call",
    "goCode": "package main\n\nimport (\n\t\"path/filepath\"\n)\n\n// Custom FileInfo interface (simplified version of os.FileInfo)\ntype FileInfo interface {\n\tName() string\n\tSize() int64\n\tIsDir() bool\n}\n\n// Simulate billy.Filesystem interface\ntype Filesystem interface {\n\tReadDir(path string) ([]FileInfo, error)\n}\n\n// MockFileInfo implements FileInfo for testing\ntype MockFileInfo struct {\n\tname  string\n\tsize  int64\n\tisDir bool\n}\n\nfunc (m *MockFileInfo) Name() string { return m.name }\nfunc (m *MockFileInfo) Size() int64  { return m.size }\nfunc (m *MockFileInfo) IsDir() bool  { return m.isDir }\n\n// MockFilesystem implements Filesystem for testing\ntype MockFilesystem struct{}\n\nfunc (m *MockFilesystem) ReadDir(path string) ([]FileInfo, error) {\n\treturn []FileInfo{\n\t\t&MockFileInfo{name: \"file1.txt\", size: 100, isDir: false},\n\t\t&MockFileInfo{name: \"subdir\", size: 0, isDir: true},\n\t}, nil\n}\n\n// Custom WalkFunc type to match filepath.WalkFunc signature but with our FileInfo\ntype WalkFunc func(path string, info FileInfo, err error) error\n\n// walk demonstrates the issue with named function types\n// This uses filepath.WalkFunc which is a named function type from external package\nfunc walk(fs Filesystem, path string, info FileInfo, walkFn filepath.WalkFunc) error { //nolint:unused\n\t// Test case 1: Direct call to named function type parameter\n\t// This should generate: walkFn!(path, info, nil)\n\t// But currently generates: walkFn(path, info, nil) - missing !\n\n\t// We need to convert our FileInfo to os.FileInfo for filepath.WalkFunc\n\t// For this test, we'll use a simpler approach with our own WalkFunc\n\treturn walkWithCustomFunc(fs, path, info, func(p string, i FileInfo, e error) error {\n\t\t// This simulates the issue by calling filepath.WalkFunc indirectly\n\t\treturn nil\n\t})\n}\n\n// walkWithCustomFunc uses our custom WalkFunc type\nfunc walkWithCustomFunc(fs Filesystem, path string, info FileInfo, walkFn WalkFunc) error {\n\t// Test case 1: Direct call to named function type parameter\n\t// This should generate: walkFn!(path, info, nil)\n\t// But currently generates: walkFn(path, info, nil) - missing !\n\tif err := walkFn(path, info, nil); err != nil && err != filepath.SkipDir {\n\t\treturn err\n\t}\n\n\t// Test case 2: Call with variable error\n\tvar walkErr error = nil\n\t// This should also generate: walkFn!(path, info, walkErr)\n\tif err := walkFn(path, info, walkErr); err != nil && err != filepath.SkipDir {\n\t\treturn err\n\t}\n\n\t// Test case 3: Call in if statement condition\n\t// This should generate: walkFn!(path, info, nil)\n\tif walkFn(path, info, nil) != nil {\n\t\treturn filepath.SkipDir\n\t}\n\n\treturn nil\n}\n\n// Additional test with different named function type\nfunc processFiles(pattern string, fn func(string) error) error {\n\t// Test case 4: Anonymous function type parameter (for comparison)\n\t// This should also have ! operator when called\n\treturn fn(pattern)\n}\n\n// Test with multiple named function types\nfunc multiCallback(walkFn WalkFunc, processFn func(string) error) error {\n\t// Test case 5: Multiple function parameters\n\t// Both should generate ! operators\n\tif err := walkFn(\"test\", nil, nil); err != nil {\n\t\treturn err\n\t}\n\treturn processFn(\"test\")\n}\n\nfunc main() {\n\tfs := &MockFilesystem{}\n\tfileInfo := &MockFileInfo{name: \"test.txt\", size: 50, isDir: false}\n\n\t// Test the walk function with custom WalkFunc\n\twalkFunc := func(path string, info FileInfo, err error) error {\n\t\tif info != nil {\n\t\t\tprintln(\"Walking:\", path, \"size:\", info.Size())\n\t\t}\n\t\tif err != nil {\n\t\t\tprintln(\"Error:\", err.Error())\n\t\t}\n\t\treturn nil\n\t}\n\n\terr := walkWithCustomFunc(fs, \"/test\", fileInfo, walkFunc)\n\tif err != nil {\n\t\tprintln(\"Walk error:\", err.Error())\n\t}\n\n\t// Test with processFiles\n\tprocessFunc := func(pattern string) error {\n\t\tprintln(\"Processing pattern:\", pattern)\n\t\treturn nil\n\t}\n\n\terr2 := processFiles(\"*.go\", processFunc)\n\tif err2 != nil {\n\t\tprintln(\"Process error:\", err2.Error())\n\t}\n\n\t// Test with multiCallback\n\terr3 := multiCallback(walkFunc, processFunc)\n\tif err3 != nil {\n\t\tprintln(\"Multi callback error:\", err3.Error())\n\t}\n}\n",
    "tsCode": "// Generated file based on named_function_type_call.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as filepath from \"@goscript/path/filepath/index.js\"\n\nexport type FileInfo = null | {\n\tIsDir(): boolean\n\tName(): string\n\tSize(): number\n}\n\n$.registerInterfaceType(\n  'main.FileInfo',\n  null, // Zero value for interface is null\n  [{ name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }]\n);\n\nexport type Filesystem = null | {\n\tReadDir(path: string): [$.Slice<FileInfo>, $.GoError]\n}\n\n$.registerInterfaceType(\n  'main.Filesystem',\n  null, // Zero value for interface is null\n  [{ name: \"ReadDir\", args: [{ name: \"path\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Slice, elemType: \"FileInfo\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class MockFileInfo {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._fields.size.value\n\t}\n\tpublic set size(value: number) {\n\t\tthis._fields.size.value = value\n\t}\n\n\tpublic get isDir(): boolean {\n\t\treturn this._fields.isDir.value\n\t}\n\tpublic set isDir(value: boolean) {\n\t\tthis._fields.isDir.value = value\n\t}\n\n\tpublic _fields: {\n\t\tname: $.VarRef<string>;\n\t\tsize: $.VarRef<number>;\n\t\tisDir: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{isDir?: boolean, name?: string, size?: number}>) {\n\t\tthis._fields = {\n\t\t\tname: $.varRef(init?.name ?? \"\"),\n\t\t\tsize: $.varRef(init?.size ?? 0),\n\t\t\tisDir: $.varRef(init?.isDir ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): MockFileInfo {\n\t\tconst cloned = new MockFileInfo()\n\t\tcloned._fields = {\n\t\t\tname: $.varRef(this._fields.name.value),\n\t\t\tsize: $.varRef(this._fields.size.value),\n\t\t\tisDir: $.varRef(this._fields.isDir.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Name(): string {\n\t\tconst m = this\n\t\treturn m.name\n\t}\n\n\tpublic Size(): number {\n\t\tconst m = this\n\t\treturn m.size\n\t}\n\n\tpublic IsDir(): boolean {\n\t\tconst m = this\n\t\treturn m.isDir\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MockFileInfo',\n\t  new MockFileInfo(),\n\t  [{ name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }, { name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }],\n\t  MockFileInfo,\n\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"size\": { kind: $.TypeKind.Basic, name: \"int64\" }, \"isDir\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\nexport class MockFilesystem {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MockFilesystem {\n\t\tconst cloned = new MockFilesystem()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic ReadDir(path: string): [$.Slice<FileInfo>, $.GoError] {\n\t\treturn [$.arrayToSlice<FileInfo>([new MockFileInfo({isDir: false, name: \"file1.txt\", size: 100}), new MockFileInfo({isDir: true, name: \"subdir\", size: 0})]), null]\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MockFilesystem',\n\t  new MockFilesystem(),\n\t  [{ name: \"ReadDir\", args: [{ name: \"path\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Slice, elemType: \"FileInfo\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  MockFilesystem,\n\t  {}\n\t);\n}\n\nexport type WalkFunc = ((path: string, info: FileInfo, err: $.GoError) => $.GoError) | null;\n\n// walk demonstrates the issue with named function types\n// This uses filepath.WalkFunc which is a named function type from external package\nexport function walk(fs: Filesystem, path: string, info: FileInfo, walkFn: filepath.WalkFunc | null): $.GoError {\n\t//nolint:unused\n\t// Test case 1: Direct call to named function type parameter\n\t// This should generate: walkFn!(path, info, nil)\n\t// But currently generates: walkFn(path, info, nil) - missing !\n\n\t// We need to convert our FileInfo to os.FileInfo for filepath.WalkFunc\n\t// For this test, we'll use a simpler approach with our own WalkFunc\n\n\t// This simulates the issue by calling filepath.WalkFunc indirectly\n\treturn walkWithCustomFunc(fs, path, info, (p: string, i: FileInfo, e: $.GoError): $.GoError => {\n\t\t// This simulates the issue by calling filepath.WalkFunc indirectly\n\t\treturn null\n\t})\n}\n\n// walkWithCustomFunc uses our custom WalkFunc type\nexport function walkWithCustomFunc(fs: Filesystem, path: string, info: FileInfo, walkFn: WalkFunc | null): $.GoError {\n\t// Test case 1: Direct call to named function type parameter\n\t// This should generate: walkFn!(path, info, nil)\n\t// But currently generates: walkFn(path, info, nil) - missing !\n\t{\n\t\tlet err = walkFn!(path, info, null)\n\t\tif (err != null && err != filepath.SkipDir) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Test case 2: Call with variable error\n\tlet walkErr: $.GoError = null\n\t// This should also generate: walkFn!(path, info, walkErr)\n\t{\n\t\tlet err = walkFn!(path, info, walkErr)\n\t\tif (err != null && err != filepath.SkipDir) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Test case 3: Call in if statement condition\n\t// This should generate: walkFn!(path, info, nil)\n\tif (walkFn!(path, info, null) != null) {\n\t\treturn filepath.SkipDir\n\t}\n\n\treturn null\n}\n\n// Additional test with different named function type\nexport function processFiles(pattern: string, fn: ((p0: string) => $.GoError) | null): $.GoError {\n\t// Test case 4: Anonymous function type parameter (for comparison)\n\t// This should also have ! operator when called\n\treturn fn!(pattern)\n}\n\n// Test with multiple named function types\nexport function multiCallback(walkFn: WalkFunc | null, processFn: ((p0: string) => $.GoError) | null): $.GoError {\n\t// Test case 5: Multiple function parameters\n\t// Both should generate ! operators\n\t{\n\t\tlet err = walkFn!(\"test\", null, null)\n\t\tif (err != null) {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn processFn!(\"test\")\n}\n\nexport async function main(): Promise<void> {\n\tlet fs = new MockFilesystem({})\n\tlet fileInfo = new MockFileInfo({isDir: false, name: \"test.txt\", size: 50})\n\n\t// Test the walk function with custom WalkFunc\n\tlet walkFunc = (path: string, info: FileInfo, err: $.GoError): $.GoError => {\n\t\tif (info != null) {\n\t\t\t$.println(\"Walking:\", path, \"size:\", info!.Size())\n\t\t}\n\t\tif (err != null) {\n\t\t\t$.println(\"Error:\", err!.Error())\n\t\t}\n\t\treturn null\n\t}\n\n\tlet err = walkWithCustomFunc(fs, \"/test\", fileInfo, walkFunc)\n\tif (err != null) {\n\t\t$.println(\"Walk error:\", err!.Error())\n\t}\n\n\t// Test with processFiles\n\tlet processFunc = (pattern: string): $.GoError => {\n\t\t$.println(\"Processing pattern:\", pattern)\n\t\treturn null\n\t}\n\n\tlet err2 = processFiles(\"*.go\", processFunc)\n\tif (err2 != null) {\n\t\t$.println(\"Process error:\", err2!.Error())\n\t}\n\n\t// Test with multiCallback\n\tlet err3 = multiCallback(walkFunc, processFunc)\n\tif (err3 != null) {\n\t\t$.println(\"Multi callback error:\", err3!.Error())\n\t}\n}\n\n",
    "expectedOutput": "Walking: /test size: 50\nWalking: /test size: 50\nWalking: /test size: 50\nProcessing pattern: *.go\nProcessing pattern: test\n"
  },
  {
    "name": "named_return_method",
    "goCode": "package main\n\ntype content struct {\n\tbytes []byte\n}\n\nfunc (c *content) ReadAt(b []byte, off int64) (n int, err error) {\n\tif off < 0 || off >= int64(len(c.bytes)) {\n\t\terr = nil // Simulate an error scenario\n\t\treturn\n\t}\n\n\tl := int64(len(b))\n\tif off+l > int64(len(c.bytes)) {\n\t\tl = int64(len(c.bytes)) - off\n\t}\n\n\tbtr := c.bytes[off : off+l]\n\tn = copy(b, btr)\n\treturn\n}\n\nfunc (c *content) ProcessData(input int) (result int, status string, valid bool) {\n\tresult = input * 2\n\tif input > 10 {\n\t\tstatus = \"high\"\n\t\tvalid = true\n\t} else if input > 0 {\n\t\tstatus = \"low\"\n\t\tvalid = true\n\t} else {\n\t\t// status and valid will be zero values\n\t\tstatus = \"invalid\"\n\t}\n\treturn\n}\n\nfunc main() {\n\tc := &content{\n\t\tbytes: []byte(\"Hello, World!\"),\n\t}\n\n\t// Test ReadAt method\n\tbuf := make([]byte, 5)\n\tn1, err1 := c.ReadAt(buf, 0)\n\tprintln(n1) // Expected: 5\n\tif err1 == nil {\n\t\tprintln(\"nil\") // Expected: nil\n\t} else {\n\t\tprintln(\"error\")\n\t}\n\tprintln(string(buf)) // Expected: Hello\n\n\t// Test ReadAt with different offset\n\tbuf2 := make([]byte, 6)\n\tn2, err2 := c.ReadAt(buf2, 7)\n\tprintln(n2) // Expected: 6\n\tif err2 == nil {\n\t\tprintln(\"nil\") // Expected: nil\n\t} else {\n\t\tprintln(\"error\")\n\t}\n\tprintln(string(buf2)) // Expected: World!\n\n\t// Test ProcessData method\n\tr1, s1, v1 := c.ProcessData(15)\n\tprintln(r1) // Expected: 30\n\tprintln(s1) // Expected: high\n\tprintln(v1) // Expected: true\n\n\tr2, s2, v2 := c.ProcessData(5)\n\tprintln(r2) // Expected: 10\n\tprintln(s2) // Expected: low\n\tprintln(v2) // Expected: true\n\n\tr3, s3, v3 := c.ProcessData(-1)\n\tprintln(r3) // Expected: -2\n\tprintln(s3) // Expected: invalid\n\tprintln(v3) // Expected: false\n}\n",
    "tsCode": "// Generated file based on named_return_method.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class content {\n\tpublic get bytes(): $.Bytes {\n\t\treturn this._fields.bytes.value\n\t}\n\tpublic set bytes(value: $.Bytes) {\n\t\tthis._fields.bytes.value = value\n\t}\n\n\tpublic _fields: {\n\t\tbytes: $.VarRef<$.Bytes>;\n\t}\n\n\tconstructor(init?: Partial<{bytes?: $.Bytes}>) {\n\t\tthis._fields = {\n\t\t\tbytes: $.varRef(init?.bytes ?? new Uint8Array(0))\n\t\t}\n\t}\n\n\tpublic clone(): content {\n\t\tconst cloned = new content()\n\t\tcloned._fields = {\n\t\t\tbytes: $.varRef(this._fields.bytes.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic ReadAt(b: $.Bytes, off: number): [number, $.GoError] {\n\t\tconst c = this\n\t\tlet n: number = 0\n\t\tlet err: $.GoError = null\n\t\tif (off < 0 || off >= ($.len(c.bytes) as number)) {\n\t\t\terr = null // Simulate an error scenario\n\t\t\treturn [n, err]\n\t\t}\n\t\tlet l = ($.len(b) as number)\n\t\tif (off + l > ($.len(c.bytes) as number)) {\n\t\t\tl = ($.len(c.bytes) as number) - off\n\t\t}\n\t\tlet btr = $.goSlice(c.bytes, off, off + l)\n\t\tn = $.copy(b, btr)\n\t\treturn [n, err]\n\t}\n\n\tpublic ProcessData(input: number): [number, string, boolean] {\n\t\tlet result: number = 0\n\t\tlet status: string = \"\"\n\t\tlet valid: boolean = false\n\t\tresult = input * 2\n\t\tif (input > 10) {\n\t\t\tstatus = \"high\"\n\t\t\tvalid = true\n\t\t} else if (input > 0) {\n\t\t\tstatus = \"low\"\n\t\t\tvalid = true\n\t\t} else {\n\t\t\t// status and valid will be zero values\n\t\t\tstatus = \"invalid\"\n\t\t}\n\t\treturn [result, status, valid]\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.content',\n\t  new content(),\n\t  [{ name: \"ReadAt\", args: [{ name: \"b\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }, { name: \"off\", type: { kind: $.TypeKind.Basic, name: \"int64\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"ProcessData\", args: [{ name: \"input\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Basic, name: \"string\" } }, { type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }],\n\t  content,\n\t  {\"bytes\": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet c = new content({bytes: $.stringToBytes(\"Hello, World!\")})\n\n\t// Test ReadAt method\n\tlet buf = new Uint8Array(5)\n\tlet [n1, err1] = c!.ReadAt(buf, 0)\n\t$.println(n1) // Expected: 5\n\n\t// Expected: nil\n\tif (err1 == null) {\n\t\t$.println(\"nil\") // Expected: nil\n\t} else {\n\t\t$.println(\"error\")\n\t}\n\t$.println($.bytesToString(buf)) // Expected: Hello\n\n\t// Test ReadAt with different offset\n\tlet buf2 = new Uint8Array(6)\n\tlet [n2, err2] = c!.ReadAt(buf2, 7)\n\t$.println(n2) // Expected: 6\n\n\t// Expected: nil\n\tif (err2 == null) {\n\t\t$.println(\"nil\") // Expected: nil\n\t} else {\n\t\t$.println(\"error\")\n\t}\n\t$.println($.bytesToString(buf2)) // Expected: World!\n\n\t// Test ProcessData method\n\tlet [r1, s1, v1] = c!.ProcessData(15)\n\t$.println(r1) // Expected: 30\n\t$.println(s1) // Expected: high\n\t$.println(v1) // Expected: true\n\n\tlet [r2, s2, v2] = c!.ProcessData(5)\n\t$.println(r2) // Expected: 10\n\t$.println(s2) // Expected: low\n\t$.println(v2) // Expected: true\n\n\tlet [r3, s3, v3] = c!.ProcessData(-1)\n\t$.println(r3) // Expected: -2\n\t$.println(s3) // Expected: invalid\n\t$.println(v3) // Expected: false\n}\n\n",
    "expectedOutput": "5\nnil\nHello\n6\nnil\nWorld!\n30\nhigh\ntrue\n10\nlow\ntrue\n-2\ninvalid\nfalse "
  },
  {
    "name": "named_return_multiple",
    "goCode": "package main\n\n// Test function with multiple named return values\nfunc processValues(input int) (num int, text string, ok bool) {\n\tnum = input * 2\n\tif input > 5 {\n\t\ttext = \"greater than five\"\n\t\tok = true\n\t} else {\n\t\ttext = \"five or less\"\n\t\t// ok remains false (its zero value)\n\t}\n\treturn // Naked return\n}\n\nfunc main() {\n\tn1, t1, o1 := processValues(10)\n\tprintln(n1) // Expected: 20\n\tprintln(t1) // Expected: greater than five\n\tprintln(o1) // Expected: true\n\n\tn2, t2, o2 := processValues(3)\n\tprintln(n2) // Expected: 6\n\tprintln(t2) // Expected: five or less\n\tprintln(o2) // Expected: false\n\n\t// Test with an anonymous function and potentially unassigned named returns\n\tn3, t3, o3 := func(val int) (resInt int, resStr string, resBool bool) {\n\t\tif val == 1 {\n\t\t\tresInt = 100\n\t\t\t// resStr and resBool are not assigned, should be zero values\n\t\t} else if val == 2 {\n\t\t\tresInt = 200\n\t\t\tresStr = \"set string\"\n\t\t\t// resBool is not assigned, should be zero value\n\t\t} else {\n\t\t\t// all are unassigned, should be zero values\n\t\t}\n\t\treturn\n\t}(1)\n\n\tprintln(n3) // Expected: 100\n\tprintln(t3) // Expected: \"\" (empty string)\n\tprintln(o3) // Expected: false\n\n\tn4, t4, o4 := func(val int) (resInt int, resStr string, resBool bool) {\n\t\tif val == 1 {\n\t\t\tresInt = 100\n\t\t} else if val == 2 {\n\t\t\tresInt = 200\n\t\t\tresStr = \"set string for val 2\"\n\t\t\t// resBool is not assigned\n\t\t} else {\n\t\t\t// all are unassigned\n\t\t}\n\t\treturn\n\t}(2)\n\n\tprintln(n4) // Expected: 200\n\tprintln(t4) // Expected: \"set string for val 2\"\n\tprintln(o4) // Expected: false\n\n\tn5, t5, o5 := func(val int) (resInt int, resStr string, resBool bool) {\n\t\tif val == 1 {\n\t\t\tresInt = 100\n\t\t} else if val == 2 {\n\t\t\tresInt = 200\n\t\t\tresStr = \"set string for val 2\"\n\t\t} else {\n\t\t\t// all are unassigned here, so will take zero values\n\t\t}\n\t\treturn\n\t}(3)\n\n\tprintln(n5) // Expected: 0\n\tprintln(t5) // Expected: \"\"\n\tprintln(o5) // Expected: false\n}\n",
    "tsCode": "// Generated file based on named_return_multiple.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\n// Test function with multiple named return values\nexport function processValues(input: number): [number, string, boolean] {\n\tlet num: number = 0\n\tlet text: string = \"\"\n\tlet ok: boolean = false\n\t{\n\t\tnum = input * 2\n\n\t\t// ok remains false (its zero value)\n\t\tif (input > 5) {\n\t\t\ttext = \"greater than five\"\n\t\t\tok = true\n\t\t} else {\n\n\t\t\t// ok remains false (its zero value)\n\t\t\ttext = \"five or less\"\n\t\t\t// ok remains false (its zero value)\n\t\t}\n\t\treturn [num, text, ok]\n\t}\n}\n\nexport async function main(): Promise<void> {\n\tlet [n1, t1, o1] = processValues(10)\n\t$.println(n1) // Expected: 20\n\t$.println(t1) // Expected: greater than five\n\t$.println(o1) // Expected: true\n\n\tlet [n2, t2, o2] = processValues(3)\n\t$.println(n2) // Expected: 6\n\t$.println(t2) // Expected: five or less\n\t$.println(o2) // Expected: false\n\n\t// Test with an anonymous function and potentially unassigned named returns\n\n\t// resStr and resBool are not assigned, should be zero values\n\n\t// resBool is not assigned, should be zero value\n\n\t// all are unassigned, should be zero values\n\tlet [n3, t3, o3] = ((val: number): [number, string, boolean] => {\n\t\tlet resInt: number = 0\n\t\tlet resStr: string = \"\"\n\t\tlet resBool: boolean = false\n\t\t{\n\n\t\t\t// resStr and resBool are not assigned, should be zero values\n\n\t\t\t// resBool is not assigned, should be zero value\n\t\t\tif (val == 1) {\n\t\t\t\tresInt = 100\n\n\t\t\t} else if (val == 2) {\n\t\t\t\tresInt = 200\n\t\t\t\tresStr = \"set string\"\n\n\t\t\t} else {\n\n\t\t\t}\n\t\t\t// all are unassigned, should be zero values\n\n\t\t\treturn [resInt, resStr, resBool]\n\t\t}})(1)\n\n\t$.println(n3) // Expected: 100\n\t$.println(t3) // Expected: \"\" (empty string)\n\t$.println(o3) // Expected: false\n\n\t// resBool is not assigned\n\n\t// all are unassigned\n\tlet [n4, t4, o4] = ((val: number): [number, string, boolean] => {\n\t\tlet resInt: number = 0\n\t\tlet resStr: string = \"\"\n\t\tlet resBool: boolean = false\n\t\t{\n\n\t\t\t// resBool is not assigned\n\t\t\tif (val == 1) {\n\t\t\t\tresInt = 100\n\t\t\t} else if (val == 2) {\n\t\t\t\tresInt = 200\n\t\t\t\tresStr = \"set string for val 2\"\n\n\t\t\t} else {\n\n\t\t\t}\n\t\t\t// all are unassigned\n\n\t\t\treturn [resInt, resStr, resBool]\n\t\t}})(2)\n\n\t$.println(n4) // Expected: 200\n\t$.println(t4) // Expected: \"set string for val 2\"\n\t$.println(o4) // Expected: false\n\n\t// all are unassigned here, so will take zero values\n\tlet [n5, t5, o5] = ((val: number): [number, string, boolean] => {\n\t\tlet resInt: number = 0\n\t\tlet resStr: string = \"\"\n\t\tlet resBool: boolean = false\n\t\t{\n\t\t\tif (val == 1) {\n\t\t\t\tresInt = 100\n\t\t\t} else if (val == 2) {\n\t\t\t\tresInt = 200\n\t\t\t\tresStr = \"set string for val 2\"\n\t\t\t} else {\n\n\t\t\t}\n\t\t\t// all are unassigned here, so will take zero values\n\n\t\t\treturn [resInt, resStr, resBool]\n\t\t}})(3)\n\n\t$.println(n5) // Expected: 0\n\t$.println(t5) // Expected: \"\"\n\t$.println(o5) // Expected: false\n}\n\n",
    "expectedOutput": "20\ngreater than five\ntrue\n6\nfive or less\nfalse\n100\n\nfalse\n200\nset string for val 2\nfalse\n0\n\nfalse\n"
  },
  {
    "name": "named_slice_wrapper",
    "goCode": "package main\n\nimport \"os\"\n\ntype ByName []os.FileInfo\n\nfunc (a ByName) Len() int           { return len(a) }\nfunc (a ByName) Less(i, j int) bool { return a[i].Name() < a[j].Name() }\nfunc (a ByName) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n\nfunc main() {\n\t// Create a ByName instance to test the wrapper\n\tvar files ByName = make([]os.FileInfo, 2)\n\tprintln(\"Length:\", files.Len())\n\n\t// Test type conversion\n\tvar slice []os.FileInfo = []os.FileInfo(files)\n\tprintln(\"Slice length:\", len(slice))\n}\n",
    "tsCode": "// Generated file based on named_slice_wrapper.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nexport type ByName = $.Slice<null | os.FileInfo>;\n\nexport function ByName_Len(a: ByName): number {\n\treturn $.len(a)\n}\n\nexport function ByName_Less(a: ByName, i: number, j: number): boolean {\n\treturn a![i]!.Name() < a![j]!.Name()\n}\n\nexport function ByName_Swap(a: ByName, i: number, j: number): void {\n\t;[a![i], a![j]] = [a![j], a![i]]\n}\n\n\nexport async function main(): Promise<void> {\n\t// Create a ByName instance to test the wrapper\n\tlet files: ByName = $.makeSlice<os.FileInfo>(2)\n\t$.println(\"Length:\", ByName_Len(files))\n\n\t// Test type conversion\n\tlet slice: $.Slice<null | os.FileInfo> = files\n\t$.println(\"Slice length:\", $.len(slice))\n}\n\n",
    "expectedOutput": "Length: 2\nSlice length: 2 "
  },
  {
    "name": "named_type_wrapper",
    "goCode": "package main\n\n// Test named type that should generate a wrapper class\ntype MyFileMode int\n\n// Add a method to trigger wrapper class generation\nfunc (m MyFileMode) String() string {\n\treturn \"mode\"\n}\n\n// Test struct using the named type\ntype FileStatus struct {\n\tmode MyFileMode\n\tsize int64\n}\n\nfunc main() {\n\t// Test using the named type directly\n\tvar mode MyFileMode = 0o644\n\tprintln(\"Mode value:\", int(mode))\n\tprintln(\"Mode string:\", mode.String())\n\n\t// Test using in struct\n\tstatus := FileStatus{\n\t\tmode: MyFileMode(0o755),\n\t\tsize: 1024,\n\t}\n\n\tprintln(\"Status mode:\", int(status.mode))\n\tprintln(\"Status size:\", status.size)\n\n\t// Test type assertion and conversion\n\tvar genericMode MyFileMode = MyFileMode(0o777)\n\tprintln(\"Generic mode:\", int(genericMode))\n}\n",
    "tsCode": "// Generated file based on named_type_wrapper.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyFileMode = number;\n\nexport function MyFileMode_String(m: MyFileMode): string {\n\treturn \"mode\"\n}\n\n\nexport class FileStatus {\n\tpublic get mode(): MyFileMode {\n\t\treturn this._fields.mode.value\n\t}\n\tpublic set mode(value: MyFileMode) {\n\t\tthis._fields.mode.value = value\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._fields.size.value\n\t}\n\tpublic set size(value: number) {\n\t\tthis._fields.size.value = value\n\t}\n\n\tpublic _fields: {\n\t\tmode: $.VarRef<MyFileMode>;\n\t\tsize: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{mode?: MyFileMode, size?: number}>) {\n\t\tthis._fields = {\n\t\t\tmode: $.varRef(init?.mode ?? 0 as MyFileMode),\n\t\t\tsize: $.varRef(init?.size ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): FileStatus {\n\t\tconst cloned = new FileStatus()\n\t\tcloned._fields = {\n\t\t\tmode: $.varRef(this._fields.mode.value),\n\t\t\tsize: $.varRef(this._fields.size.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.FileStatus',\n\t  new FileStatus(),\n\t  [],\n\t  FileStatus,\n\t  {\"mode\": \"MyFileMode\", \"size\": { kind: $.TypeKind.Basic, name: \"int64\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Test using the named type directly\n\tlet mode: MyFileMode = 0o644\n\t$.println(\"Mode value:\", mode)\n\t$.println(\"Mode string:\", MyFileMode_String(mode))\n\n\t// Test using in struct\n\tlet status = $.markAsStructValue(new FileStatus({mode: (0o755 as MyFileMode), size: 1024}))\n\n\t$.println(\"Status mode:\", status.mode)\n\t$.println(\"Status size:\", status.size)\n\n\t// Test type assertion and conversion\n\tlet genericMode: MyFileMode = (0o777 as MyFileMode)\n\t$.println(\"Generic mode:\", genericMode)\n}\n\n",
    "expectedOutput": "Mode value: 420\nMode string: mode\nStatus mode: 493\nStatus size: 1024\nGeneric mode: 511\n"
  },
  {
    "name": "named_types_valueof",
    "goCode": "package main\n\nimport (\n\t\"github.com/aperturerobotics/goscript/tests/tests/named_types_valueof/subpkg\"\n)\n\n// Local named types for testing\ntype (\n\tLocalInt    int32\n\tLocalUint   uint16\n\tLocalFloat  float32\n\tLocalString string\n\tLocalBool   bool\n)\n\n// Multi-level local types\ntype (\n\tLocalLevel1 LocalLevel2\n\tLocalLevel2 LocalLevel3\n\tLocalLevel3 int\n)\n\nfunc main() {\n\t// Test basic named numeric types with bitwise operations\n\tvar myInt LocalInt = 10\n\tvar myUint LocalUint = 5\n\n\t// Test bitwise operations with local named types\n\tprintln(\"Local bitwise operations:\")\n\tresult1 := myInt | 3\n\tprintln(\"LocalInt | 3:\", int(result1))\n\n\tresult2 := myUint & 7\n\tprintln(\"LocalUint & 7:\", int(result2))\n\n\tresult3 := myInt ^ 15\n\tprintln(\"LocalInt ^ 15:\", int(result3))\n\n\t// Test with constants\n\tconst localConst LocalInt = 20\n\tresult4 := localConst | myInt\n\tprintln(\"localConst | myInt:\", int(result4))\n\n\t// Test multi-level indirection\n\tvar level LocalLevel1 = 100\n\tresult5 := level | 7\n\tprintln(\"LocalLevel1 | 7:\", int(result5))\n\n\t// Test cross-package named types\n\tprintln(\"\\nCross-package operations:\")\n\n\t// Test imported constants\n\tprintln(\"subpkg.IntValue:\", int(subpkg.IntValue))\n\tprintln(\"subpkg.UintValue:\", int(subpkg.UintValue))\n\tprintln(\"subpkg.FloatValue:\", float64(subpkg.FloatValue))\n\tprintln(\"subpkg.StringValue:\", string(subpkg.StringValue))\n\tprintln(\"subpkg.BoolValue:\", bool(subpkg.BoolValue))\n\n\t// Test bitwise operations with imported types\n\tresult6 := subpkg.UintValue | 0x20\n\tprintln(\"subpkg.UintValue | 0x20:\", int(result6))\n\n\tresult7 := subpkg.LevelValue & 0xFFF\n\tprintln(\"subpkg.LevelValue & 0xFFF:\", int(result7))\n\n\t// Test function calls that return named types\n\tcombined := subpkg.GetCombinedFlags()\n\tprintln(\"subpkg.GetCombinedFlags():\", int(combined))\n\n\t// Test multi-level indirection directly\n\tdirectLevel := subpkg.LevelValue | 0x0F\n\tprintln(\"subpkg.LevelValue | 0x0F:\", int(directLevel))\n\n\t// Test mixed operations between local and imported types\n\tmixedResult := LocalUint(subpkg.UintValue) | myUint\n\tprintln(\"Mixed operation result:\", int(mixedResult))\n\n\t// Test various bitwise operators\n\tprintln(\"\\nTesting all bitwise operators:\")\n\tbase := LocalInt(42)\n\n\tprintln(\"base:\", int(base))\n\tprintln(\"base | 8:\", int(base|8))\n\tprintln(\"base & 15:\", int(base&15))\n\tprintln(\"base ^ 31:\", int(base^31))\n\tprintln(\"base << 2:\", int(base<<2))\n\tprintln(\"base >> 1:\", int(base>>1))\n\tprintln(\"base &^ 7:\", int(base&^7)) // AND NOT\n\n\t// Test with different underlying types\n\tprintln(\"\\nDifferent underlying types:\")\n\n\tvar f LocalFloat = 2.5\n\tvar s LocalString = \"test\"\n\tvar b LocalBool = true\n\n\tprintln(\"LocalFloat:\", float32(f))\n\tprintln(\"LocalString:\", string(s))\n\tprintln(\"LocalBool:\", bool(b))\n\n\t// Test arithmetic operations that might need valueOf\n\tf2 := f * 2.0\n\tprintln(\"LocalFloat * 2.0:\", float32(f2))\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on named_types_valueof.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as subpkg from \"@goscript/github.com/aperturerobotics/goscript/tests/tests/named_types_valueof/subpkg/index.js\"\n\nexport type LocalBool = boolean;\n\nexport type LocalFloat = number;\n\nexport type LocalInt = number;\n\nexport type LocalLevel3 = number;\n\nexport type LocalString = string;\n\nexport type LocalUint = number;\n\nexport type LocalLevel2 = LocalLevel3;\n\nexport type LocalLevel1 = LocalLevel2;\n\nexport async function main(): Promise<void> {\n\t// Test basic named numeric types with bitwise operations\n\tlet myInt: LocalInt = 10\n\tlet myUint: LocalUint = 5\n\n\t// Test bitwise operations with local named types\n\t$.println(\"Local bitwise operations:\")\n\tlet result1 = (myInt | 3)\n\t$.println(\"LocalInt | 3:\", $.int(result1))\n\n\tlet result2 = (myUint & 7)\n\t$.println(\"LocalUint & 7:\", $.int(result2))\n\n\tlet result3 = (myInt ^ 15)\n\t$.println(\"LocalInt ^ 15:\", $.int(result3))\n\n\t// Test with constants\n\tlet localConst: LocalInt = 20\n\tlet result4 = (20 | myInt)\n\t$.println(\"localConst | myInt:\", $.int(result4))\n\n\t// Test multi-level indirection\n\tlet level: LocalLevel1 = 100\n\tlet result5 = (level | 7)\n\t$.println(\"LocalLevel1 | 7:\", result5)\n\n\t// Test cross-package named types\n\t$.println(\"\\nCross-package operations:\")\n\n\t// Test imported constants\n\t$.println(\"subpkg.IntValue:\", subpkg.IntValue)\n\t$.println(\"subpkg.UintValue:\", $.int(subpkg.UintValue))\n\t$.println(\"subpkg.FloatValue:\", subpkg.FloatValue)\n\t$.println(\"subpkg.StringValue:\", subpkg.StringValue)\n\t$.println(\"subpkg.BoolValue:\", subpkg.BoolValue)\n\n\t// Test bitwise operations with imported types\n\tlet result6 = (subpkg.UintValue | 0x20)\n\t$.println(\"subpkg.UintValue | 0x20:\", $.int(result6))\n\n\tlet result7 = (subpkg.LevelValue & 0xFFF)\n\t$.println(\"subpkg.LevelValue & 0xFFF:\", $.int(result7))\n\n\t// Test function calls that return named types\n\tlet combined = subpkg.GetCombinedFlags()\n\t$.println(\"subpkg.GetCombinedFlags():\", $.int(combined))\n\n\t// Test multi-level indirection directly\n\tlet directLevel = (subpkg.LevelValue | 0x0F)\n\t$.println(\"subpkg.LevelValue | 0x0F:\", $.int(directLevel))\n\n\t// Test mixed operations between local and imported types\n\tlet mixedResult = ((subpkg.UintValue as LocalUint) | myUint)\n\t$.println(\"Mixed operation result:\", $.int(mixedResult))\n\n\t// Test various bitwise operators\n\t$.println(\"\\nTesting all bitwise operators:\")\n\tlet base = (42 as LocalInt)\n\n\t$.println(\"base:\", $.int(base))\n\t$.println(\"base | 8:\", $.int((base | 8)))\n\t$.println(\"base & 15:\", $.int((base & 15)))\n\t$.println(\"base ^ 31:\", $.int((base ^ 31)))\n\t$.println(\"base << 2:\", $.int((base << 2)))\n\t$.println(\"base >> 1:\", $.int((base >> 1)))\n\t$.println(\"base &^ 7:\", $.int((base & ~ 7))) // AND NOT\n\n\t// Test with different underlying types\n\t$.println(\"\\nDifferent underlying types:\")\n\n\tlet f: LocalFloat = 2.5\n\tlet s: LocalString = \"test\"\n\tlet b: LocalBool = true\n\n\t$.println(\"LocalFloat:\", f)\n\t$.println(\"LocalString:\", s)\n\t$.println(\"LocalBool:\", b)\n\n\t// Test arithmetic operations that might need valueOf\n\tlet f2 = f * 2.0\n\t$.println(\"LocalFloat * 2.0:\", f2)\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Local bitwise operations:\nLocalInt | 3: 11\nLocalUint & 7: 5\nLocalInt ^ 15: 5\nlocalConst | myInt: 30\nLocalLevel1 | 7: 103\n\nCross-package operations:\nsubpkg.IntValue: 42\nsubpkg.UintValue: 255\nsubpkg.FloatValue: 3.14\nsubpkg.StringValue: hello\nsubpkg.BoolValue: true\nsubpkg.UintValue | 0x20: 255\nsubpkg.LevelValue & 0xFFF: 0\nsubpkg.GetCombinedFlags(): 255\nsubpkg.LevelValue | 0x0F: 4111\nMixed operation result: 255\n\nTesting all bitwise operators:\nbase: 42\nbase | 8: 42\nbase & 15: 10\nbase ^ 31: 53\nbase << 2: 168\nbase >> 1: 21\nbase &^ 7: 40\n\nDifferent underlying types:\nLocalFloat: 2.5\nLocalString: test\nLocalBool: true\nLocalFloat * 2.0: 5\ntest finished\n"
  },
  {
    "name": "nil_channel",
    "goCode": "package main\n\nfunc main() {\n\t// Test nil channel operations\n\n\t// Test 1: Using nil channel in select with default\n\tprintln(\"Test 1: Select with nil channel and default\")\n\tvar nilCh chan int\n\n\tselect {\n\tcase nilCh <- 42:\n\t\tprintln(\"ERROR: Should not send to nil channel\")\n\tcase <-nilCh:\n\t\tprintln(\"ERROR: Should not receive from nil channel\")\n\tdefault:\n\t\tprintln(\"PASS: Default case executed correctly\")\n\t}\n\n\t// Test 2: Multiple nil channels in select with default\n\tprintln(\"\\nTest 2: Select with multiple nil channels and default\")\n\tvar nilCh1 chan string\n\tvar nilCh2 chan string\n\n\tselect {\n\tcase nilCh1 <- \"test\":\n\t\tprintln(\"ERROR: Should not send to nil channel 1\")\n\tcase <-nilCh2:\n\t\tprintln(\"ERROR: Should not receive from nil channel 2\")\n\tcase msg := <-nilCh1:\n\t\tprintln(\"ERROR: Should not receive from nil channel 1:\", msg)\n\tdefault:\n\t\tprintln(\"PASS: Default case executed with multiple nil channels\")\n\t}\n\n\t// Test 3: Mix of nil and valid channels in select\n\tprintln(\"\\nTest 3: Select with mix of nil and valid channels\")\n\tvar nilCh3 chan bool\n\tvalidCh := make(chan bool, 1)\n\tvalidCh <- true\n\n\tselect {\n\tcase nilCh3 <- true:\n\t\tprintln(\"ERROR: Should not send to nil channel\")\n\tcase <-nilCh3:\n\t\tprintln(\"ERROR: Should not receive from nil channel\")\n\tcase val := <-validCh:\n\t\tprintln(\"PASS: Received from valid channel:\", val)\n\tdefault:\n\t\tprintln(\"ERROR: Should not hit default with valid channel ready\")\n\t}\n\n\tprintln(\"\\nAll nil channel tests completed\")\n}\n",
    "tsCode": "// Generated file based on nil_channel.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test nil channel operations\n\n\t// Test 1: Using nil channel in select with default\n\t$.println(\"Test 1: Select with nil channel and default\")\n\tlet nilCh: $.Channel<number> | null = null\n\n\tconst [_select_has_return_9426, _select_value_9426] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: true,\n\t\t\tchannel: nilCh,\n\t\t\tvalue: 42,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"ERROR: Should not send to nil channel\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 1,\n\t\t\tisSend: false,\n\t\t\tchannel: nilCh,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"ERROR: Should not receive from nil channel\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"PASS: Default case executed correctly\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_9426) {\n\t\treturn _select_value_9426!\n\t}\n\t// If _select_has_return_9426 is false, continue execution\n\n\t// Test 2: Multiple nil channels in select with default\n\t$.println(\"\\nTest 2: Select with multiple nil channels and default\")\n\tlet nilCh1: $.Channel<string> | null = null\n\tlet nilCh2: $.Channel<string> | null = null\n\n\tconst [_select_has_return_69ac, _select_value_69ac] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: true,\n\t\t\tchannel: nilCh1,\n\t\t\tvalue: \"test\",\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"ERROR: Should not send to nil channel 1\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 1,\n\t\t\tisSend: false,\n\t\t\tchannel: nilCh2,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"ERROR: Should not receive from nil channel 2\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 2,\n\t\t\tisSend: false,\n\t\t\tchannel: nilCh1,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst msg = result.value\n\t\t\t\t$.println(\"ERROR: Should not receive from nil channel 1:\", msg)\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"PASS: Default case executed with multiple nil channels\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_69ac) {\n\t\treturn _select_value_69ac!\n\t}\n\t// If _select_has_return_69ac is false, continue execution\n\n\t// Test 3: Mix of nil and valid channels in select\n\t$.println(\"\\nTest 3: Select with mix of nil and valid channels\")\n\tlet nilCh3: $.Channel<boolean> | null = null\n\tlet validCh = $.makeChannel<boolean>(1, false, 'both')\n\tawait $.chanSend(validCh, true)\n\n\tconst [_select_has_return_c48f, _select_value_c48f] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: true,\n\t\t\tchannel: nilCh3,\n\t\t\tvalue: true,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"ERROR: Should not send to nil channel\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 1,\n\t\t\tisSend: false,\n\t\t\tchannel: nilCh3,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"ERROR: Should not receive from nil channel\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 2,\n\t\t\tisSend: false,\n\t\t\tchannel: validCh,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst val = result.value\n\t\t\t\t$.println(\"PASS: Received from valid channel:\", val)\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"ERROR: Should not hit default with valid channel ready\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_c48f) {\n\t\treturn _select_value_c48f!\n\t}\n\t// If _select_has_return_c48f is false, continue execution\n\n\t$.println(\"\\nAll nil channel tests completed\")\n}\n\n",
    "expectedOutput": "Test 1: Select with nil channel and default\nPASS: Default case executed correctly\n\nTest 2: Select with multiple nil channels and default\nPASS: Default case executed with multiple nil channels\n\nTest 3: Select with mix of nil and valid channels\nPASS: Received from valid channel: true\n\nAll nil channel tests completed\n"
  },
  {
    "name": "nil_pkg_pointer_dereference",
    "goCode": "package main\n\nimport \"os\"\n\ntype TestStruct struct {\n\tMode os.FileMode\n\tFile *os.File\n}\n\nfunc main() {\n\t// Test initialized struct\n\ts := TestStruct{\n\t\tMode: 420, // 420 in decimal\n\t\tFile: nil,\n\t}\n\n\tprintln(\"Mode:\", int(s.Mode))\n\tprintln(\"File is nil:\", s.File == nil)\n\n\t// Test zero values\n\tvar zero TestStruct\n\tprintln(\"Zero Mode:\", int(zero.Mode))\n\tprintln(\"Zero File is nil:\", zero.File == nil)\n}\n",
    "tsCode": "// Generated file based on nil_pkg_pointer_dereference.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nexport class TestStruct {\n\tpublic get Mode(): os.FileMode {\n\t\treturn this._fields.Mode.value\n\t}\n\tpublic set Mode(value: os.FileMode) {\n\t\tthis._fields.Mode.value = value\n\t}\n\n\tpublic get File(): os.File | null {\n\t\treturn this._fields.File.value\n\t}\n\tpublic set File(value: os.File | null) {\n\t\tthis._fields.File.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMode: $.VarRef<os.FileMode>;\n\t\tFile: $.VarRef<os.File | null>;\n\t}\n\n\tconstructor(init?: Partial<{File?: os.File | null, Mode?: os.FileMode}>) {\n\t\tthis._fields = {\n\t\t\tMode: $.varRef(init?.Mode ?? 0 as os.FileMode),\n\t\t\tFile: $.varRef(init?.File ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): TestStruct {\n\t\tconst cloned = new TestStruct()\n\t\tcloned._fields = {\n\t\t\tMode: $.varRef(this._fields.Mode.value),\n\t\t\tFile: $.varRef(this._fields.File.value ? $.markAsStructValue(this._fields.File.value.clone()) : null)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.TestStruct',\n\t  new TestStruct(),\n\t  [],\n\t  TestStruct,\n\t  {\"Mode\": { kind: $.TypeKind.Basic, name: \"uint32\" }, \"File\": { kind: $.TypeKind.Pointer, elemType: \"File\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Test initialized struct\n\n\t// 420 in decimal\n\tlet s = $.markAsStructValue(new TestStruct({File: null, Mode: 420}))\n\n\t$.println(\"Mode:\", $.int(s.Mode))\n\t$.println(\"File is nil:\", s.File == null)\n\n\t// Test zero values\n\tlet zero: TestStruct = new TestStruct()\n\t$.println(\"Zero Mode:\", $.int(zero.Mode))\n\t$.println(\"Zero File is nil:\", zero.File == null)\n}\n\n",
    "expectedOutput": "Mode: 420\nFile is nil: true\nZero Mode: 0\nZero File is nil: true "
  },
  {
    "name": "nullable_function_param_call",
    "goCode": "package main\n\nimport (\n\t\"os\"\n)\n\n// FileInfo represents file information (simplified version of os.FileInfo)\ntype FileInfo interface {\n\tName() string\n\tSize() int64\n\tIsDir() bool\n}\n\n// WalkFunc is the type of function called for each file or directory\n// visited by Walk. Returns an error to stop walking (can be SkipDir).\ntype WalkFunc func(path string, info FileInfo, err error) error\n\n// SkipDir is used as a return value from WalkFunc to indicate that\n// the directory named in the call is to be skipped.\nvar SkipDir = os.ErrNotExist\n\n// Filesystem interface (simplified version of billy.Filesystem)\ntype Filesystem interface {\n\tReadDir(path string) ([]FileInfo, error)\n}\n\n// MockFileInfo implements FileInfo for testing\ntype MockFileInfo struct {\n\tname  string\n\tsize  int64\n\tisDir bool\n}\n\nfunc (m *MockFileInfo) Name() string { return m.name }\nfunc (m *MockFileInfo) Size() int64  { return m.size }\nfunc (m *MockFileInfo) IsDir() bool  { return m.isDir }\n\n// MockFilesystem implements Filesystem for testing\ntype MockFilesystem struct{}\n\nfunc (m *MockFilesystem) ReadDir(path string) ([]FileInfo, error) {\n\treturn []FileInfo{\n\t\t&MockFileInfo{name: \"file1.txt\", size: 100, isDir: false},\n\t\t&MockFileInfo{name: \"subdir\", size: 0, isDir: true},\n\t}, nil\n}\n\n// walk is a simplified version of filepath.Walk that demonstrates the issue\n// walkFn is a nullable function parameter that needs non-null assertion when called\nfunc walk(fs Filesystem, path string, info FileInfo, walkFn WalkFunc) error {\n\t// Test case 1: Direct call to nullable function parameter\n\t// This should generate: walkFn!(path, info, nil)\n\t// But currently generates: walkFn(path, info, nil) - missing !\n\terr := walkFn(path, info, nil)\n\tif err != nil && err != SkipDir {\n\t\treturn err\n\t}\n\n\t// Test case 2: Call with error parameter\n\tvar walkErr error = nil\n\t// This should also generate: walkFn!(path, info, walkErr)\n\tresult := walkFn(path, info, walkErr)\n\tif result != nil {\n\t\treturn result\n\t}\n\n\treturn nil\n}\n\n// Additional test with different function signature\ntype ProcessFunc func(data string) (string, error)\n\nfunc processWithCallback(input string, processor ProcessFunc) (string, error) {\n\t// Test case 3: Function parameter with return values\n\t// This should generate: processor!(input)\n\t// But currently generates: processor(input) - missing !\n\treturn processor(input)\n}\n\nfunc main() {\n\tfs := &MockFilesystem{}\n\tfileInfo := &MockFileInfo{name: \"test.txt\", size: 50, isDir: false}\n\n\t// Test the walk function with a callback\n\twalkFunc := func(path string, info FileInfo, err error) error {\n\t\tprintln(\"Walking:\", path, \"size:\", info.Size())\n\t\tif err != nil {\n\t\t\tprintln(\"Error:\", err.Error())\n\t\t}\n\t\treturn nil\n\t}\n\n\terr := walk(fs, \"/test\", fileInfo, walkFunc)\n\tif err != nil {\n\t\tprintln(\"Walk error:\", err.Error())\n\t}\n\n\t// Test the process function with a callback\n\tprocessFunc := func(data string) (string, error) {\n\t\treturn \"processed: \" + data, nil\n\t}\n\n\tresult, err2 := processWithCallback(\"hello\", processFunc)\n\tif err2 != nil {\n\t\tprintln(\"Process error:\", err2.Error())\n\t} else {\n\t\tprintln(\"Process result:\", result)\n\t}\n}\n",
    "tsCode": "// Generated file based on nullable_function_param_call.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nexport type FileInfo = null | {\n\tIsDir(): boolean\n\tName(): string\n\tSize(): number\n}\n\n$.registerInterfaceType(\n  'main.FileInfo',\n  null, // Zero value for interface is null\n  [{ name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }]\n);\n\nexport type Filesystem = null | {\n\tReadDir(path: string): [$.Slice<FileInfo>, $.GoError]\n}\n\n$.registerInterfaceType(\n  'main.Filesystem',\n  null, // Zero value for interface is null\n  [{ name: \"ReadDir\", args: [{ name: \"path\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Slice, elemType: \"FileInfo\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class MockFileInfo {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._fields.size.value\n\t}\n\tpublic set size(value: number) {\n\t\tthis._fields.size.value = value\n\t}\n\n\tpublic get isDir(): boolean {\n\t\treturn this._fields.isDir.value\n\t}\n\tpublic set isDir(value: boolean) {\n\t\tthis._fields.isDir.value = value\n\t}\n\n\tpublic _fields: {\n\t\tname: $.VarRef<string>;\n\t\tsize: $.VarRef<number>;\n\t\tisDir: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{isDir?: boolean, name?: string, size?: number}>) {\n\t\tthis._fields = {\n\t\t\tname: $.varRef(init?.name ?? \"\"),\n\t\t\tsize: $.varRef(init?.size ?? 0),\n\t\t\tisDir: $.varRef(init?.isDir ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): MockFileInfo {\n\t\tconst cloned = new MockFileInfo()\n\t\tcloned._fields = {\n\t\t\tname: $.varRef(this._fields.name.value),\n\t\t\tsize: $.varRef(this._fields.size.value),\n\t\t\tisDir: $.varRef(this._fields.isDir.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Name(): string {\n\t\tconst m = this\n\t\treturn m.name\n\t}\n\n\tpublic Size(): number {\n\t\tconst m = this\n\t\treturn m.size\n\t}\n\n\tpublic IsDir(): boolean {\n\t\tconst m = this\n\t\treturn m.isDir\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MockFileInfo',\n\t  new MockFileInfo(),\n\t  [{ name: \"Name\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int64\" } }] }, { name: \"IsDir\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }],\n\t  MockFileInfo,\n\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"size\": { kind: $.TypeKind.Basic, name: \"int64\" }, \"isDir\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\nexport class MockFilesystem {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MockFilesystem {\n\t\tconst cloned = new MockFilesystem()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic ReadDir(path: string): [$.Slice<FileInfo>, $.GoError] {\n\t\treturn [$.arrayToSlice<FileInfo>([new MockFileInfo({isDir: false, name: \"file1.txt\", size: 100}), new MockFileInfo({isDir: true, name: \"subdir\", size: 0})]), null]\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MockFilesystem',\n\t  new MockFilesystem(),\n\t  [{ name: \"ReadDir\", args: [{ name: \"path\", type: { kind: $.TypeKind.Basic, name: \"string\" } }], returns: [{ type: { kind: $.TypeKind.Slice, elemType: \"FileInfo\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  MockFilesystem,\n\t  {}\n\t);\n}\n\nexport type ProcessFunc = ((data: string) => [string, $.GoError]) | null;\n\nexport type WalkFunc = ((path: string, info: FileInfo, err: $.GoError) => $.GoError) | null;\n\nexport let SkipDir: $.GoError = os.ErrNotExist\n\n// walk is a simplified version of filepath.Walk that demonstrates the issue\n// walkFn is a nullable function parameter that needs non-null assertion when called\nexport function walk(fs: Filesystem, path: string, info: FileInfo, walkFn: WalkFunc | null): $.GoError {\n\t// Test case 1: Direct call to nullable function parameter\n\t// This should generate: walkFn!(path, info, nil)\n\t// But currently generates: walkFn(path, info, nil) - missing !\n\tlet err = walkFn!(path, info, null)\n\tif (err != null && err != SkipDir) {\n\t\treturn err\n\t}\n\n\t// Test case 2: Call with error parameter\n\tlet walkErr: $.GoError = null\n\t// This should also generate: walkFn!(path, info, walkErr)\n\tlet result = walkFn!(path, info, walkErr)\n\tif (result != null) {\n\t\treturn result\n\t}\n\n\treturn null\n}\n\nexport function processWithCallback(input: string, processor: ProcessFunc | null): [string, $.GoError] {\n\t// Test case 3: Function parameter with return values\n\t// This should generate: processor!(input)\n\t// But currently generates: processor(input) - missing !\n\treturn processor!(input)\n}\n\nexport async function main(): Promise<void> {\n\tlet fs = new MockFilesystem({})\n\tlet fileInfo = new MockFileInfo({isDir: false, name: \"test.txt\", size: 50})\n\n\t// Test the walk function with a callback\n\tlet walkFunc = (path: string, info: FileInfo, err: $.GoError): $.GoError => {\n\t\t$.println(\"Walking:\", path, \"size:\", info!.Size())\n\t\tif (err != null) {\n\t\t\t$.println(\"Error:\", err!.Error())\n\t\t}\n\t\treturn null\n\t}\n\n\tlet err = walk(fs, \"/test\", fileInfo, walkFunc)\n\tif (err != null) {\n\t\t$.println(\"Walk error:\", err!.Error())\n\t}\n\n\t// Test the process function with a callback\n\tlet processFunc = (data: string): [string, $.GoError] => {\n\t\treturn [\"processed: \" + data, null]\n\t}\n\n\tlet [result, err2] = processWithCallback(\"hello\", processFunc)\n\tif (err2 != null) {\n\t\t$.println(\"Process error:\", err2!.Error())\n\t} else {\n\t\t$.println(\"Process result:\", result)\n\t}\n}\n\n",
    "expectedOutput": "Walking: /test size: 50\nWalking: /test size: 50\nProcess result: processed: hello\n"
  },
  {
    "name": "octal_literals",
    "goCode": "package main\n\nfunc main() {\n\t// Test octal literals that cause TypeScript compilation errors\n\tperm1 := 0o777\n\tperm2 := 0o666\n\tperm3 := 0o644\n\tperm4 := 0o755\n\n\tprintln(\"perm1:\", perm1)\n\tprintln(\"perm2:\", perm2)\n\tprintln(\"perm3:\", perm3)\n\tprintln(\"perm4:\", perm4)\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on octal_literals.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test octal literals that cause TypeScript compilation errors\n\tlet perm1 = 0o777\n\tlet perm2 = 0o666\n\tlet perm3 = 0o644\n\tlet perm4 = 0o755\n\n\t$.println(\"perm1:\", perm1)\n\t$.println(\"perm2:\", perm2)\n\t$.println(\"perm3:\", perm3)\n\t$.println(\"perm4:\", perm4)\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "perm1: 511\nperm2: 438\nperm3: 420\nperm4: 493\ntest finished\n"
  },
  {
    "name": "os_filemode_struct",
    "goCode": "package main\n\nimport \"os\"\n\ntype file struct {\n\tmode os.FileMode\n\tname string\n}\n\nfunc main() {\n\tf := file{\n\t\tmode: os.FileMode(0o644),\n\t\tname: \"test.txt\",\n\t}\n\n\tprintln(\"File mode:\", int(f.mode))\n\tprintln(\"File name:\", f.name)\n\n\t// Test type assertion\n\tvar mode os.FileMode = os.FileMode(0o755)\n\tprintln(\"Mode type:\", int(mode))\n}\n",
    "tsCode": "// Generated file based on os_filemode_struct.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nexport class file {\n\tpublic get mode(): os.FileMode {\n\t\treturn this._fields.mode.value\n\t}\n\tpublic set mode(value: os.FileMode) {\n\t\tthis._fields.mode.value = value\n\t}\n\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic _fields: {\n\t\tmode: $.VarRef<os.FileMode>;\n\t\tname: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{mode?: os.FileMode, name?: string}>) {\n\t\tthis._fields = {\n\t\t\tmode: $.varRef(init?.mode ?? 0 as os.FileMode),\n\t\t\tname: $.varRef(init?.name ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): file {\n\t\tconst cloned = new file()\n\t\tcloned._fields = {\n\t\t\tmode: $.varRef(this._fields.mode.value),\n\t\t\tname: $.varRef(this._fields.name.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.file',\n\t  new file(),\n\t  [],\n\t  file,\n\t  {\"mode\": { kind: $.TypeKind.Basic, name: \"uint32\" }, \"name\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet f = $.markAsStructValue(new file({mode: (0o644 as os.FileMode), name: \"test.txt\"}))\n\n\t$.println(\"File mode:\", $.int(f.mode))\n\t$.println(\"File name:\", f.name)\n\n\t// Test type assertion\n\tlet mode: os.FileMode = (0o755 as os.FileMode)\n\t$.println(\"Mode type:\", $.int(mode))\n}\n\n",
    "expectedOutput": "File mode: 420\nFile name: test.txt\nMode type: 493\n"
  },
  {
    "name": "package_import",
    "goCode": "package main\n\nimport (\n\t\"github.com/aperturerobotics/goscript/tests/tests/package_import/subpkg\"\n)\n\nfunc main() {\n\tprintln(subpkg.Greet(\"world\"))\n}\n",
    "tsCode": "// Generated file based on package_import.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as subpkg from \"@goscript/github.com/aperturerobotics/goscript/tests/tests/package_import/subpkg/index.js\"\n\nexport async function main(): Promise<void> {\n\t$.println(subpkg.Greet(\"world\"))\n}\n\n",
    "expectedOutput": "Hello, world"
  },
  {
    "name": "package_import_bytes",
    "goCode": "package main\n\nimport \"bytes\"\n\nfunc main() {\n\t// Test basic byte slice operations\n\tb1 := []byte(\"hello\")\n\tb2 := []byte(\"world\")\n\n\t// Test Equal\n\tif bytes.Equal(b1, b1) {\n\t\tprintln(\"Equal works correctly\")\n\t}\n\n\t// Test Compare\n\tresult := bytes.Compare(b1, b2)\n\tif result < 0 {\n\t\tprintln(\"Compare works: hello < world\")\n\t}\n\n\t// Test Contains\n\tif bytes.Contains(b1, []byte(\"ell\")) {\n\t\tprintln(\"Contains works correctly\")\n\t}\n\n\t// Test Index\n\tidx := bytes.Index(b1, []byte(\"ll\"))\n\tif idx == 2 {\n\t\tprintln(\"Index works correctly, found at position:\", idx)\n\t}\n\n\t// Test Join\n\tslices := [][]byte{b1, b2}\n\tjoined := bytes.Join(slices, []byte(\" \"))\n\tprintln(\"Joined:\", string(joined))\n\n\t// Test Split\n\tsplit := bytes.Split(joined, []byte(\" \"))\n\tprintln(\"Split result length:\", len(split))\n\tif len(split) == 2 {\n\t\tprintln(\"Split works correctly\")\n\t}\n\n\t// Test HasPrefix and HasSuffix\n\tif bytes.HasPrefix(b1, []byte(\"he\")) {\n\t\tprintln(\"HasPrefix works correctly\")\n\t}\n\n\tif bytes.HasSuffix(b1, []byte(\"lo\")) {\n\t\tprintln(\"HasSuffix works correctly\")\n\t}\n\n\t// Test Trim functions\n\twhitespace := []byte(\"  hello  \")\n\ttrimmed := bytes.TrimSpace(whitespace)\n\tprintln(\"Trimmed:\", string(trimmed))\n\n\t// Test ToUpper and ToLower\n\tupper := bytes.ToUpper(b1)\n\tlower := bytes.ToLower(upper)\n\tprintln(\"Upper:\", string(upper))\n\tprintln(\"Lower:\", string(lower))\n\n\t// Test Repeat\n\trepeated := bytes.Repeat([]byte(\"x\"), 3)\n\tprintln(\"Repeated:\", string(repeated))\n\n\t// Test Count\n\tcount := bytes.Count([]byte(\"banana\"), []byte(\"a\"))\n\tprintln(\"Count of 'a' in 'banana':\", count)\n\n\t// Test Replace\n\treplaced := bytes.Replace([]byte(\"hello hello\"), []byte(\"hello\"), []byte(\"hi\"), 1)\n\tprintln(\"Replace result:\", string(replaced))\n\n\t// Test ReplaceAll\n\treplacedAll := bytes.ReplaceAll([]byte(\"hello hello\"), []byte(\"hello\"), []byte(\"hi\"))\n\tprintln(\"ReplaceAll result:\", string(replacedAll))\n\n\t// Test Buffer\n\tvar buf bytes.Buffer\n\tbuf.WriteString(\"Hello \")\n\tbuf.WriteString(\"World\")\n\tprintln(\"Buffer content:\", buf.String())\n\tprintln(\"Buffer length:\", buf.Len())\n\n\t// Test Buffer Read\n\tdata := make([]byte, 5)\n\tn, _ := buf.Read(data)\n\tprintln(\"Read\", n, \"bytes:\", string(data))\n\n\t// Test Buffer Reset\n\tbuf.Reset()\n\tprintln(\"Buffer after reset, length:\", buf.Len())\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_bytes.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as bytes from \"@goscript/bytes/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test basic byte slice operations\n\tlet b1 = $.stringToBytes(\"hello\")\n\tlet b2 = $.stringToBytes(\"world\")\n\n\t// Test Equal\n\tif (bytes.Equal(b1, b1)) {\n\t\t$.println(\"Equal works correctly\")\n\t}\n\n\t// Test Compare\n\tlet result = bytes.Compare(b1, b2)\n\tif (result < 0) {\n\t\t$.println(\"Compare works: hello < world\")\n\t}\n\n\t// Test Contains\n\tif (bytes.Contains(b1, $.stringToBytes(\"ell\"))) {\n\t\t$.println(\"Contains works correctly\")\n\t}\n\n\t// Test Index\n\tlet idx = bytes.Index(b1, $.stringToBytes(\"ll\"))\n\tif (idx == 2) {\n\t\t$.println(\"Index works correctly, found at position:\", idx)\n\t}\n\n\t// Test Join\n\tlet slices = $.arrayToSlice<$.Bytes>([b1, b2], 2)\n\tlet joined = bytes.Join(slices, $.stringToBytes(\" \"))\n\t$.println(\"Joined:\", $.bytesToString(joined))\n\n\t// Test Split\n\tlet split = bytes.Split(joined, $.stringToBytes(\" \"))\n\t$.println(\"Split result length:\", $.len(split))\n\tif ($.len(split) == 2) {\n\t\t$.println(\"Split works correctly\")\n\t}\n\n\t// Test HasPrefix and HasSuffix\n\tif (bytes.HasPrefix(b1, $.stringToBytes(\"he\"))) {\n\t\t$.println(\"HasPrefix works correctly\")\n\t}\n\n\tif (bytes.HasSuffix(b1, $.stringToBytes(\"lo\"))) {\n\t\t$.println(\"HasSuffix works correctly\")\n\t}\n\n\t// Test Trim functions\n\tlet whitespace = $.stringToBytes(\"  hello  \")\n\tlet trimmed = bytes.TrimSpace(whitespace)\n\t$.println(\"Trimmed:\", $.bytesToString(trimmed))\n\n\t// Test ToUpper and ToLower\n\tlet upper = bytes.ToUpper(b1)\n\tlet lower = bytes.ToLower(upper)\n\t$.println(\"Upper:\", $.bytesToString(upper))\n\t$.println(\"Lower:\", $.bytesToString(lower))\n\n\t// Test Repeat\n\tlet repeated = bytes.Repeat($.stringToBytes(\"x\"), 3)\n\t$.println(\"Repeated:\", $.bytesToString(repeated))\n\n\t// Test Count\n\tlet count = bytes.Count($.stringToBytes(\"banana\"), $.stringToBytes(\"a\"))\n\t$.println(\"Count of 'a' in 'banana':\", count)\n\n\t// Test Replace\n\tlet replaced = bytes.Replace($.stringToBytes(\"hello hello\"), $.stringToBytes(\"hello\"), $.stringToBytes(\"hi\"), 1)\n\t$.println(\"Replace result:\", $.bytesToString(replaced))\n\n\t// Test ReplaceAll\n\tlet replacedAll = bytes.ReplaceAll($.stringToBytes(\"hello hello\"), $.stringToBytes(\"hello\"), $.stringToBytes(\"hi\"))\n\t$.println(\"ReplaceAll result:\", $.bytesToString(replacedAll))\n\n\t// Test Buffer\n\tlet buf: $.VarRef<bytes.Buffer> = $.varRef(new bytes.Buffer())\n\tbuf!.value.WriteString(\"Hello \")\n\tbuf!.value.WriteString(\"World\")\n\t$.println(\"Buffer content:\", buf!.value.String())\n\t$.println(\"Buffer length:\", buf!.value.Len())\n\n\t// Test Buffer Read\n\tlet data = new Uint8Array(5)\n\tlet [n, ] = buf!.value.Read(data)\n\t$.println(\"Read\", n, \"bytes:\", $.bytesToString(data))\n\n\t// Test Buffer Reset\n\tbuf!.value.Reset()\n\t$.println(\"Buffer after reset, length:\", buf!.value.Len())\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Equal works correctly\nCompare works: hello < world\nContains works correctly\nIndex works correctly, found at position: 2\nJoined: hello world\nSplit result length: 2\nSplit works correctly\nHasPrefix works correctly\nHasSuffix works correctly\nTrimmed: hello\nUpper: HELLO\nLower: hello\nRepeated: xxx\nCount of 'a' in 'banana': 3\nReplace result: hi hello\nReplaceAll result: hi hi\nBuffer content: Hello World\nBuffer length: 11\nRead 5 bytes: Hello\nBuffer after reset, length: 0\ntest finished\n"
  },
  {
    "name": "package_import_context",
    "goCode": "package main\n\nimport \"context\"\n\nfunc run(ctx context.Context) {\n\tsctx, sctxCancel := context.WithCancel(ctx)\n\tdefer sctxCancel()\n\n\tmyCh := make(chan struct{})\n\n\tgo func() {\n\t\t<-sctx.Done()\n\t\tmyCh <- struct{}{}\n\t}()\n\n\t// Check that myCh is not readable yet\n\tselect {\n\tcase <-myCh:\n\t\tprintln(\"myCh should not be readable yet\")\n\tdefault:\n\t\tprintln(\"myCh is not be readable yet\")\n\t}\n\n\t// Cancel context which should trigger the goroutine\n\tsctxCancel()\n\n\t// Now myCh should become readable\n\t<-myCh\n\n\tprintln(\"read successfully\")\n}\n\nfunc main() {\n\tctx := context.Background()\n\trun(ctx)\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_context.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as context from \"@goscript/context/index.js\"\n\nexport async function run(ctx: null | context.Context): Promise<void> {\n\tusing __defer = new $.DisposableStack();\n\tlet [sctx, sctxCancel] = context.WithCancel(ctx)\n\t__defer.defer(() => {\n\t\tsctxCancel!()\n\t});\n\n\tlet myCh = $.makeChannel<{  }>(0, {}, 'both')\n\n\tqueueMicrotask(async () => {\n\t\tawait $.chanRecv(sctx!.Done())\n\t\tawait $.chanSend(myCh, {})\n\t})\n\n\t// Check that myCh is not readable yet\n\tconst [_select_has_return_be9f, _select_value_be9f] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: myCh,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"myCh should not be readable yet\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"myCh is not be readable yet\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_be9f) {\n\t\treturn _select_value_be9f!\n\t}\n\t// If _select_has_return_be9f is false, continue execution\n\n\t// Cancel context which should trigger the goroutine\n\tsctxCancel!()\n\n\t// Now myCh should become readable\n\tawait $.chanRecv(myCh)\n\n\t$.println(\"read successfully\")\n}\n\nexport async function main(): Promise<void> {\n\tlet ctx = context.Background()\n\tawait run(ctx)\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "myCh is not be readable yet\nread successfully\ntest finished\n"
  },
  {
    "name": "package_import_csync",
    "goCode": "package main\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/aperturerobotics/util/csync\"\n)\n\nfunc main() {\n\tvar (\n\t\tmtx     csync.Mutex\n\t\tcounter int\n\t\twg      sync.WaitGroup\n\t)\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\t// Number of goroutines to spawn\n\tnumWorkers := 5\n\twg.Add(numWorkers)\n\n\t// Function that will be run by each worker\n\tworker := func(id int) {\n\t\tdefer wg.Done()\n\n\t\t// Try to acquire the lock\n\t\trelLock, err := mtx.Lock(ctx)\n\t\tif err != nil {\n\t\t\tprintln(\"worker\", id, \"failed to acquire lock:\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tdefer relLock()\n\n\t\t// Critical section\n\t\t// println(\"worker\", id, \"entered critical section\") - non-deterministic, leave commented out\n\t\tcurrent := counter\n\t\ttime.Sleep(100 * time.Millisecond) // Simulate work\n\t\tcounter = current + 1\n\t\t// println(\"worker\", id, \"incremented counter to\", counter) - non-deterministic, leave commented out\n\t}\n\n\t// Start worker goroutines\n\tfor i := 0; i < numWorkers; i++ {\n\t\tgo worker(i)\n\t}\n\n\t// Wait for all workers to complete or context timeout\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\tprintln(\"All workers completed successfully\")\n\tcase <-ctx.Done():\n\t\tprintln(\"Test timed out:\", ctx.Err().Error())\n\t}\n\n\tprintln(\"Final counter value:\", counter)\n\tif counter != numWorkers {\n\t\tpanic(\"counter does not match expected value\")\n\t}\n\n\tprintln(\"success: csync.Mutex test completed\")\n}\n",
    "tsCode": "// Generated file based on package_import_csync.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as context from \"@goscript/context/index.js\"\n\nimport * as sync from \"@goscript/sync/index.js\"\n\nimport * as time from \"@goscript/time/index.js\"\n\nimport * as csync from \"@goscript/github.com/aperturerobotics/util/csync/index.js\"\n\nexport async function main(): Promise<void> {\n\tusing __defer = new $.DisposableStack();\n\tlet mtx: $.VarRef<csync.Mutex> = $.varRef(new csync.Mutex())\n\tlet counter: number = 0\n\tlet wg: $.VarRef<sync.WaitGroup> = $.varRef(new sync.WaitGroup())\n\n\tlet [ctx, cancel] = context.WithTimeout(context.Background(), 5 * time.Second)\n\t__defer.defer(() => {\n\t\tcancel!()\n\t});\n\n\t// Number of goroutines to spawn\n\tlet numWorkers = 5\n\twg!.value.Add(numWorkers)\n\n\t// Function that will be run by each worker\n\n\t// Try to acquire the lock\n\n\t// Critical section\n\t// println(\"worker\", id, \"entered critical section\") - non-deterministic, leave commented out\n\n\t// Simulate work\n\n\t// println(\"worker\", id, \"incremented counter to\", counter) - non-deterministic, leave commented out\n\tlet worker = async (id: number): Promise<void> => {\n\t\tusing __defer = new $.DisposableStack();\n\t\t__defer.defer(() => {\n\t\t\twg!.value.Done()\n\t\t});\n\n\t\t// Try to acquire the lock\n\t\tlet [relLock, err] = await mtx!.value.Lock(ctx)\n\t\tif (err != null) {\n\t\t\t$.println(\"worker\", id, \"failed to acquire lock:\", err!.Error())\n\t\t\treturn \n\t\t}\n\t\t__defer.defer(() => {\n\t\t\trelLock!()\n\t\t});\n\n\t\t// Critical section\n\t\t// println(\"worker\", id, \"entered critical section\") - non-deterministic, leave commented out\n\t\tlet current = counter\n\t\tawait time.Sleep(100 * time.Millisecond) // Simulate work\n\n\t\t// println(\"worker\", id, \"incremented counter to\", counter) - non-deterministic, leave commented out\n\t\tcounter = current + 1\n\t\t// println(\"worker\", id, \"incremented counter to\", counter) - non-deterministic, leave commented out\n\t}\n\n\t// Start worker goroutines\n\tfor (let i = 0; i < numWorkers; i++) {\n\t\tqueueMicrotask(() => {\n\t\t\tworker(i)\n\t\t})\n\t}\n\n\t// Wait for all workers to complete or context timeout\n\tlet done = $.makeChannel<{  }>(0, {}, 'both')\n\tqueueMicrotask(async () => {\n\t\tawait wg!.value.Wait()\n\t\tdone.close()\n\t})\n\n\tconst [_select_has_return_11d7, _select_value_11d7] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: done,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"All workers completed successfully\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 1,\n\t\t\tisSend: false,\n\t\t\tchannel: ctx!.Done(),\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"Test timed out:\", ctx!.Err()!.Error())\n\t\t\t}\n\t\t},\n\t], false)\n\tif (_select_has_return_11d7) {\n\t\treturn _select_value_11d7!\n\t}\n\t// If _select_has_return_11d7 is false, continue execution\n\n\t$.println(\"Final counter value:\", counter)\n\tif (counter != numWorkers) {\n\t\t$.panic(\"counter does not match expected value\")\n\t}\n\n\t$.println(\"success: csync.Mutex test completed\")\n}\n\n",
    "expectedOutput": "All workers completed successfully\nFinal counter value: 5\nsuccess: csync.Mutex test completed\n"
  },
  {
    "name": "package_import_encoding_json",
    "goCode": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"slices\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\nfunc main() {\n\tvar results []string\n\n\t// Marshal a simple struct\n\tp := Person{Name: \"Alice\", Age: 30, Active: true}\n\tb, err := json.Marshal(p)\n\tif err != nil {\n\t\tresults = append(results, \"Marshal error: \"+err.Error())\n\t} else {\n\t\tresults = append(results, \"Marshal: \"+string(b))\n\t}\n\n\t// Unmarshal into a struct\n\tvar q Person\n\tif err := json.Unmarshal([]byte(`{\"name\":\"Bob\",\"age\":25,\"active\":false}`), &q); err != nil {\n\t\tresults = append(results, \"Unmarshal struct error: \"+err.Error())\n\t} else {\n\t\tresults = append(results, \"Unmarshal struct: Name=\"+q.Name+\", Age=\"+itoa(q.Age)+\", Active=\"+boolstr(q.Active))\n\t}\n\n\t// Unmarshal into a map[string]any\n\tvar m map[string]any\n\tif err := json.Unmarshal([]byte(`{\"name\":\"Carol\",\"age\":22,\"active\":true}`), &m); err != nil {\n\t\tresults = append(results, \"Unmarshal map error: \"+err.Error())\n\t} else {\n\t\tname := m[\"name\"].(string)\n\t\tage := int(m[\"age\"].(float64))\n\t\tactive := m[\"active\"].(bool)\n\t\tresults = append(results, \"Unmarshal map: name=\"+name+\", age=\"+itoa(age)+\", active=\"+boolstr(active))\n\t}\n\n\t// Sort results for deterministic output\n\tslices.Sort(results)\n\n\tfor _, r := range results {\n\t\tprintln(\"JSON result:\", r)\n\t}\n\n\tprintln(\"encoding/json test finished\")\n}\n\n// minimal helpers to avoid imports\nfunc itoa(i int) string {\n\t// simple positive int conversion sufficient for this test\n\tif i == 0 {\n\t\treturn \"0\"\n\t}\n\tneg := false\n\tif i < 0 {\n\t\tneg = true\n\t\ti = -i\n\t}\n\tbuf := make([]byte, 0, 20)\n\tfor i > 0 {\n\t\td := byte(i % 10)\n\t\tbuf = append(buf, '0'+d)\n\t\ti /= 10\n\t}\n\t// reverse\n\tfor l, r := 0, len(buf)-1; l < r; l, r = l+1, r-1 {\n\t\tbuf[l], buf[r] = buf[r], buf[l]\n\t}\n\tif neg {\n\t\treturn \"-\" + string(buf)\n\t}\n\treturn string(buf)\n}\n\nfunc boolstr(b bool) string {\n\tif b {\n\t\treturn \"true\"\n\t}\n\treturn \"false\"\n}\n",
    "tsCode": "// Generated file based on package_import_encoding_json.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as json from \"@goscript/encoding/json/index.js\"\n\nimport * as slices from \"@goscript/slices/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet results: $.Slice<string> = null\n\n\t// Marshal a simple struct\n\tlet p = $.markAsStructValue(new Person({Active: true, Age: 30, Name: \"Alice\"}))\n\tlet [b, err] = await json.Marshal(p)\n\tif (err != null) {\n\t\tresults = $.append(results, \"Marshal error: \" + err!.Error())\n\t} else {\n\t\tresults = $.append(results, \"Marshal: \" + $.bytesToString(b))\n\t}\n\n\t// Unmarshal into a struct\n\tlet q: $.VarRef<Person> = $.varRef(new Person())\n\t{\n\t\tlet err = await json.Unmarshal($.stringToBytes(`{\"name\":\"Bob\",\"age\":25,\"active\":false}`), q)\n\t\tif (err != null) {\n\t\t\tresults = $.append(results, \"Unmarshal struct error: \" + err!.Error())\n\t\t} else {\n\t\t\tresults = $.append(results, \"Unmarshal struct: Name=\" + q!.value.Name + \", Age=\" + itoa(q!.value.Age) + \", Active=\" + boolstr(q!.value.Active))\n\t\t}\n\t}\n\n\t// Unmarshal into a map[string]any\n\tlet m: $.VarRef<Map<string, null | any> | null> = $.varRef(null)\n\t{\n\t\tlet err = await json.Unmarshal($.stringToBytes(`{\"name\":\"Carol\",\"age\":22,\"active\":true}`), m)\n\t\tif (err != null) {\n\t\t\tresults = $.append(results, \"Unmarshal map error: \" + err!.Error())\n\t\t} else {\n\t\t\tlet name = $.mustTypeAssert<string>($.mapGet(m!.value, \"name\", null)[0], {kind: $.TypeKind.Basic, name: 'string'})\n\t\t\tlet age = $.int($.mustTypeAssert<number>($.mapGet(m!.value, \"age\", null)[0], {kind: $.TypeKind.Basic, name: 'number'}))\n\t\t\tlet active = $.mustTypeAssert<boolean>($.mapGet(m!.value, \"active\", null)[0], {kind: $.TypeKind.Basic, name: 'boolean'})\n\t\t\tresults = $.append(results, \"Unmarshal map: name=\" + name + \", age=\" + itoa(age) + \", active=\" + boolstr(active))\n\t\t}\n\t}\n\n\t// Sort results for deterministic output\n\tslices.Sort(results)\n\n\tfor (let _i = 0; _i < $.len(results); _i++) {\n\t\tlet r = results![_i]\n\t\t{\n\t\t\t$.println(\"JSON result:\", r)\n\t\t}\n\t}\n\n\t$.println(\"encoding/json test finished\")\n}\n\n// minimal helpers to avoid imports\nexport function itoa(i: number): string {\n\t// simple positive int conversion sufficient for this test\n\tif (i == 0) {\n\t\treturn \"0\"\n\t}\n\tlet neg = false\n\tif (i < 0) {\n\t\tneg = true\n\t\ti = -i\n\t}\n\tlet buf = $.makeSlice<number>(0, 20, 'byte')\n\tfor (; i > 0; ) {\n\t\tlet d = $.byte(i % 10)\n\t\tbuf = $.append(buf, 48 + d)\n\t\ti = Math.trunc(i / 10)\n\t}\n\t// reverse\n\tfor (let l = 0, r = $.len(buf) - 1; l < r; [l, r] = [l + 1, r - 1]) {\n\t\t;[buf![l], buf![r]] = [buf![r], buf![l]]\n\t}\n\tif (neg) {\n\t\treturn \"-\" + $.bytesToString(buf)\n\t}\n\treturn $.bytesToString(buf)\n}\n\nexport function boolstr(b: boolean): string {\n\tif (b) {\n\t\treturn \"true\"\n\t}\n\treturn \"false\"\n}\n\n",
    "expectedOutput": "JSON result: Marshal: {\"name\":\"Alice\",\"age\":30,\"active\":true}\nJSON result: Unmarshal map: name=Carol, age=22, active=true\nJSON result: Unmarshal struct: Name=Bob, Age=25, Active=false\nencoding/json test finished\n"
  },
  {
    "name": "package_import_errors",
    "goCode": "package main\n\nimport \"errors\"\n\nfunc main() {\n\t// Test basic error creation\n\terr1 := errors.New(\"first error\")\n\terr2 := errors.New(\"second error\")\n\n\tprintln(\"err1:\", err1.Error())\n\tprintln(\"err2:\", err2.Error())\n\n\t// Test error comparison\n\tprintln(\"err1 == err2:\", err1 == err2)\n\tprintln(\"err1 == nil:\", err1 == nil)\n\n\t// Test nil error\n\tvar nilErr error\n\tprintln(\"nilErr == nil:\", nilErr == nil)\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_errors.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as errors from \"@goscript/errors/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test basic error creation\n\tlet err1 = errors.New(\"first error\")\n\tlet err2 = errors.New(\"second error\")\n\n\t$.println(\"err1:\", err1!.Error())\n\t$.println(\"err2:\", err2!.Error())\n\n\t// Test error comparison\n\t$.println(\"err1 == err2:\", err1 == err2)\n\t$.println(\"err1 == nil:\", err1 == null)\n\n\t// Test nil error\n\tlet nilErr: $.GoError = null\n\t$.println(\"nilErr == nil:\", nilErr == null)\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "err1: first error\nerr2: second error\nerr1 == err2: false\nerr1 == nil: false\nnilErr == nil: true\ntest finished\n"
  },
  {
    "name": "package_import_fmt",
    "goCode": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\t// Test basic Print functions\n\tfmt.Print(\"Hello\")\n\tfmt.Print(\" \")\n\tfmt.Print(\"World\")\n\tfmt.Println()\n\n\t// Test Printf with basic formatting\n\tname := \"Go\"\n\tversion := 1.21\n\tfmt.Printf(\"Welcome to %s %.2f\\n\", name, version)\n\n\t// Test Println\n\tfmt.Println(\"This is println\")\n\n\t// Test Sprint functions\n\tresult := fmt.Sprint(\"Sprint\", \" \", \"result\")\n\tfmt.Println(\"Sprint result:\", result)\n\n\t// Test Sprintf\n\tformatted := fmt.Sprintf(\"Number: %d, String: %s\", 42, \"test\")\n\tfmt.Println(\"Sprintf result:\", formatted)\n\n\t// Test Sprintln\n\tsprintln_result := fmt.Sprintln(\"Sprintln\", \"result\")\n\tfmt.Print(\"Sprintln result:\", sprintln_result)\n\n\t// Test Errorf\n\terr := fmt.Errorf(\"error code: %d\", 404)\n\tfmt.Println(\"Error:\", err)\n\n\t// Test various format verbs\n\tfmt.Printf(\"Boolean: %t\\n\", true)\n\tfmt.Printf(\"Integer: %d\\n\", 123)\n\tfmt.Printf(\"Float: %f\\n\", 3.14159)\n\tfmt.Printf(\"String: %s\\n\", \"hello\")\n\tfmt.Printf(\"Type: %T\\n\", 42)\n\tfmt.Printf(\"Value: %v\\n\", []int{1, 2, 3})\n\n\t// Test width and precision\n\tfmt.Printf(\"Width: '%5s'\\n\", \"hi\")\n\tfmt.Printf(\"Precision: '%.2f'\\n\", 3.14159)\n\tfmt.Printf(\"Both: '%5.2f'\\n\", 3.14159)\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_fmt.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as fmt from \"@goscript/fmt/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test basic Print functions\n\tfmt.Print(\"Hello\")\n\tfmt.Print(\" \")\n\tfmt.Print(\"World\")\n\tfmt.Println()\n\n\t// Test Printf with basic formatting\n\tlet name = \"Go\"\n\tlet version = 1.21\n\tfmt.Printf(\"Welcome to %s %.2f\\n\", name, version)\n\n\t// Test Println\n\tfmt.Println(\"This is println\")\n\n\t// Test Sprint functions\n\tlet result = fmt.Sprint(\"Sprint\", \" \", \"result\")\n\tfmt.Println(\"Sprint result:\", result)\n\n\t// Test Sprintf\n\tlet formatted = fmt.Sprintf(\"Number: %d, String: %s\", 42, \"test\")\n\tfmt.Println(\"Sprintf result:\", formatted)\n\n\t// Test Sprintln\n\tlet sprintln_result = fmt.Sprintln(\"Sprintln\", \"result\")\n\tfmt.Print(\"Sprintln result:\", sprintln_result)\n\n\t// Test Errorf\n\tlet err = fmt.Errorf(\"error code: %d\", 404)\n\tfmt.Println(\"Error:\", err)\n\n\t// Test various format verbs\n\tfmt.Printf(\"Boolean: %t\\n\", true)\n\tfmt.Printf(\"Integer: %d\\n\", 123)\n\tfmt.Printf(\"Float: %f\\n\", 3.14159)\n\tfmt.Printf(\"String: %s\\n\", \"hello\")\n\tfmt.Printf(\"Type: %T\\n\", 42)\n\tfmt.Printf(\"Value: %v\\n\", $.arrayToSlice<number>([1, 2, 3]))\n\n\t// Test width and precision\n\tfmt.Printf(\"Width: '%5s'\\n\", \"hi\")\n\tfmt.Printf(\"Precision: '%.2f'\\n\", 3.14159)\n\tfmt.Printf(\"Both: '%5.2f'\\n\", 3.14159)\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Hello World\nWelcome to Go 1.21\nThis is println\nSprint result: Sprint result\nSprintf result: Number: 42, String: test\nSprintln result:Sprintln result\nError: error code: 404\nBoolean: true\nInteger: 123\nFloat: 3.14159\nString: hello\nType: int\nValue: [1 2 3]\nWidth: '   hi'\nPrecision: '3.14'\nBoth: ' 3.14'\ntest finished\n"
  },
  {
    "name": "package_import_go_parser",
    "goCode": "package main\n\nimport (\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"slices\"\n)\n\nfunc main() {\n\t// Create a new token file set\n\tfset := token.NewFileSet()\n\n\t// Test parsing expressions\n\tvar results []string\n\n\t// Parse some simple expressions\n\texpressions := []string{\n\t\t\"42\",\n\t\t\"x + y\",\n\t\t\"len(slice)\",\n\t\t\"map[string]int{}\",\n\t}\n\n\tfor _, expr := range expressions {\n\t\tnode, err := parser.ParseExpr(expr)\n\t\tif err != nil {\n\t\t\tresults = append(results, \"Error parsing \"+expr+\": \"+err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Extract type information from the parsed expression\n\t\tswitch n := node.(type) {\n\t\tcase *ast.BasicLit:\n\t\t\tresults = append(results, \"BasicLit: \"+n.Value)\n\t\tcase *ast.BinaryExpr:\n\t\t\tresults = append(results, \"BinaryExpr with operator: \"+n.Op.String())\n\t\tcase *ast.CallExpr:\n\t\t\tif ident, ok := n.Fun.(*ast.Ident); ok {\n\t\t\t\tresults = append(results, \"CallExpr: \"+ident.Name)\n\t\t\t}\n\t\tcase *ast.CompositeLit:\n\t\t\tresults = append(results, \"CompositeLit (composite literal)\")\n\t\tdefault:\n\t\t\tresults = append(results, \"Unknown expression type\")\n\t\t}\n\t}\n\n\t// Test parsing a simple Go source file\n\tsrc := `package main\n\t\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := add(1, 2)\n\tprintln(result)\n}`\n\n\t// Parse the source code\n\tfile, err := parser.ParseFile(fset, \"test.go\", src, parser.ParseComments)\n\tif err != nil {\n\t\tresults = append(results, \"Error parsing file: \"+err.Error())\n\t} else {\n\t\t// Extract function names\n\t\tfor _, decl := range file.Decls {\n\t\t\tif fn, ok := decl.(*ast.FuncDecl); ok {\n\t\t\t\tresults = append(results, \"Function: \"+fn.Name.Name)\n\t\t\t}\n\t\t}\n\n\t\t// Check package name\n\t\tresults = append(results, \"Package: \"+file.Name.Name)\n\t}\n\n\t// Sort results for deterministic output\n\tslices.Sort(results)\n\n\t// Print results\n\tfor _, result := range results {\n\t\tprintln(\"Parse result:\", result)\n\t}\n\n\tprintln(\"go/parser test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_go_parser.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\";\n\nimport * as ast from \"@goscript/go/ast/index.js\"\n\nimport * as parser from \"@goscript/go/parser/index.js\"\n\nimport * as token from \"@goscript/go/token/index.js\"\n\nimport * as slices from \"@goscript/slices/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Create a new token file set\n\tlet fset = token.NewFileSet()\n\n\t// Test parsing expressions\n\tlet results: $.Slice<string> = null\n\n\t// Parse some simple expressions\n\tlet expressions = $.arrayToSlice<string>([\"42\", \"x + y\", \"len(slice)\", \"map[string]int{}\"])\n\n\t// Extract type information from the parsed expression\n\tfor (let _i = 0; _i < $.len(expressions); _i++) {\n\t\tconst expr = expressions![_i]\n\t\t{\n\t\t\tlet [node, err] = parser.ParseExpr(expr)\n\t\t\tif (err != null) {\n\t\t\t\tresults = $.append(results, \"Error parsing \" + expr + \": \" + err!.Error())\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Extract type information from the parsed expression\n\t\t\t$.typeSwitch(node, [{ types: [{kind: $.TypeKind.Pointer, elemType: 'ast.BasicLit'}], body: (n) => {\n\t\t\t\tresults = $.append(results, \"BasicLit: \" + n.Value)\n\t\t\t}},\n\t\t\t{ types: [{kind: $.TypeKind.Pointer, elemType: 'ast.BinaryExpr'}], body: (n) => {\n\t\t\t\tresults = $.append(results, \"BinaryExpr with operator: \" + token.Token_String(n.Op))\n\t\t\t}},\n\t\t\t{ types: [{kind: $.TypeKind.Pointer, elemType: 'ast.CallExpr'}], body: (n) => {\n\t\t\t\t{\n\t\t\t\t\tlet { value: ident, ok: ok } = $.typeAssert<ast.Ident | null>(n.Fun, {kind: $.TypeKind.Pointer, elemType: 'ast.Ident'})\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tresults = $.append(results, \"CallExpr: \" + ident!.Name)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}},\n\t\t\t{ types: [{kind: $.TypeKind.Pointer, elemType: 'ast.CompositeLit'}], body: (n) => {\n\t\t\t\tresults = $.append(results, \"CompositeLit (composite literal)\")\n\t\t\t}}], () => {\n\t\t\t\tresults = $.append(results, \"Unknown expression type\")\n\t\t\t})\n\t\t}\n\t}\n\n\t// Test parsing a simple Go source file\n\tlet src = `package main\n\t\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tresult := add(1, 2)\n\tprintln(result)\n}`\n\n\t// Parse the source code\n\tlet [file, err] = parser.ParseFile(fset, \"test.go\", src, parser.ParseComments)\n\n\t// Extract function names\n\n\t// Check package name\n\tif (err != null) {\n\t\tresults = $.append(results, \"Error parsing file: \" + err!.Error())\n\t}\n\t else {\n\t\t// Extract function names\n\t\tfor (let _i = 0; _i < $.len(file!.Decls); _i++) {\n\t\t\tconst decl = file!.Decls![_i]\n\t\t\t{\n\t\t\t\t{\n\t\t\t\t\tlet { value: fn, ok: ok } = $.typeAssert<ast.FuncDecl | null>(decl, {kind: $.TypeKind.Pointer, elemType: 'ast.FuncDecl'})\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tresults = $.append(results, \"Function: \" + fn!.Name!.Name)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check package name\n\t\tresults = $.append(results, \"Package: \" + file!.Name!.Name)\n\t}\n\n\t// Sort results for deterministic output\n\tslices.Sort(results)\n\n\t// Print results\n\tfor (let _i = 0; _i < $.len(results); _i++) {\n\t\tconst result = results![_i]\n\t\t{\n\t\t\tconsole.log(\"Parse result:\", result)\n\t\t}\n\t}\n\n\tconsole.log(\"go/parser test finished\")\n}\n\n",
    "expectedOutput": "Parse result: BasicLit: 42\nParse result: BinaryExpr with operator: +\nParse result: CallExpr: len\nParse result: CompositeLit (composite literal)\nParse result: Function: add\nParse result: Function: main\nParse result: Package: main\ngo/parser test finished\n"
  },
  {
    "name": "package_import_go_scanner",
    "goCode": "package main\n\nimport (\n\t\"fmt\"\n\t\"go/scanner\"\n\t\"go/token\"\n)\n\nfunc main() {\n\t// Use scanner package functionality that should generate imports\n\tvar errorList scanner.ErrorList\n\n\t// This should require importing both scanner and token packages\n\tpos := token.Position{Filename: \"test.go\", Line: 1, Column: 1}\n\terrorList.Add(pos, \"test error\")\n\n\tfmt.Printf(\"ErrorList length: %d\\n\", len(errorList))\n}\n",
    "tsCode": "// Generated file based on package_import_go_scanner.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as fmt from \"@goscript/fmt/index.js\"\n\nimport * as scanner from \"@goscript/go/scanner/index.js\"\n\nimport * as token from \"@goscript/go/token/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Use scanner package functionality that should generate imports\n\tlet errorList: $.VarRef<scanner.ErrorList> = $.varRef(null)\n\n\t// This should require importing both scanner and token packages\n\tlet pos = $.markAsStructValue(new token.Position({Column: 1, Filename: \"test.go\", Line: 1}))\n\tscanner.ErrorList_Add(errorList, pos, \"test error\")\n\n\tfmt.Printf(\"ErrorList length: %d\\n\", $.len(errorList!.value))\n}\n\n",
    "expectedOutput": "ErrorList length: 1\n"
  },
  {
    "name": "package_import_io",
    "goCode": "package main\n\nimport \"io\"\n\nfunc main() {\n\t// Test basic error variables\n\tprintln(\"EOF:\", io.EOF.Error())\n\tprintln(\"ErrClosedPipe:\", io.ErrClosedPipe.Error())\n\tprintln(\"ErrShortWrite:\", io.ErrShortWrite.Error())\n\tprintln(\"ErrUnexpectedEOF:\", io.ErrUnexpectedEOF.Error())\n\n\t// Test seek constants\n\tprintln(\"SeekStart:\", io.SeekStart)\n\tprintln(\"SeekCurrent:\", io.SeekCurrent)\n\tprintln(\"SeekEnd:\", io.SeekEnd)\n\n\t// Test Discard writer\n\tn, err := io.WriteString(io.Discard, \"hello world\")\n\tprintln(\"WriteString to Discard - bytes:\", n, \"err:\", err == nil)\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_io.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as io from \"@goscript/io/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test basic error variables\n\t$.println(\"EOF:\", io.EOF!.Error())\n\t$.println(\"ErrClosedPipe:\", io.ErrClosedPipe!.Error())\n\t$.println(\"ErrShortWrite:\", io.ErrShortWrite!.Error())\n\t$.println(\"ErrUnexpectedEOF:\", io.ErrUnexpectedEOF!.Error())\n\n\t// Test seek constants\n\t$.println(\"SeekStart:\", io.SeekStart)\n\t$.println(\"SeekCurrent:\", io.SeekCurrent)\n\t$.println(\"SeekEnd:\", io.SeekEnd)\n\n\t// Test Discard writer\n\tlet [n, err] = io.WriteString(io.Discard, \"hello world\")\n\t$.println(\"WriteString to Discard - bytes:\", n, \"err:\", err == null)\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "EOF: EOF\nErrClosedPipe: io: read/write on closed pipe\nErrShortWrite: short write\nErrUnexpectedEOF: unexpected EOF\nSeekStart: 0\nSeekCurrent: 1\nSeekEnd: 2\nWriteString to Discard - bytes: 11 err: true\ntest finished\n"
  },
  {
    "name": "package_import_io_fs",
    "goCode": "package main\n\nimport \"io/fs\"\n\nfunc main() {\n\t// Test ValidPath function\n\tvalid1 := fs.ValidPath(\"hello/world.txt\")\n\tprintln(\"ValidPath('hello/world.txt'):\", valid1)\n\n\tvalid2 := fs.ValidPath(\"../invalid\")\n\tprintln(\"ValidPath('../invalid'):\", valid2)\n\n\tvalid3 := fs.ValidPath(\".\")\n\tprintln(\"ValidPath('.'):\", valid3)\n\n\tvalid4 := fs.ValidPath(\"\")\n\tprintln(\"ValidPath(''):\", valid4)\n\n\t// Test error constants\n\tprintln(\"ErrInvalid:\", fs.ErrInvalid.Error())\n\tprintln(\"ErrNotExist:\", fs.ErrNotExist.Error())\n\tprintln(\"ErrExist:\", fs.ErrExist.Error())\n\tprintln(\"ErrPermission:\", fs.ErrPermission.Error())\n\tprintln(\"ErrClosed:\", fs.ErrClosed.Error())\n\n\t// Test all FileMode constants\n\tprintln(\"ModeDir:\", int(fs.ModeDir))\n\tprintln(\"ModeAppend:\", int(fs.ModeAppend))\n\tprintln(\"ModeExclusive:\", int(fs.ModeExclusive))\n\tprintln(\"ModeTemporary:\", int(fs.ModeTemporary))\n\tprintln(\"ModeSymlink:\", int(fs.ModeSymlink))\n\tprintln(\"ModeDevice:\", int(fs.ModeDevice))\n\tprintln(\"ModeNamedPipe:\", int(fs.ModeNamedPipe))\n\tprintln(\"ModeSocket:\", int(fs.ModeSocket))\n\tprintln(\"ModeSetuid:\", int(fs.ModeSetuid))\n\tprintln(\"ModeSetgid:\", int(fs.ModeSetgid))\n\tprintln(\"ModeCharDevice:\", int(fs.ModeCharDevice))\n\tprintln(\"ModeSticky:\", int(fs.ModeSticky))\n\tprintln(\"ModeIrregular:\", int(fs.ModeIrregular))\n\tprintln(\"ModeType:\", int(fs.ModeType))\n\tprintln(\"ModePerm:\", int(fs.ModePerm))\n\n\t// Test FileMode methods\n\tmode := fs.FileMode(fs.ModeDir | 0o755)\n\tprintln(\"FileMode.IsDir():\", mode.IsDir())\n\tprintln(\"FileMode.IsRegular():\", mode.IsRegular())\n\tprintln(\"FileMode.Perm():\", int(mode.Perm()))\n\tprintln(\"FileMode.Type():\", int(mode.Type()))\n\tprintln(\"FileMode.String():\", mode.String())\n\n\tregularMode := fs.FileMode(0o644)\n\tprintln(\"Regular file IsDir():\", regularMode.IsDir())\n\tprintln(\"Regular file IsRegular():\", regularMode.IsRegular())\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_io_fs.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as fs from \"@goscript/io/fs/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test ValidPath function\n\tlet valid1 = fs.ValidPath(\"hello/world.txt\")\n\t$.println(\"ValidPath('hello/world.txt'):\", valid1)\n\n\tlet valid2 = fs.ValidPath(\"../invalid\")\n\t$.println(\"ValidPath('../invalid'):\", valid2)\n\n\tlet valid3 = fs.ValidPath(\".\")\n\t$.println(\"ValidPath('.'):\", valid3)\n\n\tlet valid4 = fs.ValidPath(\"\")\n\t$.println(\"ValidPath(''):\", valid4)\n\n\t// Test error constants\n\t$.println(\"ErrInvalid:\", fs.ErrInvalid!.Error())\n\t$.println(\"ErrNotExist:\", fs.ErrNotExist!.Error())\n\t$.println(\"ErrExist:\", fs.ErrExist!.Error())\n\t$.println(\"ErrPermission:\", fs.ErrPermission!.Error())\n\t$.println(\"ErrClosed:\", fs.ErrClosed!.Error())\n\n\t// Test all FileMode constants\n\t$.println(\"ModeDir:\", $.int(fs.ModeDir))\n\t$.println(\"ModeAppend:\", $.int(fs.ModeAppend))\n\t$.println(\"ModeExclusive:\", $.int(fs.ModeExclusive))\n\t$.println(\"ModeTemporary:\", $.int(fs.ModeTemporary))\n\t$.println(\"ModeSymlink:\", $.int(fs.ModeSymlink))\n\t$.println(\"ModeDevice:\", $.int(fs.ModeDevice))\n\t$.println(\"ModeNamedPipe:\", $.int(fs.ModeNamedPipe))\n\t$.println(\"ModeSocket:\", $.int(fs.ModeSocket))\n\t$.println(\"ModeSetuid:\", $.int(fs.ModeSetuid))\n\t$.println(\"ModeSetgid:\", $.int(fs.ModeSetgid))\n\t$.println(\"ModeCharDevice:\", $.int(fs.ModeCharDevice))\n\t$.println(\"ModeSticky:\", $.int(fs.ModeSticky))\n\t$.println(\"ModeIrregular:\", $.int(fs.ModeIrregular))\n\t$.println(\"ModeType:\", $.int(fs.ModeType))\n\t$.println(\"ModePerm:\", $.int(fs.ModePerm))\n\n\t// Test FileMode methods\n\tlet mode = ((fs.ModeDir | 0o755) as fs.FileMode)\n\t$.println(\"FileMode.IsDir():\", fs.FileMode_IsDir(mode))\n\t$.println(\"FileMode.IsRegular():\", fs.FileMode_IsRegular(mode))\n\t$.println(\"FileMode.Perm():\", $.int(fs.FileMode_Perm(mode)))\n\t$.println(\"FileMode.Type():\", $.int(fs.FileMode_Type(mode)))\n\t$.println(\"FileMode.String():\", fs.FileMode_String(mode))\n\n\tlet regularMode = (0o644 as fs.FileMode)\n\t$.println(\"Regular file IsDir():\", fs.FileMode_IsDir(regularMode))\n\t$.println(\"Regular file IsRegular():\", fs.FileMode_IsRegular(regularMode))\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "ValidPath('hello/world.txt'): true\nValidPath('../invalid'): false\nValidPath('.'): true\nValidPath(''): false\nErrInvalid: invalid argument\nErrNotExist: file does not exist\nErrExist: file already exists\nErrPermission: permission denied\nErrClosed: file already closed\nModeDir: 2147483648\nModeAppend: 1073741824\nModeExclusive: 536870912\nModeTemporary: 268435456\nModeSymlink: 134217728\nModeDevice: 67108864\nModeNamedPipe: 33554432\nModeSocket: 16777216\nModeSetuid: 8388608\nModeSetgid: 4194304\nModeCharDevice: 2097152\nModeSticky: 1048576\nModeIrregular: 524288\nModeType: 2401763328\nModePerm: 511\nFileMode.IsDir(): true\nFileMode.IsRegular(): false\nFileMode.Perm(): 493\nFileMode.Type(): 2147483648\nFileMode.String(): drwxr-xr-x\nRegular file IsDir(): false\nRegular file IsRegular(): true\ntest finished\n"
  },
  {
    "name": "package_import_maps",
    "goCode": "package main\n\nimport (\n\t\"maps\"\n\t\"slices\"\n)\n\nfunc getValue() (string, int) {\n\treturn \"test\", 42\n}\n\n// Simple iterator function that mimics maps.All behavior\nfunc simpleIterator(m map[string]int) func(func(string, int) bool) {\n\treturn func(yield func(string, int) bool) {\n\t\tfor k, v := range m {\n\t\t\tif !yield(k, v) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Create a map to test with\n\tm := map[string]int{\n\t\t\"a\": 1,\n\t\t\"b\": 2,\n\t\t\"c\": 3,\n\t}\n\n\t// Collect results in a slice to ensure deterministic output\n\tvar results []string\n\n\t// Test maps.All which returns an iterator function (this tests the maps package import)\n\tfor k, v := range maps.All(m) {\n\t\t// Simple assignment that should trigger the error\n\t\tx, y := getValue()\n\t\tresult := k + x + string(rune(v+y))\n\t\tresults = append(results, result)\n\t}\n\n\t// Also test simpleIterator to ensure our local iterator works\n\tfor k, v := range simpleIterator(m) {\n\t\tx, y := getValue()\n\t\tresult := k + x + string(rune(v+y)) + \"_local\"\n\t\tresults = append(results, result)\n\t}\n\n\t// Sort results for deterministic output\n\tslices.Sort(results)\n\n\t// Print sorted results\n\tfor _, result := range results {\n\t\tprintln(\"Result:\", result)\n\t}\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_maps.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as maps from \"@goscript/maps/index.js\"\n\nimport * as slices from \"@goscript/slices/index.js\"\n\nexport function getValue(): [string, number] {\n\treturn [\"test\", 42]\n}\n\n// Simple iterator function that mimics maps.All behavior\nexport function simpleIterator(m: Map<string, number> | null): ((p0: ((p0: string, p1: number) => boolean) | null) => void) | null {\n\treturn (_yield: ((p0: string, p1: number) => boolean) | null): void => {\n\t\tfor (const [k, v] of m?.entries() ?? []) {\n\t\t\t{\n\t\t\t\tif (!_yield!(k, v)) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function main(): Promise<void> {\n\t// Create a map to test with\n\tlet m = new Map([[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n\n\t// Collect results in a slice to ensure deterministic output\n\tlet results: $.Slice<string> = null\n\n\t// Test maps.All which returns an iterator function (this tests the maps package import)\n\n\t// Simple assignment that should trigger the error\n\t;(() => {\n\t\tlet shouldContinue = true\n\t\tmaps.All(m)!((k, v) => {\n\t\t\t{\n\t\t\t\t// Simple assignment that should trigger the error\n\t\t\t\tlet [x, y] = getValue()\n\t\t\t\tlet result = k + x + $.runeOrStringToString(v + y)\n\t\t\t\tresults = $.append(results, result)\n\t\t\t}\n\t\t\treturn shouldContinue\n\t\t})\n\t})()\n\n\t// Also test simpleIterator to ensure our local iterator works\n\t;(() => {\n\t\tlet shouldContinue = true\n\t\tsimpleIterator(m)!((k, v) => {\n\t\t\t{\n\t\t\t\tlet [x, y] = getValue()\n\t\t\t\tlet result = k + x + $.runeOrStringToString(v + y) + \"_local\"\n\t\t\t\tresults = $.append(results, result)\n\t\t\t}\n\t\t\treturn shouldContinue\n\t\t})\n\t})()\n\n\t// Sort results for deterministic output\n\tslices.Sort(results)\n\n\t// Print sorted results\n\tfor (let _i = 0; _i < $.len(results); _i++) {\n\t\tlet result = results![_i]\n\t\t{\n\t\t\t$.println(\"Result:\", result)\n\t\t}\n\t}\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Result: atest+\nResult: atest+_local\nResult: btest,\nResult: btest,_local\nResult: ctest-\nResult: ctest-_local\ntest finished\n"
  },
  {
    "name": "package_import_os",
    "goCode": "package main\n\nimport \"os\"\n\nfunc main() {\n\t// Test Getwd - works with mock data\n\tif wd, err := os.Getwd(); err == nil {\n\t\tprintln(\"Current working directory:\", wd)\n\t} else {\n\t\tprintln(\"Error getting working directory:\", err.Error())\n\t}\n\n\t// Test Environment variables - these work\n\tos.Setenv(\"TEST_VAR\", \"test_value\")\n\tprintln(\"Set environment variable TEST_VAR\")\n\n\tif val := os.Getenv(\"TEST_VAR\"); val != \"\" {\n\t\tprintln(\"Got environment variable TEST_VAR:\", val)\n\t}\n\n\tos.Unsetenv(\"TEST_VAR\")\n\tif val := os.Getenv(\"TEST_VAR\"); val == \"\" {\n\t\tprintln(\"Environment variable TEST_VAR unset successfully\")\n\t}\n\n\t// Test Hostname - works with mock data\n\tif hostname, err := os.Hostname(); err == nil {\n\t\tprintln(\"Hostname:\", hostname)\n\t} else {\n\t\tprintln(\"Error getting hostname:\", err.Error())\n\t}\n}\n",
    "tsCode": "// Generated file based on package_import_os.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test Getwd - works with mock data\n\t{\n\t\tlet [wd, err] = os.Getwd()\n\t\tif (err == null) {\n\t\t\t$.println(\"Current working directory:\", wd)\n\t\t} else {\n\t\t\t$.println(\"Error getting working directory:\", err!.Error())\n\t\t}\n\t}\n\n\t// Test Environment variables - these work\n\tos.Setenv(\"TEST_VAR\", \"test_value\")\n\t$.println(\"Set environment variable TEST_VAR\")\n\n\t{\n\t\tlet val = os.Getenv(\"TEST_VAR\")\n\t\tif (val != \"\") {\n\t\t\t$.println(\"Got environment variable TEST_VAR:\", val)\n\t\t}\n\t}\n\n\tos.Unsetenv(\"TEST_VAR\")\n\t{\n\t\tlet val = os.Getenv(\"TEST_VAR\")\n\t\tif (val == \"\") {\n\t\t\t$.println(\"Environment variable TEST_VAR unset successfully\")\n\t\t}\n\t}\n\n\t// Test Hostname - works with mock data\n\t{\n\t\tlet [hostname, err] = os.Hostname()\n\t\tif (err == null) {\n\t\t\t$.println(\"Hostname:\", hostname)\n\t\t} else {\n\t\t\t$.println(\"Error getting hostname:\", err!.Error())\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Current working directory: /\nSet environment variable TEST_VAR\nGot environment variable TEST_VAR: test_value\nEnvironment variable TEST_VAR unset successfully\nHostname: goscript\n"
  },
  {
    "name": "package_import_path",
    "goCode": "package main\n\nimport \"path\"\n\nfunc main() {\n\t// Test Clean function\n\tcleaned := path.Clean(\"/a/b/../c/./d\")\n\tprintln(\"Clean result:\", cleaned)\n\n\t// Test Join function\n\tjoined := path.Join(\"a\", \"b\", \"c\")\n\tprintln(\"Join result:\", joined)\n\n\t// Test Base function\n\tbase := path.Base(\"/a/b/c.txt\")\n\tprintln(\"Base result:\", base)\n\n\t// Test Dir function\n\tdir := path.Dir(\"/a/b/c.txt\")\n\tprintln(\"Dir result:\", dir)\n\n\t// Test Ext function\n\text := path.Ext(\"/a/b/c.txt\")\n\tprintln(\"Ext result:\", ext)\n\n\t// Test IsAbs function\n\tisAbs := path.IsAbs(\"/a/b/c\")\n\tprintln(\"IsAbs result:\", isAbs)\n\n\t// Test Split function\n\tdir2, file := path.Split(\"/a/b/c.txt\")\n\tprintln(\"Split dir:\", dir2)\n\tprintln(\"Split file:\", file)\n\n\t// Test Match function\n\tmatched, err := path.Match(\"*.txt\", \"file.txt\")\n\tif err != nil {\n\t\tprintln(\"Match error:\", err.Error())\n\t} else {\n\t\tprintln(\"Match result:\", matched)\n\t}\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_path.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as path from \"@goscript/path/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test Clean function\n\tlet cleaned = path.Clean(\"/a/b/../c/./d\")\n\t$.println(\"Clean result:\", cleaned)\n\n\t// Test Join function\n\tlet joined = path.Join(\"a\", \"b\", \"c\")\n\t$.println(\"Join result:\", joined)\n\n\t// Test Base function\n\tlet base = path.Base(\"/a/b/c.txt\")\n\t$.println(\"Base result:\", base)\n\n\t// Test Dir function\n\tlet dir = path.Dir(\"/a/b/c.txt\")\n\t$.println(\"Dir result:\", dir)\n\n\t// Test Ext function\n\tlet ext = path.Ext(\"/a/b/c.txt\")\n\t$.println(\"Ext result:\", ext)\n\n\t// Test IsAbs function\n\tlet isAbs = path.IsAbs(\"/a/b/c\")\n\t$.println(\"IsAbs result:\", isAbs)\n\n\t// Test Split function\n\tlet [dir2, file] = path.Split(\"/a/b/c.txt\")\n\t$.println(\"Split dir:\", dir2)\n\t$.println(\"Split file:\", file)\n\n\t// Test Match function\n\tlet [matched, err] = path.Match(\"*.txt\", \"file.txt\")\n\tif (err != null) {\n\t\t$.println(\"Match error:\", err!.Error())\n\t} else {\n\t\t$.println(\"Match result:\", matched)\n\t}\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Clean result: /a/c/d\nJoin result: a/b/c\nBase result: c.txt\nDir result: /a/b\nExt result: .txt\nIsAbs result: true\nSplit dir: /a/b/\nSplit file: c.txt\nMatch result: true\ntest finished\n"
  },
  {
    "name": "package_import_path_filepath",
    "goCode": "package main\n\nimport \"path/filepath\"\n\nfunc main() {\n\t// Test Basic path operations\n\tpath := \"dir/subdir/file.txt\"\n\n\t// Test Base\n\tbase := filepath.Base(path)\n\tprintln(\"Base:\", base)\n\n\t// Test Dir\n\tdir := filepath.Dir(path)\n\tprintln(\"Dir:\", dir)\n\n\t// Test Ext\n\text := filepath.Ext(path)\n\tprintln(\"Ext:\", ext)\n\n\t// Test Clean\n\tdirty := \"dir//subdir/../subdir/./file.txt\"\n\tclean := filepath.Clean(dirty)\n\tprintln(\"Clean:\", clean)\n\n\t// Test Join\n\tjoined := filepath.Join(\"dir\", \"subdir\", \"file.txt\")\n\tprintln(\"Join:\", joined)\n\n\t// Test Split\n\tdir2, file := filepath.Split(path)\n\tprintln(\"Split dir:\", dir2)\n\tprintln(\"Split file:\", file)\n\n\t// Test IsAbs\n\tabs := filepath.IsAbs(\"/absolute/path\")\n\tprintln(\"IsAbs /absolute/path:\", abs)\n\trel := filepath.IsAbs(\"relative/path\")\n\tprintln(\"IsAbs relative/path:\", rel)\n\n\t// Test ToSlash and FromSlash\n\twindowsPath := \"dir\\\\subdir\\\\file.txt\"\n\tslashed := filepath.ToSlash(windowsPath)\n\tprintln(\"ToSlash:\", slashed)\n\tbackslashed := filepath.FromSlash(\"dir/subdir/file.txt\")\n\tprintln(\"FromSlash:\", backslashed)\n\n\t// Test VolumeName\n\tvol := filepath.VolumeName(\"C:\\\\Windows\\\\System32\")\n\tprintln(\"VolumeName:\", vol)\n\n\t// Test Match\n\tmatched, err := filepath.Match(\"*.txt\", \"file.txt\")\n\tif err == nil {\n\t\tprintln(\"Match *.txt file.txt:\", matched)\n\t}\n\n\tmatched2, err2 := filepath.Match(\"dir/*\", \"dir/file.txt\")\n\tif err2 == nil {\n\t\tprintln(\"Match dir/* dir/file.txt:\", matched2)\n\t}\n\n\t// Test HasPrefix\n\thasPrefix := filepath.HasPrefix(\"/usr/local/bin\", \"/usr/local\")\n\tprintln(\"HasPrefix /usr/local/bin /usr/local:\", hasPrefix)\n\n\t// Test IsLocal\n\tlocal := filepath.IsLocal(\"file.txt\")\n\tprintln(\"IsLocal file.txt:\", local)\n\tnonLocal := filepath.IsLocal(\"../file.txt\")\n\tprintln(\"IsLocal ../file.txt:\", nonLocal)\n\n\t// Test SplitList\n\tpathList := \"/usr/bin:/usr/local/bin:/bin\"\n\tsplit := filepath.SplitList(pathList)\n\tprintln(\"SplitList length:\", len(split))\n\tfor i, p := range split {\n\t\tprintln(\"SplitList\", i, \":\", p)\n\t}\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_path_filepath.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as filepath from \"@goscript/path/filepath/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test Basic path operations\n\tlet path = \"dir/subdir/file.txt\"\n\n\t// Test Base\n\tlet base = filepath.Base(path)\n\t$.println(\"Base:\", base)\n\n\t// Test Dir\n\tlet dir = filepath.Dir(path)\n\t$.println(\"Dir:\", dir)\n\n\t// Test Ext\n\tlet ext = filepath.Ext(path)\n\t$.println(\"Ext:\", ext)\n\n\t// Test Clean\n\tlet dirty = \"dir//subdir/../subdir/./file.txt\"\n\tlet clean = filepath.Clean(dirty)\n\t$.println(\"Clean:\", clean)\n\n\t// Test Join\n\tlet joined = filepath.Join(\"dir\", \"subdir\", \"file.txt\")\n\t$.println(\"Join:\", joined)\n\n\t// Test Split\n\tlet [dir2, file] = filepath.Split(path)\n\t$.println(\"Split dir:\", dir2)\n\t$.println(\"Split file:\", file)\n\n\t// Test IsAbs\n\tlet abs = filepath.IsAbs(\"/absolute/path\")\n\t$.println(\"IsAbs /absolute/path:\", abs)\n\tlet rel = filepath.IsAbs(\"relative/path\")\n\t$.println(\"IsAbs relative/path:\", rel)\n\n\t// Test ToSlash and FromSlash\n\tlet windowsPath = \"dir\\\\subdir\\\\file.txt\"\n\tlet slashed = filepath.ToSlash(windowsPath)\n\t$.println(\"ToSlash:\", slashed)\n\tlet backslashed = filepath.FromSlash(\"dir/subdir/file.txt\")\n\t$.println(\"FromSlash:\", backslashed)\n\n\t// Test VolumeName\n\tlet vol = filepath.VolumeName(\"C:\\\\Windows\\\\System32\")\n\t$.println(\"VolumeName:\", vol)\n\n\t// Test Match\n\tlet [matched, err] = filepath.Match(\"*.txt\", \"file.txt\")\n\tif (err == null) {\n\t\t$.println(\"Match *.txt file.txt:\", matched)\n\t}\n\n\tlet [matched2, err2] = filepath.Match(\"dir/*\", \"dir/file.txt\")\n\tif (err2 == null) {\n\t\t$.println(\"Match dir/* dir/file.txt:\", matched2)\n\t}\n\n\t// Test HasPrefix\n\tlet hasPrefix = filepath.HasPrefix(\"/usr/local/bin\", \"/usr/local\")\n\t$.println(\"HasPrefix /usr/local/bin /usr/local:\", hasPrefix)\n\n\t// Test IsLocal\n\tlet local = filepath.IsLocal(\"file.txt\")\n\t$.println(\"IsLocal file.txt:\", local)\n\tlet nonLocal = filepath.IsLocal(\"../file.txt\")\n\t$.println(\"IsLocal ../file.txt:\", nonLocal)\n\n\t// Test SplitList\n\tlet pathList = \"/usr/bin:/usr/local/bin:/bin\"\n\tlet split = filepath.SplitList(pathList)\n\t$.println(\"SplitList length:\", $.len(split))\n\tfor (let i = 0; i < $.len(split); i++) {\n\t\tlet p = split![i]\n\t\t{\n\t\t\t$.println(\"SplitList\", i, \":\", p)\n\t\t}\n\t}\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Base: file.txt\nDir: dir/subdir\nExt: .txt\nClean: dir/subdir/file.txt\nJoin: dir/subdir/file.txt\nSplit dir: dir/subdir/\nSplit file: file.txt\nIsAbs /absolute/path: true\nIsAbs relative/path: false\nToSlash: dir\\subdir\\file.txt\nFromSlash: dir/subdir/file.txt\nVolumeName: \nMatch *.txt file.txt: true\nMatch dir/* dir/file.txt: true\nHasPrefix /usr/local/bin /usr/local: true\nIsLocal file.txt: true\nIsLocal ../file.txt: false\nSplitList length: 3\nSplitList 0 : /usr/bin\nSplitList 1 : /usr/local/bin\nSplitList 2 : /bin\ntest finished\n"
  },
  {
    "name": "package_import_pkg_errors",
    "goCode": "package main\n\nimport \"github.com/pkg/errors\"\n\nfunc main() {\n\t// Test New\n\terr1 := errors.New(\"basic error\")\n\tprintln(\"New error:\", err1.Error())\n\n\t// Test Errorf\n\terr2 := errors.Errorf(\"formatted error: %d\", 42)\n\tprintln(\"Errorf error:\", err2.Error())\n\n\t// Test WithStack\n\tbaseErr := errors.New(\"base error\")\n\terr3 := errors.WithStack(baseErr)\n\tprintln(\"WithStack error:\", err3.Error())\n\n\t// Test Wrap\n\terr4 := errors.Wrap(baseErr, \"wrapped message\")\n\tprintln(\"Wrap error:\", err4.Error())\n\n\t// Test Wrapf\n\terr5 := errors.Wrapf(baseErr, \"wrapped with format: %s\", \"test\")\n\tprintln(\"Wrapf error:\", err5.Error())\n\n\t// Test WithMessage\n\terr6 := errors.WithMessage(baseErr, \"additional message\")\n\tprintln(\"WithMessage error:\", err6.Error())\n\n\t// Test WithMessagef\n\terr7 := errors.WithMessagef(baseErr, \"additional formatted message: %d\", 123)\n\tprintln(\"WithMessagef error:\", err7.Error())\n\n\t// Test Cause\n\tcause := errors.Cause(err4)\n\tprintln(\"Cause error:\", cause.Error())\n\n\t// Test nil handling\n\tnilErr := errors.WithStack(nil)\n\tif nilErr == nil {\n\t\tprintln(\"WithStack with nil returns nil\")\n\t}\n\n\tnilWrap := errors.Wrap(nil, \"message\")\n\tif nilWrap == nil {\n\t\tprintln(\"Wrap with nil returns nil\")\n\t}\n\n\t// Test Go 1.13 error handling\n\tunwrapped := errors.Unwrap(err4)\n\tif unwrapped != nil {\n\t\tprintln(\"Unwrap error:\", unwrapped.Error())\n\t}\n\n\t// Test Is\n\tif errors.Is(err4, baseErr) {\n\t\tprintln(\"Is check passed\")\n\t}\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_pkg_errors.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as errors from \"@goscript/github.com/pkg/errors/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test New\n\tlet err1 = errors.New(\"basic error\")\n\t$.println(\"New error:\", err1!.Error())\n\n\t// Test Errorf\n\tlet err2 = errors.Errorf(\"formatted error: %d\", 42)\n\t$.println(\"Errorf error:\", err2!.Error())\n\n\t// Test WithStack\n\tlet baseErr = errors.New(\"base error\")\n\tlet err3 = errors.WithStack(baseErr)\n\t$.println(\"WithStack error:\", err3!.Error())\n\n\t// Test Wrap\n\tlet err4 = errors.Wrap(baseErr, \"wrapped message\")\n\t$.println(\"Wrap error:\", err4!.Error())\n\n\t// Test Wrapf\n\tlet err5 = errors.Wrapf(baseErr, \"wrapped with format: %s\", \"test\")\n\t$.println(\"Wrapf error:\", err5!.Error())\n\n\t// Test WithMessage\n\tlet err6 = errors.WithMessage(baseErr, \"additional message\")\n\t$.println(\"WithMessage error:\", err6!.Error())\n\n\t// Test WithMessagef\n\tlet err7 = errors.WithMessagef(baseErr, \"additional formatted message: %d\", 123)\n\t$.println(\"WithMessagef error:\", err7!.Error())\n\n\t// Test Cause\n\tlet cause = errors.Cause(err4)\n\t$.println(\"Cause error:\", cause!.Error())\n\n\t// Test nil handling\n\tlet nilErr = errors.WithStack(null)\n\tif (nilErr == null) {\n\t\t$.println(\"WithStack with nil returns nil\")\n\t}\n\n\tlet nilWrap = errors.Wrap(null, \"message\")\n\tif (nilWrap == null) {\n\t\t$.println(\"Wrap with nil returns nil\")\n\t}\n\n\t// Test Go 1.13 error handling\n\tlet unwrapped = errors.Unwrap(err4)\n\tif (unwrapped != null) {\n\t\t$.println(\"Unwrap error:\", unwrapped!.Error())\n\t}\n\n\t// Test Is\n\tif (errors.Is(err4, baseErr)) {\n\t\t$.println(\"Is check passed\")\n\t}\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "New error: basic error\nErrorf error: formatted error: 42\nWithStack error: base error\nWrap error: wrapped message: base error\nWrapf error: wrapped with format: test: base error\nWithMessage error: additional message: base error\nWithMessagef error: additional formatted message: 123: base error\nCause error: base error\nWithStack with nil returns nil\nWrap with nil returns nil\nUnwrap error: wrapped message: base error\nIs check passed\ntest finished\n"
  },
  {
    "name": "package_import_reflect",
    "goCode": "package main\n\nimport \"reflect\"\n\n// Test struct reflection - moved outside main to avoid export issues\ntype Person struct {\n\tName string\n\tAge  int\n}\n\n// Test interface for type assertions\ntype Stringer interface {\n\tString() string\n}\n\nfunc main() {\n\t// Test basic reflect functions\n\tx := 42\n\tv := reflect.ValueOf(x)\n\tprintln(\"Type:\", reflect.TypeOf(x).String())\n\tprintln(\"Value:\", v.Int())\n\tprintln(\"Kind:\", v.Kind().String())\n\n\t// Test with string\n\ts := \"hello\"\n\tsv := reflect.ValueOf(s)\n\tprintln(\"String type:\", reflect.TypeOf(s).String())\n\tprintln(\"String value:\", sv.String())\n\tprintln(\"String kind:\", sv.Kind().String())\n\n\t// Test with slice\n\tslice := []int{1, 2, 3}\n\tsliceV := reflect.ValueOf(slice)\n\tprintln(\"Slice type:\", reflect.TypeOf(slice).String())\n\tprintln(\"Slice len:\", sliceV.Len())\n\tprintln(\"Slice kind:\", sliceV.Kind().String())\n\n\t// Test DeepEqual\n\ta := []int{1, 2, 3}\n\tb := []int{1, 2, 3}\n\tc := []int{1, 2, 4}\n\tprintln(\"DeepEqual a==b:\", reflect.DeepEqual(a, b))\n\tprintln(\"DeepEqual a==c:\", reflect.DeepEqual(a, c))\n\n\t// Test Zero value\n\tzeroInt := reflect.Zero(reflect.TypeOf(42))\n\tprintln(\"Zero int:\", zeroInt.Int())\n\n\t// Test type construction functions\n\tintType := reflect.TypeOf(0)\n\tsliceType := reflect.SliceOf(intType)\n\tprintln(\"SliceOf int:\", sliceType.String())\n\tprintln(\"SliceOf kind:\", sliceType.Kind().String())\n\n\tarrayType := reflect.ArrayOf(5, intType)\n\tprintln(\"ArrayOf 5 int:\", arrayType.String())\n\tprintln(\"ArrayOf kind:\", arrayType.Kind().String())\n\n\tptrType := reflect.PointerTo(intType)\n\tprintln(\"PointerTo int:\", ptrType.String())\n\tprintln(\"PointerTo kind:\", ptrType.Kind().String())\n\n\t// Test PtrTo (alias for PointerTo)\n\tptrType2 := reflect.PtrTo(intType)\n\tprintln(\"PtrTo int:\", ptrType2.String())\n\n\t// Test New and Indirect\n\tnewVal := reflect.New(intType)\n\tprintln(\"New int type:\", newVal.Type().String())\n\tindirectVal := reflect.Indirect(newVal)\n\tprintln(\"Indirect type:\", indirectVal.Type().String())\n\n\t// Test Zero values for different types\n\tzeroString := reflect.Zero(reflect.TypeOf(\"\"))\n\tprintln(\"Zero string:\", zeroString.String())\n\n\tzeroBool := reflect.Zero(reflect.TypeOf(true))\n\tprintln(\"Zero bool:\", zeroBool.String()) // Should show the type since it's not a string\n\n\t// Test Swapper function\n\ttestSlice := []int{1, 2, 3, 4, 5}\n\tswapper := reflect.Swapper(testSlice)\n\tprintln(\"Before swap:\", testSlice[0], testSlice[4])\n\tswapper(0, 4)\n\tprintln(\"After swap:\", testSlice[0], testSlice[4])\n\n\t// Test Copy function\n\tsrc := []int{10, 20, 30}\n\tdst := make([]int, 2)\n\tsrcVal := reflect.ValueOf(src)\n\tdstVal := reflect.ValueOf(dst)\n\tcopied := reflect.Copy(dstVal, srcVal)\n\tprintln(\"Copied elements:\", copied)\n\tprintln(\"Dst after copy:\", dst[0], dst[1])\n\n\t// Test struct reflection\n\tperson := Person{Name: \"Alice\", Age: 30}\n\tpersonType := reflect.TypeOf(person)\n\tprintln(\"Struct type:\", personType.String())\n\tprintln(\"Struct kind:\", personType.Kind().String())\n\n\tpersonVal := reflect.ValueOf(person)\n\tprintln(\"Struct value type:\", personVal.Type().String())\n\n\t// Test with different kinds\n\tvar f float64 = 3.14\n\tfVal := reflect.ValueOf(f)\n\tprintln(\"Float kind:\", fVal.Kind().String())\n\n\tvar boolVal bool = true\n\tbVal := reflect.ValueOf(boolVal)\n\tprintln(\"Bool kind:\", bVal.Kind().String())\n\n\t// Test type equality\n\tintType1 := reflect.TypeOf(1)\n\tintType2 := reflect.TypeOf(2)\n\tprintln(\"Same int types:\", intType1.String() == intType2.String())\n\n\tstringType := reflect.TypeOf(\"test\")\n\tprintln(\"Different types:\", intType1.String() == stringType.String())\n\n\t// Test map type construction\n\tmapType := reflect.MapOf(reflect.TypeOf(\"\"), reflect.TypeOf(0))\n\tprintln(\"MapOf string->int:\", mapType.String())\n\tprintln(\"MapOf kind:\", mapType.Kind().String())\n\n\t// Test channel direction constants\n\tprintln(\"Chan kinds available\")\n\n\t// Test pointer operations\n\t// Note: Pointer-to-pointer reflection has a compiler limitation\n\t// var ptr *int = &x\n\t// ptrVal := reflect.ValueOf(&ptr)\n\t// println(\"Pointer type:\", ptrVal.Type().String())\n\t// println(\"Pointer kind:\", ptrVal.Kind().String())\n\n\t// Test interface type\n\tvar iface interface{} = \"hello\"\n\tifaceVal := reflect.ValueOf(iface)\n\tprintln(\"Interface value type:\", ifaceVal.Type().String())\n\tprintln(\"Interface kind:\", ifaceVal.Kind().String())\n\n\t// Test function type\n\tfn := func(int) string { return \"\" }\n\tfnVal := reflect.ValueOf(fn)\n\tprintln(\"Function type:\", fnVal.Type().String())\n\tprintln(\"Function kind:\", fnVal.Kind().String())\n\n\t// Test more complex types\n\tcomplexSlice := [][]int{{1, 2}, {3, 4}}\n\tcomplexVal := reflect.ValueOf(complexSlice)\n\tprintln(\"Complex slice type:\", complexVal.Type().String())\n\tprintln(\"Complex slice kind:\", complexVal.Kind().String())\n\tprintln(\"Complex slice len:\", complexVal.Len())\n\n\t// Test type methods\n\tprintln(\"Type size methods:\")\n\tprintln(\"Int size:\", reflect.TypeOf(0).Size())\n\tprintln(\"String size:\", reflect.TypeOf(\"\").Size())\n\tprintln(\"Slice size:\", reflect.TypeOf([]int{}).Size())\n\n\t// Test enhanced API surface - functions to implement\n\tprintln(\"Enhanced API tests:\")\n\n\t// Test MakeSlice\n\tsliceTypeInt := reflect.SliceOf(reflect.TypeOf(0))\n\tnewSlice := reflect.MakeSlice(sliceTypeInt, 3, 5)\n\tprintln(\"MakeSlice len:\", newSlice.Len())\n\tprintln(\"MakeSlice type:\", newSlice.Type().String())\n\n\t// Test MakeMap\n\tmapTypeStr := reflect.MapOf(reflect.TypeOf(\"\"), reflect.TypeOf(0))\n\tnewMap := reflect.MakeMap(mapTypeStr)\n\tprintln(\"MakeMap type:\", newMap.Type().String())\n\n\t// Test Append\n\toriginalSlice := reflect.ValueOf([]int{1, 2})\n\tappendedSlice := reflect.Append(originalSlice, reflect.ValueOf(3))\n\tprintln(\"Append result len:\", appendedSlice.Len())\n\n\t// Test channel types\n\tchanType := reflect.ChanOf(reflect.BothDir, reflect.TypeOf(0))\n\tprintln(\"ChanOf type:\", chanType.String())\n\tprintln(\"ChanOf kind:\", chanType.Kind().String())\n\n\t// Test MakeChan\n\tnewChan := reflect.MakeChan(chanType, 0)\n\tprintln(\"MakeChan type:\", newChan.Type().String())\n\n\t// Test different channel directions\n\tsendOnlyChan := reflect.ChanOf(reflect.SendDir, reflect.TypeOf(\"\"))\n\tprintln(\"SendOnly chan type:\", sendOnlyChan.String())\n\n\trecvOnlyChan := reflect.ChanOf(reflect.RecvDir, reflect.TypeOf(true))\n\tprintln(\"RecvOnly chan type:\", recvOnlyChan.String())\n\n\t// Test channels with different element types\n\tstringChanType := reflect.ChanOf(reflect.BothDir, reflect.TypeOf(\"\"))\n\tstringChan := reflect.MakeChan(stringChanType, 5)\n\tprintln(\"String chan type:\", stringChan.Type().String())\n\tprintln(\"String chan elem type:\", stringChan.Type().Elem().String())\n\n\t// Test buffered vs unbuffered channels\n\tunbufferedChan := reflect.MakeChan(chanType, 0)\n\tbufferedChan := reflect.MakeChan(chanType, 10)\n\tprintln(\"Unbuffered chan type:\", unbufferedChan.Type().String())\n\tprintln(\"Buffered chan type:\", bufferedChan.Type().String())\n\n\t// Test channel reflection properties\n\tprintln(\"Chan elem type:\", chanType.Elem().String())\n\tprintln(\"Chan elem kind:\", chanType.Elem().Kind().String())\n\tprintln(\"Chan size:\", chanType.Size())\n\n\t// Test Select functionality\n\tintChan := reflect.MakeChan(reflect.ChanOf(reflect.BothDir, reflect.TypeOf(0)), 1)\n\tstrChan := reflect.MakeChan(reflect.ChanOf(reflect.BothDir, reflect.TypeOf(\"\")), 1)\n\n\t// Send values to only the string channel to make select deterministic\n\tstrChan.Send(reflect.ValueOf(\"hello\"))\n\n\tcases := []reflect.SelectCase{\n\t\t{Dir: reflect.SelectRecv, Chan: intChan},\n\t\t{Dir: reflect.SelectRecv, Chan: strChan},\n\t\t{Dir: reflect.SelectDefault},\n\t}\n\tchosen, recv, recvOK := reflect.Select(cases)\n\tprintln(\"Select chosen:\", chosen, \"recvOK:\", recvOK)\n\tif recv.IsValid() {\n\t\tprintln(\"Select recv type:\", recv.Type().String())\n\t\t// Print the actual received value\n\t\tif chosen == 0 {\n\t\t\tprintln(\"Select recv value:\", recv.Int())\n\t\t} else if chosen == 1 {\n\t\t\tprintln(\"Select recv value:\", recv.String())\n\t\t}\n\t} else {\n\t\tprintln(\"Select recv type: invalid\")\n\t}\n}\n",
    "tsCode": "// Generated file based on package_import_reflect.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"Age\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport type Stringer = null | {\n\tString(): string\n}\n\n$.registerInterfaceType(\n  'main.Stringer',\n  null, // Zero value for interface is null\n  [{ name: \"String\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport async function main(): Promise<void> {\n\t// Test basic reflect functions\n\tlet x = 42\n\tlet v = $.markAsStructValue(reflect.ValueOf(x).clone())\n\t$.println(\"Type:\", reflect.TypeOf(x)!.String())\n\t$.println(\"Value:\", v.Int())\n\t$.println(\"Kind:\", reflect.Kind_String(v.Kind()))\n\n\t// Test with string\n\tlet s = \"hello\"\n\tlet sv = $.markAsStructValue(reflect.ValueOf(s).clone())\n\t$.println(\"String type:\", reflect.TypeOf(s)!.String())\n\t$.println(\"String value:\", sv.String())\n\t$.println(\"String kind:\", reflect.Kind_String(sv.Kind()))\n\n\t// Test with slice\n\tlet slice = $.arrayToSlice<number>([1, 2, 3])\n\tlet sliceV = $.markAsStructValue(reflect.ValueOf(slice).clone())\n\t$.println(\"Slice type:\", reflect.TypeOf(slice)!.String())\n\t$.println(\"Slice len:\", sliceV.Len())\n\t$.println(\"Slice kind:\", reflect.Kind_String(sliceV.Kind()))\n\n\t// Test DeepEqual\n\tlet a = $.arrayToSlice<number>([1, 2, 3])\n\tlet b = $.arrayToSlice<number>([1, 2, 3])\n\tlet c = $.arrayToSlice<number>([1, 2, 4])\n\t$.println(\"DeepEqual a==b:\", reflect.DeepEqual(a, b))\n\t$.println(\"DeepEqual a==c:\", reflect.DeepEqual(a, c))\n\n\t// Test Zero value\n\tlet zeroInt = $.markAsStructValue(reflect.Zero(reflect.TypeOf(42)).clone())\n\t$.println(\"Zero int:\", zeroInt.Int())\n\n\t// Test type construction functions\n\tlet intType = reflect.TypeOf(0)\n\tlet sliceType = reflect.SliceOf(intType)\n\t$.println(\"SliceOf int:\", sliceType!.String())\n\t$.println(\"SliceOf kind:\", reflect.Kind_String(sliceType!.Kind()))\n\n\tlet arrayType = reflect.ArrayOf(5, intType)\n\t$.println(\"ArrayOf 5 int:\", arrayType!.String())\n\t$.println(\"ArrayOf kind:\", reflect.Kind_String(arrayType!.Kind()))\n\n\tlet ptrType = reflect.PointerTo(intType)\n\t$.println(\"PointerTo int:\", ptrType!.String())\n\t$.println(\"PointerTo kind:\", reflect.Kind_String(ptrType!.Kind()))\n\n\t// Test PtrTo (alias for PointerTo)\n\tlet ptrType2 = reflect.PtrTo(intType)\n\t$.println(\"PtrTo int:\", ptrType2!.String())\n\n\t// Test New and Indirect\n\tlet newVal = $.markAsStructValue(reflect.New(intType).clone())\n\t$.println(\"New int type:\", newVal.Type()!.String())\n\tlet indirectVal = $.markAsStructValue(reflect.Indirect(newVal).clone())\n\t$.println(\"Indirect type:\", indirectVal.Type()!.String())\n\n\t// Test Zero values for different types\n\tlet zeroString = $.markAsStructValue(reflect.Zero(reflect.TypeOf(\"\")).clone())\n\t$.println(\"Zero string:\", zeroString.String())\n\n\tlet zeroBool = $.markAsStructValue(reflect.Zero(reflect.TypeOf(true)).clone())\n\t$.println(\"Zero bool:\", zeroBool.String()) // Should show the type since it's not a string\n\n\t// Test Swapper function\n\tlet testSlice = $.arrayToSlice<number>([1, 2, 3, 4, 5])\n\tlet swapper = reflect.Swapper(testSlice)\n\t$.println(\"Before swap:\", testSlice![0], testSlice![4])\n\tswapper!(0, 4)\n\t$.println(\"After swap:\", testSlice![0], testSlice![4])\n\n\t// Test Copy function\n\tlet src = $.arrayToSlice<number>([10, 20, 30])\n\tlet dst = $.makeSlice<number>(2, undefined, 'number')\n\tlet srcVal = $.markAsStructValue(reflect.ValueOf(src).clone())\n\tlet dstVal = $.markAsStructValue(reflect.ValueOf(dst).clone())\n\tlet copied = reflect.Copy(dstVal, srcVal)\n\t$.println(\"Copied elements:\", copied)\n\t$.println(\"Dst after copy:\", dst![0], dst![1])\n\n\t// Test struct reflection\n\tlet person = $.markAsStructValue(new Person({Age: 30, Name: \"Alice\"}))\n\tlet personType = reflect.TypeOf(person)\n\t$.println(\"Struct type:\", personType!.String())\n\t$.println(\"Struct kind:\", reflect.Kind_String(personType!.Kind()))\n\n\tlet personVal = $.markAsStructValue(reflect.ValueOf(person).clone())\n\t$.println(\"Struct value type:\", personVal.Type()!.String())\n\n\t// Test with different kinds\n\tlet f: number = 3.14\n\tlet fVal = $.markAsStructValue(reflect.ValueOf(f).clone())\n\t$.println(\"Float kind:\", reflect.Kind_String(fVal.Kind()))\n\n\tlet boolVal: boolean = true\n\tlet bVal = $.markAsStructValue(reflect.ValueOf(boolVal).clone())\n\t$.println(\"Bool kind:\", reflect.Kind_String(bVal.Kind()))\n\n\t// Test type equality\n\tlet intType1 = reflect.TypeOf(1)\n\tlet intType2 = reflect.TypeOf(2)\n\t$.println(\"Same int types:\", intType1!.String() == intType2!.String())\n\n\tlet stringType = reflect.TypeOf(\"test\")\n\t$.println(\"Different types:\", intType1!.String() == stringType!.String())\n\n\t// Test map type construction\n\tlet mapType = reflect.MapOf(reflect.TypeOf(\"\"), reflect.TypeOf(0))\n\t$.println(\"MapOf string->int:\", mapType!.String())\n\t$.println(\"MapOf kind:\", reflect.Kind_String(mapType!.Kind()))\n\n\t// Test channel direction constants\n\t$.println(\"Chan kinds available\")\n\n\t// Test pointer operations\n\t// Note: Pointer-to-pointer reflection has a compiler limitation\n\t// var ptr *int = &x\n\t// ptrVal := reflect.ValueOf(&ptr)\n\t// println(\"Pointer type:\", ptrVal.Type().String())\n\t// println(\"Pointer kind:\", ptrVal.Kind().String())\n\n\t// Test interface type\n\tlet iface: null | any = \"hello\"\n\tlet ifaceVal = $.markAsStructValue(reflect.ValueOf(iface).clone())\n\t$.println(\"Interface value type:\", ifaceVal.Type()!.String())\n\t$.println(\"Interface kind:\", reflect.Kind_String(ifaceVal.Kind()))\n\n\t// Test function type\n\tlet fn = (() => {\n\t\tconst fn = (): string => {\n\t\t\treturn \"\"\n\t\t}\n\t\tfn.__typeInfo = {\n\t\t\tkind: $.TypeKind.Function,\n\t\t\tparams: ['int'],\n\t\t\tresults: ['string'],\n\t\t}\n\t\treturn fn\n\t})()\n\tlet fnVal = $.markAsStructValue(reflect.ValueOf(fn).clone())\n\t$.println(\"Function type:\", fnVal.Type()!.String())\n\t$.println(\"Function kind:\", reflect.Kind_String(fnVal.Kind()))\n\n\t// Test more complex types\n\tlet complexSlice = $.arrayToSlice<$.Slice<number>>([[ 1, 2 ], [ 3, 4 ]], 2)\n\tlet complexVal = $.markAsStructValue(reflect.ValueOf(complexSlice).clone())\n\t$.println(\"Complex slice type:\", complexVal.Type()!.String())\n\t$.println(\"Complex slice kind:\", reflect.Kind_String(complexVal.Kind()))\n\t$.println(\"Complex slice len:\", complexVal.Len())\n\n\t// Test type methods\n\t$.println(\"Type size methods:\")\n\t$.println(\"Int size:\", reflect.TypeOf(0)!.Size())\n\t$.println(\"String size:\", reflect.TypeOf(\"\")!.Size())\n\t$.println(\"Slice size:\", reflect.TypeOf($.arrayToSlice<number>([]))!.Size())\n\n\t// Test enhanced API surface - functions to implement\n\t$.println(\"Enhanced API tests:\")\n\n\t// Test MakeSlice\n\tlet sliceTypeInt = reflect.SliceOf(reflect.TypeOf(0))\n\tlet newSlice = $.markAsStructValue(reflect.MakeSlice(sliceTypeInt, 3, 5).clone())\n\t$.println(\"MakeSlice len:\", newSlice.Len())\n\t$.println(\"MakeSlice type:\", newSlice.Type()!.String())\n\n\t// Test MakeMap\n\tlet mapTypeStr = reflect.MapOf(reflect.TypeOf(\"\"), reflect.TypeOf(0))\n\tlet newMap = $.markAsStructValue(reflect.MakeMap(mapTypeStr).clone())\n\t$.println(\"MakeMap type:\", newMap.Type()!.String())\n\n\t// Test Append\n\tlet originalSlice = $.markAsStructValue(reflect.ValueOf($.arrayToSlice<number>([1, 2])).clone())\n\tlet appendedSlice = $.markAsStructValue(reflect.Append(originalSlice, reflect.ValueOf(3)).clone())\n\t$.println(\"Append result len:\", appendedSlice.Len())\n\n\t// Test channel types\n\tlet chanType = reflect.ChanOf(reflect.BothDir, reflect.TypeOf(0))\n\t$.println(\"ChanOf type:\", chanType!.String())\n\t$.println(\"ChanOf kind:\", reflect.Kind_String(chanType!.Kind()))\n\n\t// Test MakeChan\n\tlet newChan = $.markAsStructValue(reflect.MakeChan(chanType, 0).clone())\n\t$.println(\"MakeChan type:\", newChan.Type()!.String())\n\n\t// Test different channel directions\n\tlet sendOnlyChan = reflect.ChanOf(reflect.SendDir, reflect.TypeOf(\"\"))\n\t$.println(\"SendOnly chan type:\", sendOnlyChan!.String())\n\n\tlet recvOnlyChan = reflect.ChanOf(reflect.RecvDir, reflect.TypeOf(true))\n\t$.println(\"RecvOnly chan type:\", recvOnlyChan!.String())\n\n\t// Test channels with different element types\n\tlet stringChanType = reflect.ChanOf(reflect.BothDir, reflect.TypeOf(\"\"))\n\tlet stringChan = $.markAsStructValue(reflect.MakeChan(stringChanType, 5).clone())\n\t$.println(\"String chan type:\", stringChan.Type()!.String())\n\t$.println(\"String chan elem type:\", stringChan.Type()!.Elem()!.String())\n\n\t// Test buffered vs unbuffered channels\n\tlet unbufferedChan = $.markAsStructValue(reflect.MakeChan(chanType, 0).clone())\n\tlet bufferedChan = $.markAsStructValue(reflect.MakeChan(chanType, 10).clone())\n\t$.println(\"Unbuffered chan type:\", unbufferedChan.Type()!.String())\n\t$.println(\"Buffered chan type:\", bufferedChan.Type()!.String())\n\n\t// Test channel reflection properties\n\t$.println(\"Chan elem type:\", chanType!.Elem()!.String())\n\t$.println(\"Chan elem kind:\", reflect.Kind_String(chanType!.Elem()!.Kind()))\n\t$.println(\"Chan size:\", chanType!.Size())\n\n\t// Test Select functionality\n\tlet intChan = $.markAsStructValue(reflect.MakeChan(reflect.ChanOf(reflect.BothDir, reflect.TypeOf(0)), 1).clone())\n\tlet strChan = $.markAsStructValue(reflect.MakeChan(reflect.ChanOf(reflect.BothDir, reflect.TypeOf(\"\")), 1).clone())\n\n\t// Send values to only the string channel to make select deterministic\n\tstrChan.Send(reflect.ValueOf(\"hello\"))\n\n\tlet cases = $.arrayToSlice<reflect.SelectCase>([$.markAsStructValue(new reflect.SelectCase({Chan: intChan, Dir: reflect.SelectRecv})), $.markAsStructValue(new reflect.SelectCase({Chan: strChan, Dir: reflect.SelectRecv})), $.markAsStructValue(new reflect.SelectCase({Dir: reflect.SelectDefault}))])\n\tlet [chosen, recv, recvOK] = reflect.Select(cases)\n\t$.println(\"Select chosen:\", chosen, \"recvOK:\", recvOK)\n\n\t// Print the actual received value\n\tif (recv.IsValid()) {\n\t\t$.println(\"Select recv type:\", recv.Type()!.String())\n\t\t// Print the actual received value\n\t\tif (chosen == 0) {\n\t\t\t$.println(\"Select recv value:\", recv.Int())\n\t\t} else if (chosen == 1) {\n\t\t\t$.println(\"Select recv value:\", recv.String())\n\t\t}\n\t} else {\n\t\t$.println(\"Select recv type: invalid\")\n\t}\n}\n\n",
    "expectedOutput": "Type: int\nValue: 42\nKind: int\nString type: string\nString value: hello\nString kind: string\nSlice type: []int\nSlice len: 3\nSlice kind: slice\nDeepEqual a==b: true\nDeepEqual a==c: false\nZero int: 0\nSliceOf int: []int\nSliceOf kind: slice\nArrayOf 5 int: [5]int\nArrayOf kind: array\nPointerTo int: *int\nPointerTo kind: ptr\nPtrTo int: *int\nNew int type: *int\nIndirect type: int\nZero string: \nZero bool: <bool Value>\nBefore swap: 1 5\nAfter swap: 5 1\nCopied elements: 2\nDst after copy: 10 20\nStruct type: main.Person\nStruct kind: struct\nStruct value type: main.Person\nFloat kind: float64\nBool kind: bool\nSame int types: true\nDifferent types: false\nMapOf string->int: map[string]int\nMapOf kind: map\nChan kinds available\nInterface value type: string\nInterface kind: string\nFunction type: func(int) string\nFunction kind: func\nComplex slice type: [][]int\nComplex slice kind: slice\nComplex slice len: 2\nType size methods:\nInt size: 8\nString size: 16\nSlice size: 24\nEnhanced API tests:\nMakeSlice len: 3\nMakeSlice type: []int\nMakeMap type: map[string]int\nAppend result len: 3\nChanOf type: chan int\nChanOf kind: chan\nMakeChan type: chan int\nSendOnly chan type: chan<- string\nRecvOnly chan type: <-chan bool\nString chan type: chan string\nString chan elem type: string\nUnbuffered chan type: chan int\nBuffered chan type: chan int\nChan elem type: int\nChan elem kind: int\nChan size: 8\nSelect chosen: 1 recvOK: true\nSelect recv type: string\nSelect recv value: hello\n"
  },
  {
    "name": "package_import_runtime",
    "goCode": "package main\n\nimport \"runtime\"\n\nfunc main() {\n\t// Test basic runtime functions\n\tprintln(\"GOOS:\", runtime.GOOS)\n\tprintln(\"GOARCH:\", runtime.GOARCH)\n\t// println(\"Version:\", runtime.Version()) - not stable for the test (go.mod may change)\n\t// println(\"NumCPU:\", runtime.NumCPU()) - not stable for the test (number of cores may change)\n\n\t// Test GOMAXPROCS\n\tprocs := runtime.GOMAXPROCS(0) // Get current value\n\tprintln(\"GOMAXPROCS(-1):\", runtime.GOMAXPROCS(-1))\n\tprintln(\"GOMAXPROCS(0):\", procs)\n\n\t// Test NumGoroutine\n\tprintln(\"NumGoroutine:\", runtime.NumGoroutine())\n\n\t// Test GC (should be no-op)\n\truntime.GC()\n\tprintln(\"GC called successfully\")\n}\n",
    "tsCode": "// Generated file based on package_import_runtime.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as runtime from \"@goscript/runtime/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test basic runtime functions\n\t$.println(\"GOOS:\", runtime.GOOS)\n\n\t// println(\"Version:\", runtime.Version()) - not stable for the test (go.mod may change)\n\t// println(\"NumCPU:\", runtime.NumCPU()) - not stable for the test (number of cores may change)\n\t$.println(\"GOARCH:\", runtime.GOARCH)\n\n\t// Test GOMAXPROCS\n\tlet procs = runtime.GOMAXPROCS(0) // Get current value\n\t$.println(\"GOMAXPROCS(-1):\", runtime.GOMAXPROCS(-1))\n\t$.println(\"GOMAXPROCS(0):\", procs)\n\n\t// Test NumGoroutine\n\t$.println(\"NumGoroutine:\", runtime.NumGoroutine())\n\n\t// Test GC (should be no-op)\n\tawait runtime.GC()\n\t$.println(\"GC called successfully\")\n}\n\n",
    "expectedOutput": "GOOS: js\nGOARCH: wasm\nGOMAXPROCS(-1): 1\nGOMAXPROCS(0): 1\nNumGoroutine: 1\nGC called successfully\n"
  },
  {
    "name": "package_import_slices",
    "goCode": "package main\n\nimport \"slices\"\n\nfunc main() {\n\ts := []int{1, 2, 3, 4, 5}\n\n\t// This should trigger the interface range issue\n\t// slices.All returns an iterator interface that can be ranged over\n\tfor i, v := range slices.All(s) {\n\t\tprintln(\"index:\", i, \"value:\", v)\n\t}\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_slices.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as slices from \"@goscript/slices/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet s = $.arrayToSlice<number>([1, 2, 3, 4, 5])\n\n\t// This should trigger the interface range issue\n\t// slices.All returns an iterator interface that can be ranged over\n\t;(() => {\n\t\tlet shouldContinue = true\n\t\tslices.All(s)!((i, v) => {\n\t\t\t{\n\t\t\t\t$.println(\"index:\", i, \"value:\", v)\n\t\t\t}\n\t\t\treturn shouldContinue\n\t\t})\n\t})()\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "index: 0 value: 1\nindex: 1 value: 2\nindex: 2 value: 3\nindex: 3 value: 4\nindex: 4 value: 5\ntest finished\n"
  },
  {
    "name": "package_import_sort",
    "goCode": "package main\n\nimport \"sort\"\n\nfunc main() {\n\t// Test basic slice sorting\n\tints := []int{3, 1, 4, 1, 5, 9}\n\tprintln(\"Original ints:\", ints[0], ints[1], ints[2], ints[3], ints[4], ints[5])\n\tsort.Ints(ints)\n\tprintln(\"Sorted ints:\", ints[0], ints[1], ints[2], ints[3], ints[4], ints[5])\n\n\t// Test if sorted\n\tisSorted := sort.IntsAreSorted(ints)\n\tprintln(\"Ints are sorted:\", isSorted)\n\n\t// Test string sorting\n\tstrings := []string{\"banana\", \"apple\", \"cherry\"}\n\tprintln(\"Original strings:\", strings[0], strings[1], strings[2])\n\tsort.Strings(strings)\n\tprintln(\"Sorted strings:\", strings[0], strings[1], strings[2])\n\n\t// Test if strings are sorted\n\tstringSorted := sort.StringsAreSorted(strings)\n\tprintln(\"Strings are sorted:\", stringSorted)\n\n\t// Test float64 sorting\n\tfloats := []float64{3.14, 2.71, 1.41}\n\tprintln(\"Original floats:\", floats[0], floats[1], floats[2])\n\tsort.Float64s(floats)\n\tprintln(\"Sorted floats:\", floats[0], floats[1], floats[2])\n\n\t// Test if floats are sorted\n\tfloatSorted := sort.Float64sAreSorted(floats)\n\tprintln(\"Floats are sorted:\", floatSorted)\n\n\t// Test search functions\n\tintIndex := sort.SearchInts(ints, 4)\n\tprintln(\"Index of 4 in sorted ints:\", intIndex)\n\n\tstringIndex := sort.SearchStrings(strings, \"banana\")\n\tprintln(\"Index of 'banana' in sorted strings:\", stringIndex)\n\n\tfloatIndex := sort.SearchFloat64s(floats, 2.71)\n\tprintln(\"Index of 2.71 in sorted floats:\", floatIndex)\n\n\t// Test generic Search function\n\tsearchResult := sort.Search(len(ints), func(i int) bool {\n\t\treturn ints[i] >= 5\n\t})\n\tprintln(\"First index where value >= 5:\", searchResult)\n\n\t// Test Slice function with custom comparator\n\ttestSlice := []int{5, 2, 8, 1, 9}\n\tsort.Slice(testSlice, func(i, j int) bool {\n\t\treturn testSlice[i] < testSlice[j]\n\t})\n\tprintln(\"Custom sorted slice:\", testSlice[0], testSlice[1], testSlice[2], testSlice[3], testSlice[4])\n\n\t// Test SliceIsSorted\n\tisSliceSorted := sort.SliceIsSorted(testSlice, func(i, j int) bool {\n\t\treturn testSlice[i] < testSlice[j]\n\t})\n\tprintln(\"Custom slice is sorted:\", isSliceSorted)\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_sort.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as sort from \"@goscript/sort/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test basic slice sorting\n\tlet ints = $.arrayToSlice<number>([3, 1, 4, 1, 5, 9])\n\t$.println(\"Original ints:\", ints![0], ints![1], ints![2], ints![3], ints![4], ints![5])\n\tsort.Ints(ints)\n\t$.println(\"Sorted ints:\", ints![0], ints![1], ints![2], ints![3], ints![4], ints![5])\n\n\t// Test if sorted\n\tlet isSorted = sort.IntsAreSorted(ints)\n\t$.println(\"Ints are sorted:\", isSorted)\n\n\t// Test string sorting\n\tlet strings = $.arrayToSlice<string>([\"banana\", \"apple\", \"cherry\"])\n\t$.println(\"Original strings:\", strings![0], strings![1], strings![2])\n\tsort.Strings(strings)\n\t$.println(\"Sorted strings:\", strings![0], strings![1], strings![2])\n\n\t// Test if strings are sorted\n\tlet stringSorted = sort.StringsAreSorted(strings)\n\t$.println(\"Strings are sorted:\", stringSorted)\n\n\t// Test float64 sorting\n\tlet floats = $.arrayToSlice<number>([3.14, 2.71, 1.41])\n\t$.println(\"Original floats:\", floats![0], floats![1], floats![2])\n\tsort.Float64s(floats)\n\t$.println(\"Sorted floats:\", floats![0], floats![1], floats![2])\n\n\t// Test if floats are sorted\n\tlet floatSorted = sort.Float64sAreSorted(floats)\n\t$.println(\"Floats are sorted:\", floatSorted)\n\n\t// Test search functions\n\tlet intIndex = sort.SearchInts(ints, 4)\n\t$.println(\"Index of 4 in sorted ints:\", intIndex)\n\n\tlet stringIndex = sort.SearchStrings(strings, \"banana\")\n\t$.println(\"Index of 'banana' in sorted strings:\", stringIndex)\n\n\tlet floatIndex = sort.SearchFloat64s(floats, 2.71)\n\t$.println(\"Index of 2.71 in sorted floats:\", floatIndex)\n\n\t// Test generic Search function\n\tlet searchResult = sort.Search($.len(ints), (i: number): boolean => {\n\t\treturn ints![i] >= 5\n\t})\n\t$.println(\"First index where value >= 5:\", searchResult)\n\n\t// Test Slice function with custom comparator\n\tlet testSlice = $.arrayToSlice<number>([5, 2, 8, 1, 9])\n\tsort.Slice(testSlice, (i: number, j: number): boolean => {\n\t\treturn testSlice![i] < testSlice![j]\n\t})\n\t$.println(\"Custom sorted slice:\", testSlice![0], testSlice![1], testSlice![2], testSlice![3], testSlice![4])\n\n\t// Test SliceIsSorted\n\tlet isSliceSorted = sort.SliceIsSorted(testSlice, (i: number, j: number): boolean => {\n\t\treturn testSlice![i] < testSlice![j]\n\t})\n\t$.println(\"Custom slice is sorted:\", isSliceSorted)\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Original ints: 3 1 4 1 5 9\nSorted ints: 1 1 3 4 5 9\nInts are sorted: true\nOriginal strings: banana apple cherry\nSorted strings: apple banana cherry\nStrings are sorted: true\nOriginal floats: 3.14 2.71 1.41\nSorted floats: 1.41 2.71 3.14\nFloats are sorted: true\nIndex of 4 in sorted ints: 3\nIndex of 'banana' in sorted strings: 1\nIndex of 2.71 in sorted floats: 1\nFirst index where value >= 5: 4\nCustom sorted slice: 1 2 5 8 9\nCustom slice is sorted: true\ntest finished\n"
  },
  {
    "name": "package_import_strconv",
    "goCode": "package main\n\nimport \"strconv\"\n\nfunc main() {\n\t// Test Atoi\n\ti, err := strconv.Atoi(\"42\")\n\tif err == nil {\n\t\tprintln(\"Atoi result:\", i)\n\t}\n\n\t// Test Itoa\n\ts := strconv.Itoa(123)\n\tprintln(\"Itoa result:\", s)\n\n\t// Test ParseInt\n\ti64, err := strconv.ParseInt(\"456\", 10, 64)\n\tif err == nil {\n\t\tprintln(\"ParseInt result:\", i64)\n\t}\n\n\t// Test FormatInt\n\tformatted := strconv.FormatInt(789, 10)\n\tprintln(\"FormatInt result:\", formatted)\n\n\t// Test ParseFloat\n\tf, err := strconv.ParseFloat(\"3.14\", 64)\n\tif err == nil {\n\t\tprintln(\"ParseFloat result:\", strconv.FormatFloat(f, 'f', 2, 64))\n\t}\n\n\t// Test FormatFloat\n\tfloatStr := strconv.FormatFloat(2.718, 'f', 3, 64)\n\tprintln(\"FormatFloat result:\", floatStr)\n\n\t// Test ParseBool\n\tb, err := strconv.ParseBool(\"true\")\n\tif err == nil {\n\t\tprintln(\"ParseBool result:\", b)\n\t}\n\n\t// Test FormatBool\n\tboolStr := strconv.FormatBool(false)\n\tprintln(\"FormatBool result:\", boolStr)\n\n\t// Test Quote\n\tquoted := strconv.Quote(\"hello world\")\n\tprintln(\"Quote result:\", quoted)\n\n\t// Test Unquote\n\tunquoted, err := strconv.Unquote(`\"hello world\"`)\n\tif err == nil {\n\t\tprintln(\"Unquote result:\", unquoted)\n\t}\n\n\t// Test error cases\n\t_, err = strconv.Atoi(\"invalid\")\n\tif err != nil {\n\t\tprintln(\"Atoi error handled\")\n\t}\n\n\t_, err = strconv.ParseFloat(\"invalid\", 64)\n\tif err != nil {\n\t\tprintln(\"ParseFloat error handled\")\n\t}\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_strconv.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as strconv from \"@goscript/strconv/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test Atoi\n\tlet [i, err] = strconv.Atoi(\"42\")\n\tif (err == null) {\n\t\t$.println(\"Atoi result:\", i)\n\t}\n\n\t// Test Itoa\n\tlet s = strconv.Itoa(123)\n\t$.println(\"Itoa result:\", s)\n\n\t// Test ParseInt\n\tlet i64: number\n\t[i64, err] = strconv.ParseInt(\"456\", 10, 64)\n\tif (err == null) {\n\t\t$.println(\"ParseInt result:\", i64)\n\t}\n\n\t// Test FormatInt\n\tlet formatted = strconv.FormatInt(789, 10)\n\t$.println(\"FormatInt result:\", formatted)\n\n\t// Test ParseFloat\n\tlet f: number\n\t[f, err] = strconv.ParseFloat(\"3.14\", 64)\n\tif (err == null) {\n\t\t$.println(\"ParseFloat result:\", strconv.FormatFloat(f, 102, 2, 64))\n\t}\n\n\t// Test FormatFloat\n\tlet floatStr = strconv.FormatFloat(2.718, 102, 3, 64)\n\t$.println(\"FormatFloat result:\", floatStr)\n\n\t// Test ParseBool\n\tlet b: boolean\n\t[b, err] = strconv.ParseBool(\"true\")\n\tif (err == null) {\n\t\t$.println(\"ParseBool result:\", b)\n\t}\n\n\t// Test FormatBool\n\tlet boolStr = strconv.FormatBool(false)\n\t$.println(\"FormatBool result:\", boolStr)\n\n\t// Test Quote\n\tlet quoted = strconv.Quote(\"hello world\")\n\t$.println(\"Quote result:\", quoted)\n\n\t// Test Unquote\n\tlet unquoted: string\n\t[unquoted, err] = strconv.Unquote(`\"hello world\"`)\n\tif (err == null) {\n\t\t$.println(\"Unquote result:\", unquoted)\n\t}\n\n\t// Test error cases\n\t;[, err] = strconv.Atoi(\"invalid\")\n\tif (err != null) {\n\t\t$.println(\"Atoi error handled\")\n\t}\n\n\t;[, err] = strconv.ParseFloat(\"invalid\", 64)\n\tif (err != null) {\n\t\t$.println(\"ParseFloat error handled\")\n\t}\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Atoi result: 42\nItoa result: 123\nParseInt result: 456\nFormatInt result: 789\nParseFloat result: 3.14\nFormatFloat result: 2.718\nParseBool result: true\nFormatBool result: false\nQuote result: \"hello world\"\nUnquote result: hello world\nAtoi error handled\nParseFloat error handled\ntest finished\n"
  },
  {
    "name": "package_import_strings",
    "goCode": "package main\n\nimport \"strings\"\n\nfunc main() {\n\t// This should trigger the unhandled make call error\n\t// strings.Builder uses make internally for its buffer\n\tvar builder strings.Builder\n\tbuilder.WriteString(\"Hello\")\n\tbuilder.WriteString(\" \")\n\tbuilder.WriteString(\"World\")\n\n\tresult := builder.String()\n\tprintln(\"Result:\", result)\n\n\t// Also test direct make with strings.Builder\n\tbuilderPtr := &strings.Builder{}\n\tbuilderPtr.WriteString(\"Direct make test\")\n\tprintln(\"Direct:\", builderPtr.String())\n}\n",
    "tsCode": "// Generated file based on package_import_strings.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as strings from \"@goscript/strings/index.js\"\n\nexport async function main(): Promise<void> {\n\t// This should trigger the unhandled make call error\n\t// strings.Builder uses make internally for its buffer\n\tlet builder: $.VarRef<strings.Builder> = $.varRef(new strings.Builder())\n\tbuilder!.value.WriteString(\"Hello\")\n\tbuilder!.value.WriteString(\" \")\n\tbuilder!.value.WriteString(\"World\")\n\n\tlet result = builder!.value.String()\n\t$.println(\"Result:\", result)\n\n\t// Also test direct make with strings.Builder\n\tlet builderPtr = new strings.Builder({})\n\tbuilderPtr!.WriteString(\"Direct make test\")\n\t$.println(\"Direct:\", builderPtr!.String())\n}\n\n",
    "expectedOutput": "Result: Hello World\nDirect: Direct make test\n"
  },
  {
    "name": "package_import_sync",
    "goCode": "package main\n\nimport \"sync\"\n\nfunc main() {\n\t// Test Mutex\n\tvar mu sync.Mutex\n\tmu.Lock()\n\tprintln(\"Mutex locked\")\n\tmu.Unlock()\n\tprintln(\"Mutex unlocked\")\n\n\t// Test TryLock\n\tif mu.TryLock() {\n\t\tprintln(\"TryLock succeeded\")\n\t\tmu.Unlock()\n\t} else {\n\t\tprintln(\"TryLock failed\")\n\t}\n\n\t// Test WaitGroup\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tprintln(\"WaitGroup counter set to 1\")\n\twg.Done()\n\tprintln(\"WaitGroup counter decremented\")\n\twg.Wait()\n\tprintln(\"WaitGroup wait completed\")\n\n\t// Test Once\n\tvar once sync.Once\n\tcounter := 0\n\tonce.Do(func() {\n\t\tcounter++\n\t\tprintln(\"Once function executed, counter:\", counter)\n\t})\n\tonce.Do(func() {\n\t\tcounter++\n\t\tprintln(\"This should not execute\")\n\t})\n\tprintln(\"Final counter:\", counter)\n\n\t// Test OnceFunc\n\tonceFunc := sync.OnceFunc(func() {\n\t\tprintln(\"OnceFunc executed\")\n\t})\n\tonceFunc()\n\tonceFunc() // Should not execute again\n\n\t// Test OnceValue\n\tonceValue := sync.OnceValue(func() int {\n\t\tprintln(\"OnceValue function executed\")\n\t\treturn 42\n\t})\n\tval1 := onceValue()\n\tval2 := onceValue()\n\tprintln(\"OnceValue results:\", val1, val2)\n\n\t// Test sync.Map\n\tvar m sync.Map\n\tm.Store(\"key1\", \"value1\")\n\tprintln(\"Stored key1\")\n\n\tif val, ok := m.Load(\"key1\"); ok {\n\t\tprintln(\"Loaded key1:\", val)\n\t}\n\n\tif val, loaded := m.LoadOrStore(\"key2\", \"value2\"); !loaded {\n\t\tprintln(\"Stored key2:\", val)\n\t}\n\n\tm.Range(func(key, value interface{}) bool {\n\t\tprintln(\"Range:\", key, \"->\", value)\n\t\treturn true\n\t})\n\n\tm.Delete(\"key1\")\n\tif _, ok := m.Load(\"key1\"); !ok {\n\t\tprintln(\"key1 deleted successfully\")\n\t}\n\n\t// Test Pool\n\tpool := &sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\tprintln(\"Pool creating new object\")\n\t\t\treturn \"new object\"\n\t\t},\n\t}\n\n\tobj1 := pool.Get()\n\tprintln(\"Got from pool:\", obj1)\n\tpool.Put(\"reused object\")\n\tobj2 := pool.Get()\n\tprintln(\"Got from pool:\", obj2)\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_sync.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as sync from \"@goscript/sync/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test Mutex\n\tlet mu: $.VarRef<sync.Mutex> = $.varRef(new sync.Mutex())\n\tawait mu!.value.Lock()\n\t$.println(\"Mutex locked\")\n\tmu!.value.Unlock()\n\t$.println(\"Mutex unlocked\")\n\n\t// Test TryLock\n\tif (mu!.value.TryLock()) {\n\t\t$.println(\"TryLock succeeded\")\n\t\tmu!.value.Unlock()\n\t} else {\n\t\t$.println(\"TryLock failed\")\n\t}\n\n\t// Test WaitGroup\n\tlet wg: $.VarRef<sync.WaitGroup> = $.varRef(new sync.WaitGroup())\n\twg!.value.Add(1)\n\t$.println(\"WaitGroup counter set to 1\")\n\twg!.value.Done()\n\t$.println(\"WaitGroup counter decremented\")\n\tawait wg!.value.Wait()\n\t$.println(\"WaitGroup wait completed\")\n\n\t// Test Once\n\tlet once: $.VarRef<sync.Once> = $.varRef(new sync.Once())\n\tlet counter = 0\n\tawait once!.value.Do((): void => {\n\t\tcounter++\n\t\t$.println(\"Once function executed, counter:\", counter)\n\t})\n\tawait once!.value.Do((): void => {\n\t\tcounter++\n\t\t$.println(\"This should not execute\")\n\t})\n\t$.println(\"Final counter:\", counter)\n\n\t// Test OnceFunc\n\tlet onceFunc = sync.OnceFunc((): void => {\n\t\t$.println(\"OnceFunc executed\")\n\t})\n\tonceFunc!()\n\tonceFunc!() // Should not execute again\n\n\t// Test OnceValue\n\tlet onceValue = sync.OnceValue((): number => {\n\t\t$.println(\"OnceValue function executed\")\n\t\treturn 42\n\t})\n\tlet val1 = onceValue!()\n\tlet val2 = onceValue!()\n\t$.println(\"OnceValue results:\", val1, val2)\n\n\t// Test sync.Map\n\tlet m: $.VarRef<sync.Map> = $.varRef(new sync.Map())\n\tawait m!.value.Store(\"key1\", \"value1\")\n\t$.println(\"Stored key1\")\n\n\t{\n\t\tlet [val, ok] = await m!.value.Load(\"key1\")\n\t\tif (ok) {\n\t\t\t$.println(\"Loaded key1:\", val)\n\t\t}\n\t}\n\n\t{\n\t\tlet [val, loaded] = await m!.value.LoadOrStore(\"key2\", \"value2\")\n\t\tif (!loaded) {\n\t\t\t$.println(\"Stored key2:\", val)\n\t\t}\n\t}\n\n\tawait m!.value.Range((key: null | any, value: null | any): boolean => {\n\t\t$.println(\"Range:\", key, \"->\", value)\n\t\treturn true\n\t})\n\n\tawait m!.value.Delete(\"key1\")\n\t{\n\t\tlet [, ok] = await m!.value.Load(\"key1\")\n\t\tif (!ok) {\n\t\t\t$.println(\"key1 deleted successfully\")\n\t\t}\n\t}\n\n\t// Test Pool\n\tlet pool = new sync.Pool({New: (): null | any => {\n\t\t$.println(\"Pool creating new object\")\n\t\treturn \"new object\"\n\t}})\n\n\tlet obj1 = pool!.Get()\n\t$.println(\"Got from pool:\", obj1)\n\tpool!.Put(\"reused object\")\n\tlet obj2 = pool!.Get()\n\t$.println(\"Got from pool:\", obj2)\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Mutex locked\nMutex unlocked\nTryLock succeeded\nWaitGroup counter set to 1\nWaitGroup counter decremented\nWaitGroup wait completed\nOnce function executed, counter: 1\nFinal counter: 1\nOnceFunc executed\nOnceValue function executed\nOnceValue results: 42 42\nStored key1\nLoaded key1: value1\nStored key2: value2\nRange: key1 -> value1\nRange: key2 -> value2\nkey1 deleted successfully\nPool creating new object\nGot from pool: new object\nGot from pool: reused object\ntest finished\n"
  },
  {
    "name": "package_import_sync_atomic",
    "goCode": "package main\n\nimport \"sync/atomic\"\n\nfunc main() {\n\t// Test atomic.Int32\n\tvar i32 atomic.Int32\n\ti32.Store(42)\n\tprintln(\"Int32 stored 42, value:\", i32.Load())\n\n\told := i32.Swap(100)\n\tprintln(\"Int32 swapped to 100, old value:\", old, \"new value:\", i32.Load())\n\n\tnewVal := i32.Add(5)\n\tprintln(\"Int32 added 5, new value:\", newVal)\n\n\tif i32.CompareAndSwap(105, 200) {\n\t\tprintln(\"Int32 CompareAndSwap 105->200 succeeded, value:\", i32.Load())\n\t}\n\n\t// Test atomic.Int64\n\tvar i64 atomic.Int64\n\ti64.Store(1000)\n\tprintln(\"Int64 stored 1000, value:\", i64.Load())\n\n\ti64.Add(-100)\n\tprintln(\"Int64 after subtracting 100:\", i64.Load())\n\n\t// Test atomic.Uint32\n\tvar u32 atomic.Uint32\n\tu32.Store(50)\n\tprintln(\"Uint32 stored 50, value:\", u32.Load())\n\n\tu32.Add(25)\n\tprintln(\"Uint32 after adding 25:\", u32.Load())\n\n\t// Test atomic.Uint64\n\tvar u64 atomic.Uint64\n\tu64.Store(2000)\n\tprintln(\"Uint64 stored 2000, value:\", u64.Load())\n\n\t// Test atomic.Bool\n\tvar b atomic.Bool\n\tb.Store(true)\n\tprintln(\"Bool stored true, value:\", b.Load())\n\n\told_bool := b.Swap(false)\n\tprintln(\"Bool swapped to false, old value:\", old_bool, \"new value:\", b.Load())\n\n\t// Test atomic.Pointer\n\tvar ptr atomic.Pointer[string]\n\tstr1 := \"hello\"\n\tstr2 := \"world\"\n\n\tptr.Store(&str1)\n\tloaded := ptr.Load()\n\tif loaded != nil {\n\t\tprintln(\"Pointer loaded:\", *loaded)\n\t}\n\n\told_ptr := ptr.Swap(&str2)\n\tif old_ptr != nil {\n\t\tprintln(\"Pointer swapped, old:\", *old_ptr)\n\t}\n\tloaded = ptr.Load()\n\tif loaded != nil {\n\t\tprintln(\"Pointer new value:\", *loaded)\n\t}\n\n\t// Test atomic.Value\n\tvar val atomic.Value\n\tval.Store(\"atomic value\")\n\tif loaded_val := val.Load(); loaded_val != nil {\n\t\tif str, ok := loaded_val.(string); ok {\n\t\t\tprintln(\"Value loaded:\", str)\n\t\t}\n\t}\n\n\told_val := val.Swap(\"new atomic value\")\n\tif old_val != nil {\n\t\tif str, ok := old_val.(string); ok {\n\t\t\tprintln(\"Value swapped, old:\", str)\n\t\t}\n\t}\n\tif loaded_val := val.Load(); loaded_val != nil {\n\t\tif str, ok := loaded_val.(string); ok {\n\t\t\tprintln(\"Value new:\", str)\n\t\t}\n\t}\n\n\tprintln(\"atomic test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_sync_atomic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as atomic from \"@goscript/sync/atomic/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test atomic.Int32\n\tlet i32: $.VarRef<atomic.Int32> = $.varRef(new atomic.Int32())\n\ti32!.value.Store(42)\n\t$.println(\"Int32 stored 42, value:\", i32!.value.Load())\n\n\tlet old = i32!.value.Swap(100)\n\t$.println(\"Int32 swapped to 100, old value:\", old, \"new value:\", i32!.value.Load())\n\n\tlet newVal = i32!.value.Add(5)\n\t$.println(\"Int32 added 5, new value:\", newVal)\n\n\tif (i32!.value.CompareAndSwap(105, 200)) {\n\t\t$.println(\"Int32 CompareAndSwap 105->200 succeeded, value:\", i32!.value.Load())\n\t}\n\n\t// Test atomic.Int64\n\tlet i64: $.VarRef<atomic.Int64> = $.varRef(new atomic.Int64())\n\ti64!.value.Store(1000)\n\t$.println(\"Int64 stored 1000, value:\", i64!.value.Load())\n\n\ti64!.value.Add(-100)\n\t$.println(\"Int64 after subtracting 100:\", i64!.value.Load())\n\n\t// Test atomic.Uint32\n\tlet u32: $.VarRef<atomic.Uint32> = $.varRef(new atomic.Uint32())\n\tu32!.value.Store(50)\n\t$.println(\"Uint32 stored 50, value:\", u32!.value.Load())\n\n\tu32!.value.Add(25)\n\t$.println(\"Uint32 after adding 25:\", u32!.value.Load())\n\n\t// Test atomic.Uint64\n\tlet u64: $.VarRef<atomic.Uint64> = $.varRef(new atomic.Uint64())\n\tu64!.value.Store(2000)\n\t$.println(\"Uint64 stored 2000, value:\", u64!.value.Load())\n\n\t// Test atomic.Bool\n\tlet b: $.VarRef<atomic.Bool> = $.varRef(new atomic.Bool())\n\tb!.value.Store(true)\n\t$.println(\"Bool stored true, value:\", b!.value.Load())\n\n\tlet old_bool = b!.value.Swap(false)\n\t$.println(\"Bool swapped to false, old value:\", old_bool, \"new value:\", b!.value.Load())\n\n\t// Test atomic.Pointer\n\tlet ptr: $.VarRef<atomic.Pointer<string>> = $.varRef(new atomic.Pointer<string>())\n\tlet str1 = $.varRef(\"hello\")\n\tlet str2 = $.varRef(\"world\")\n\n\tptr!.value.Store(str1)\n\tlet loaded = ptr!.value.Load()\n\tif (loaded != null) {\n\t\t$.println(\"Pointer loaded:\", loaded!.value)\n\t}\n\n\tlet old_ptr = ptr!.value.Swap(str2)\n\tif (old_ptr != null) {\n\t\t$.println(\"Pointer swapped, old:\", old_ptr!.value)\n\t}\n\tloaded = ptr!.value.Load()\n\tif (loaded != null) {\n\t\t$.println(\"Pointer new value:\", loaded!.value)\n\t}\n\n\t// Test atomic.Value\n\tlet val: $.VarRef<atomic.Value> = $.varRef(new atomic.Value())\n\tval!.value.Store(\"atomic value\")\n\t{\n\t\tlet loaded_val = val!.value.Load()\n\t\tif (loaded_val != null) {\n\t\t\t{\n\t\t\t\tlet { value: str, ok: ok } = $.typeAssert<string>(loaded_val, {kind: $.TypeKind.Basic, name: 'string'})\n\t\t\t\tif (ok) {\n\t\t\t\t\t$.println(\"Value loaded:\", str)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlet old_val = val!.value.Swap(\"new atomic value\")\n\tif (old_val != null) {\n\t\t{\n\t\t\tlet { value: str, ok: ok } = $.typeAssert<string>(old_val, {kind: $.TypeKind.Basic, name: 'string'})\n\t\t\tif (ok) {\n\t\t\t\t$.println(\"Value swapped, old:\", str)\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tlet loaded_val = val!.value.Load()\n\t\tif (loaded_val != null) {\n\t\t\t{\n\t\t\t\tlet { value: str, ok: ok } = $.typeAssert<string>(loaded_val, {kind: $.TypeKind.Basic, name: 'string'})\n\t\t\t\tif (ok) {\n\t\t\t\t\t$.println(\"Value new:\", str)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t$.println(\"atomic test finished\")\n}\n\n",
    "expectedOutput": "Int32 stored 42, value: 42\nInt32 swapped to 100, old value: 42 new value: 100\nInt32 added 5, new value: 105\nInt32 CompareAndSwap 105->200 succeeded, value: 200\nInt64 stored 1000, value: 1000\nInt64 after subtracting 100: 900\nUint32 stored 50, value: 50\nUint32 after adding 25: 75\nUint64 stored 2000, value: 2000\nBool stored true, value: true\nBool swapped to false, old value: true new value: false\nPointer loaded: hello\nPointer swapped, old: hello\nPointer new value: world\nValue loaded: atomic value\nValue swapped, old: atomic value\nValue new: new atomic value\natomic test finished\n"
  },
  {
    "name": "package_import_testing_fstest",
    "goCode": "package main\n\nimport (\n\t\"testing/fstest\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a MapFS with some test files\n\tfsys := fstest.MapFS{\n\t\t\"hello.txt\": &fstest.MapFile{\n\t\t\tData: []byte(\"Hello, World!\"),\n\t\t},\n\t\t\"dir/subfile.txt\": &fstest.MapFile{\n\t\t\tData: []byte(\"This is a subfile\"),\n\t\t},\n\t\t\"dir\": &fstest.MapFile{\n\t\t\tMode: 0o755 | (1 << (32 - 1 - 20)), // fs.ModeDir\n\t\t},\n\t\t\"binary.bin\": &fstest.MapFile{\n\t\t\tData:    []byte{0x48, 0x65, 0x6c, 0x6c, 0x6f},\n\t\t\tModTime: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC),\n\t\t},\n\t}\n\n\t// Test Open and read a file\n\tfile, err := fsys.Open(\"hello.txt\")\n\tif err != nil {\n\t\tprintln(\"Error opening hello.txt:\", err.Error())\n\t\treturn\n\t}\n\n\tdata := make([]byte, 20)\n\tn, err := file.Read(data)\n\tif err != nil {\n\t\tprintln(\"Error reading hello.txt:\", err.Error())\n\t\treturn\n\t}\n\tprintln(\"Read from hello.txt:\", string(data[:n]))\n\tfile.Close()\n\n\t// Test ReadFile\n\tcontent, err := fsys.ReadFile(\"dir/subfile.txt\")\n\tif err != nil {\n\t\tprintln(\"Error reading dir/subfile.txt:\", err.Error())\n\t\treturn\n\t}\n\tprintln(\"ReadFile dir/subfile.txt:\", string(content))\n\n\t// Test Stat\n\tinfo, err := fsys.Stat(\"hello.txt\")\n\tif err != nil {\n\t\tprintln(\"Error stating hello.txt:\", err.Error())\n\t\treturn\n\t}\n\tprintln(\"hello.txt size:\", info.Size())\n\tprintln(\"hello.txt name:\", info.Name())\n\n\t// Test ReadDir\n\tentries, err := fsys.ReadDir(\".\")\n\tif err != nil {\n\t\tprintln(\"Error reading directory:\", err.Error())\n\t\treturn\n\t}\n\tprintln(\"Directory entries:\")\n\tfor _, entry := range entries {\n\t\tprintln(\"  Entry:\", entry.Name(), \"IsDir:\", entry.IsDir())\n\t}\n\n\t// Test ReadDir on subdirectory\n\tdirEntries, err := fsys.ReadDir(\"dir\")\n\tif err != nil {\n\t\tprintln(\"Error reading dir:\", err.Error())\n\t\treturn\n\t}\n\tprintln(\"Dir entries:\")\n\tfor _, entry := range dirEntries {\n\t\tprintln(\"  Entry:\", entry.Name(), \"IsDir:\", entry.IsDir())\n\t}\n\n\t// Test Glob\n\tmatches, err := fsys.Glob(\"*.txt\")\n\tif err != nil {\n\t\tprintln(\"Error globbing *.txt:\", err.Error())\n\t\treturn\n\t}\n\tprintln(\"Glob *.txt matches:\")\n\tfor _, match := range matches {\n\t\tprintln(\"  Match:\", match)\n\t}\n\n\t// Test Sub\n\tsubFS, err := fsys.Sub(\"dir\")\n\tif err != nil {\n\t\tprintln(\"Error creating sub filesystem:\", err.Error())\n\t\treturn\n\t}\n\n\tsubContent, err := subFS.(*fstest.MapFS).ReadFile(\"subfile.txt\")\n\tif err != nil {\n\t\tprintln(\"Error reading from sub filesystem:\", err.Error())\n\t\treturn\n\t}\n\tprintln(\"Sub filesystem content:\", string(subContent))\n\n\tprintln(\"testing/fstest MapFS test completed\")\n}\n",
    "tsCode": "// Generated file based on package_import_testing_fstest.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as fstest from \"@goscript/testing/fstest/index.js\"\n\nimport * as time from \"@goscript/time/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Create a MapFS with some test files\n\n\t// fs.ModeDir\n\tlet fsys = ({\"hello.txt\": new fstest.MapFile({Data: $.stringToBytes(\"Hello, World!\")}), \"dir/subfile.txt\": new fstest.MapFile({Data: $.stringToBytes(\"This is a subfile\")}), \"dir\": new fstest.MapFile({Mode: (0o755 | ((1 << (32 - 1 - 20))))}), \"binary.bin\": new fstest.MapFile({Data: new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]), ModTime: time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC)})})\n\n\t// Test Open and read a file\n\tlet [file, err] = fstest.MapFS_Open(fsys, \"hello.txt\")\n\tif (err != null) {\n\t\tconsole.log(\"Error opening hello.txt:\", err!.Error())\n\t\treturn \n\t}\n\n\tlet data = new Uint8Array(20)\n\tlet n: number\n\t[n, err] = file!.Read(data)\n\tif (err != null) {\n\t\tconsole.log(\"Error reading hello.txt:\", err!.Error())\n\t\treturn \n\t}\n\tconsole.log(\"Read from hello.txt:\", $.bytesToString($.goSlice(data, undefined, n)))\n\tfile!.Close()\n\n\t// Test ReadFile\n\tlet content: $.Bytes\n\t[content, err] = fstest.MapFS_ReadFile(fsys, \"dir/subfile.txt\")\n\tif (err != null) {\n\t\tconsole.log(\"Error reading dir/subfile.txt:\", err!.Error())\n\t\treturn \n\t}\n\tconsole.log(\"ReadFile dir/subfile.txt:\", $.bytesToString(content))\n\n\t// Test Stat\n\tlet info: FileInfo\n\t[info, err] = fstest.MapFS_Stat(fsys, \"hello.txt\")\n\tif (err != null) {\n\t\tconsole.log(\"Error stating hello.txt:\", err!.Error())\n\t\treturn \n\t}\n\tconsole.log(\"hello.txt size:\", info!.Size())\n\tconsole.log(\"hello.txt name:\", info!.Name())\n\n\t// Test ReadDir\n\tlet entries: $.Slice<DirEntry>\n\t[entries, err] = fstest.MapFS_ReadDir(fsys, \".\")\n\tif (err != null) {\n\t\tconsole.log(\"Error reading directory:\", err!.Error())\n\t\treturn \n\t}\n\tconsole.log(\"Directory entries:\")\n\tfor (let _i = 0; _i < $.len(entries); _i++) {\n\t\tconst entry = entries![_i]\n\t\t{\n\t\t\tconsole.log(\"  Entry:\", entry!.Name(), \"IsDir:\", entry!.IsDir())\n\t\t}\n\t}\n\n\t// Test ReadDir on subdirectory\n\tlet dirEntries: $.Slice<DirEntry>\n\t[dirEntries, err] = fstest.MapFS_ReadDir(fsys, \"dir\")\n\tif (err != null) {\n\t\tconsole.log(\"Error reading dir:\", err!.Error())\n\t\treturn \n\t}\n\tconsole.log(\"Dir entries:\")\n\tfor (let _i = 0; _i < $.len(dirEntries); _i++) {\n\t\tconst entry = dirEntries![_i]\n\t\t{\n\t\t\tconsole.log(\"  Entry:\", entry!.Name(), \"IsDir:\", entry!.IsDir())\n\t\t}\n\t}\n\n\t// Test Glob\n\tlet matches: $.Slice<string>\n\t[matches, err] = fstest.MapFS_Glob(fsys, \"*.txt\")\n\tif (err != null) {\n\t\tconsole.log(\"Error globbing *.txt:\", err!.Error())\n\t\treturn \n\t}\n\tconsole.log(\"Glob *.txt matches:\")\n\tfor (let _i = 0; _i < $.len(matches); _i++) {\n\t\tconst match = matches![_i]\n\t\t{\n\t\t\tconsole.log(\"  Match:\", match)\n\t\t}\n\t}\n\n\t// Test Sub\n\tlet subFS: FS\n\t[subFS, err] = fstest.MapFS_Sub(fsys, \"dir\")\n\tif (err != null) {\n\t\tconsole.log(\"Error creating sub filesystem:\", err!.Error())\n\t\treturn \n\t}\n\n\tlet subContent: $.Bytes\n\t[subContent, err] = $.mustTypeAssert<$.VarRef<fstest.MapFS> | null>(subFS, {kind: $.TypeKind.Pointer, elemType: 'fstest.MapFS'})!.ReadFile(\"subfile.txt\")\n\tif (err != null) {\n\t\tconsole.log(\"Error reading from sub filesystem:\", err!.Error())\n\t\treturn \n\t}\n\tconsole.log(\"Sub filesystem content:\", $.bytesToString(subContent))\n\n\tconsole.log(\"testing/fstest MapFS test completed\")\n}\n\n",
    "expectedOutput": "Read from hello.txt: Hello, World!\nReadFile dir/subfile.txt: This is a subfile\nhello.txt size: 13\nhello.txt name: hello.txt\nDirectory entries:\n  Entry: binary.bin IsDir: false\n  Entry: dir IsDir: false\n  Entry: hello.txt IsDir: false\nError reading dir: readdir dir: not implemented\n"
  },
  {
    "name": "package_import_time",
    "goCode": "package main\n\nimport \"time\"\n\nfunc main() {\n\tnow := time.Now()\n\tsetTime := time.Date(2025, time.May, 15, 1, 10, 42, 0, time.UTC)\n\tif now.Sub(setTime) < time.Hour*24 {\n\t\tprintln(\"expected we are > 24 hrs past may 15, incorrect\")\n\t}\n\n\tprintln(\"preset time\", setTime.String())\n\tprintln(\"unix\", setTime.Unix())\n\tprintln(\"unix micro\", setTime.UnixMicro())\n\tprintln(\"unix nano\", setTime.UnixNano())\n\tprintln(\"unix milli\", setTime.UnixMilli())\n\n\t// day, month, etc.\n\tprintln(\"day\", setTime.Day())\n\tprintln(\"month\", setTime.Month())\n\tprintln(\"year\", setTime.Year())\n\tprintln(\"hour\", setTime.Hour())\n\tprintln(\"minute\", setTime.Minute())\n\tprintln(\"second\", setTime.Second())\n\tprintln(\"nanosecond\", setTime.Nanosecond())\n\n\t// other functions on setTime\n\tprintln(\"weekday\", setTime.Weekday().String())\n\tprintln(\"location\", setTime.Location().String())\n}\n",
    "tsCode": "// Generated file based on package_import_time.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as time from \"@goscript/time/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet now = $.markAsStructValue(time.Now().clone())\n\tlet setTime = $.markAsStructValue(time.Date(2025, time.May, 15, 1, 10, 42, 0, time.UTC).clone())\n\tif (now.Sub(setTime) < time.Hour * 24) {\n\t\t$.println(\"expected we are > 24 hrs past may 15, incorrect\")\n\t}\n\n\t$.println(\"preset time\", setTime.String())\n\t$.println(\"unix\", setTime.Unix())\n\t$.println(\"unix micro\", setTime.UnixMicro())\n\t$.println(\"unix nano\", setTime.UnixNano())\n\t$.println(\"unix milli\", setTime.UnixMilli())\n\n\t// day, month, etc.\n\t$.println(\"day\", setTime.Day())\n\t$.println(\"month\", setTime.Month())\n\t$.println(\"year\", setTime.Year())\n\t$.println(\"hour\", setTime.Hour())\n\t$.println(\"minute\", setTime.Minute())\n\t$.println(\"second\", setTime.Second())\n\t$.println(\"nanosecond\", setTime.Nanosecond())\n\n\t// other functions on setTime\n\t$.println(\"weekday\", time.Weekday_String(setTime.Weekday()))\n\t$.println(\"location\", setTime.Location()!.String())\n}\n\n",
    "expectedOutput": "preset time 2025-05-15 01:10:42 +0000 UTC\nunix 1747271442\nunix micro 1747271442000000\nunix nano 1747271442000000000\nunix milli 1747271442000\nday 15\nmonth 5\nyear 2025\nhour 1\nminute 10\nsecond 42\nnanosecond 0\nweekday Thursday\nlocation UTC\n"
  },
  {
    "name": "package_import_unicode",
    "goCode": "package main\n\nimport \"unicode\"\n\nfunc main() {\n\t// Test character classification functions\n\tprintln(\"Testing character classification:\")\n\n\t// Test IsLetter\n\tprintln(\"IsLetter('A'):\", unicode.IsLetter('A'))\n\tprintln(\"IsLetter('1'):\", unicode.IsLetter('1'))\n\n\t// Test IsDigit\n\tprintln(\"IsDigit('5'):\", unicode.IsDigit('5'))\n\tprintln(\"IsDigit('a'):\", unicode.IsDigit('a'))\n\n\t// Test IsUpper\n\tprintln(\"IsUpper('Z'):\", unicode.IsUpper('Z'))\n\tprintln(\"IsUpper('z'):\", unicode.IsUpper('z'))\n\n\t// Test IsLower\n\tprintln(\"IsLower('b'):\", unicode.IsLower('b'))\n\tprintln(\"IsLower('B'):\", unicode.IsLower('B'))\n\n\t// Test IsSpace\n\tprintln(\"IsSpace(' '):\", unicode.IsSpace(' '))\n\tprintln(\"IsSpace('x'):\", unicode.IsSpace('x'))\n\n\t// Test IsPunct\n\tprintln(\"IsPunct('!'):\", unicode.IsPunct('!'))\n\tprintln(\"IsPunct('a'):\", unicode.IsPunct('a'))\n\n\t// Test case conversion functions\n\tprintln(\"\\nTesting case conversion:\")\n\n\t// Test ToUpper\n\tprintln(\"ToUpper('a'):\", string(unicode.ToUpper('a')))\n\tprintln(\"ToUpper('Z'):\", string(unicode.ToUpper('Z')))\n\n\t// Test ToLower\n\tprintln(\"ToLower('A'):\", string(unicode.ToLower('A')))\n\tprintln(\"ToLower('z'):\", string(unicode.ToLower('z')))\n\n\t// Test ToTitle\n\tprintln(\"ToTitle('a'):\", string(unicode.ToTitle('a')))\n\n\t// Test To function with constants\n\tprintln(\"To(UpperCase, 'b'):\", string(unicode.To(unicode.UpperCase, 'b')))\n\tprintln(\"To(LowerCase, 'C'):\", string(unicode.To(unicode.LowerCase, 'C')))\n\n\t// Test SimpleFold\n\tprintln(\"SimpleFold('A'):\", string(unicode.SimpleFold('A')))\n\tprintln(\"SimpleFold('a'):\", string(unicode.SimpleFold('a')))\n\n\t// Test constants\n\tprintln(\"\\nTesting constants:\")\n\tprintln(\"MaxRune:\", unicode.MaxRune)\n\tprintln(\"Version:\", unicode.Version)\n\n\t// Test range tables with Is function\n\tprintln(\"\\nTesting range tables:\")\n\tprintln(\"Is(Letter, 'A'):\", unicode.Is(unicode.Letter, 'A'))\n\tprintln(\"Is(Letter, '1'):\", unicode.Is(unicode.Letter, '1'))\n\tprintln(\"Is(Digit, '5'):\", unicode.Is(unicode.Digit, '5'))\n\tprintln(\"Is(Digit, 'x'):\", unicode.Is(unicode.Digit, 'x'))\n\n\t// Test In function\n\tprintln(\"In('A', Letter, Digit):\", unicode.In('A', unicode.Letter, unicode.Digit))\n\tprintln(\"In('5', Letter, Digit):\", unicode.In('5', unicode.Letter, unicode.Digit))\n\tprintln(\"In('!', Letter, Digit):\", unicode.In('!', unicode.Letter, unicode.Digit))\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on package_import_unicode.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as unicode from \"@goscript/unicode/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test character classification functions\n\t$.println(\"Testing character classification:\")\n\n\t// Test IsLetter\n\t$.println(\"IsLetter('A'):\", unicode.IsLetter(65))\n\t$.println(\"IsLetter('1'):\", unicode.IsLetter(49))\n\n\t// Test IsDigit\n\t$.println(\"IsDigit('5'):\", unicode.IsDigit(53))\n\t$.println(\"IsDigit('a'):\", unicode.IsDigit(97))\n\n\t// Test IsUpper\n\t$.println(\"IsUpper('Z'):\", unicode.IsUpper(90))\n\t$.println(\"IsUpper('z'):\", unicode.IsUpper(122))\n\n\t// Test IsLower\n\t$.println(\"IsLower('b'):\", unicode.IsLower(98))\n\t$.println(\"IsLower('B'):\", unicode.IsLower(66))\n\n\t// Test IsSpace\n\t$.println(\"IsSpace(' '):\", unicode.IsSpace(32))\n\t$.println(\"IsSpace('x'):\", unicode.IsSpace(120))\n\n\t// Test IsPunct\n\t$.println(\"IsPunct('!'):\", unicode.IsPunct(33))\n\t$.println(\"IsPunct('a'):\", unicode.IsPunct(97))\n\n\t// Test case conversion functions\n\t$.println(\"\\nTesting case conversion:\")\n\n\t// Test ToUpper\n\t$.println(\"ToUpper('a'):\", $.runeOrStringToString(unicode.ToUpper(97)))\n\t$.println(\"ToUpper('Z'):\", $.runeOrStringToString(unicode.ToUpper(90)))\n\n\t// Test ToLower\n\t$.println(\"ToLower('A'):\", $.runeOrStringToString(unicode.ToLower(65)))\n\t$.println(\"ToLower('z'):\", $.runeOrStringToString(unicode.ToLower(122)))\n\n\t// Test ToTitle\n\t$.println(\"ToTitle('a'):\", $.runeOrStringToString(unicode.ToTitle(97)))\n\n\t// Test To function with constants\n\t$.println(\"To(UpperCase, 'b'):\", $.runeOrStringToString(unicode.To(unicode.UpperCase, 98)))\n\t$.println(\"To(LowerCase, 'C'):\", $.runeOrStringToString(unicode.To(unicode.LowerCase, 67)))\n\n\t// Test SimpleFold\n\t$.println(\"SimpleFold('A'):\", $.runeOrStringToString(unicode.SimpleFold(65)))\n\t$.println(\"SimpleFold('a'):\", $.runeOrStringToString(unicode.SimpleFold(97)))\n\n\t// Test constants\n\t$.println(\"\\nTesting constants:\")\n\t$.println(\"MaxRune:\", unicode.MaxRune)\n\t$.println(\"Version:\", unicode.Version)\n\n\t// Test range tables with Is function\n\t$.println(\"\\nTesting range tables:\")\n\t$.println(\"Is(Letter, 'A'):\", unicode.Is(unicode.Letter, 65))\n\t$.println(\"Is(Letter, '1'):\", unicode.Is(unicode.Letter, 49))\n\t$.println(\"Is(Digit, '5'):\", unicode.Is(unicode.Digit, 53))\n\t$.println(\"Is(Digit, 'x'):\", unicode.Is(unicode.Digit, 120))\n\n\t// Test In function\n\t$.println(\"In('A', Letter, Digit):\", unicode.In(65, unicode.Letter, unicode.Digit))\n\t$.println(\"In('5', Letter, Digit):\", unicode.In(53, unicode.Letter, unicode.Digit))\n\t$.println(\"In('!', Letter, Digit):\", unicode.In(33, unicode.Letter, unicode.Digit))\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Testing character classification:\nIsLetter('A'): true\nIsLetter('1'): false\nIsDigit('5'): true\nIsDigit('a'): false\nIsUpper('Z'): true\nIsUpper('z'): false\nIsLower('b'): true\nIsLower('B'): false\nIsSpace(' '): true\nIsSpace('x'): false\nIsPunct('!'): true\nIsPunct('a'): false\n\nTesting case conversion:\nToUpper('a'): A\nToUpper('Z'): Z\nToLower('A'): a\nToLower('z'): z\nToTitle('a'): A\nTo(UpperCase, 'b'): B\nTo(LowerCase, 'C'): c\nSimpleFold('A'): a\nSimpleFold('a'): A\n\nTesting constants:\nMaxRune: 1114111\nVersion: 15.0.0\n\nTesting range tables:\nIs(Letter, 'A'): true\nIs(Letter, '1'): false\nIs(Digit, '5'): true\nIs(Digit, 'x'): false\nIn('A', Letter, Digit): true\nIn('5', Letter, Digit): true\nIn('!', Letter, Digit): false\ntest finished\n"
  },
  {
    "name": "package_import_unicode_utf8",
    "goCode": "package main\n\nimport \"unicode/utf8\"\n\nfunc main() {\n\t// Test basic UTF-8 functions\n\ts := \"Hello, \"\n\n\t// Test RuneCountInString\n\tcount := utf8.RuneCountInString(s)\n\tprintln(\"Rune count:\", count)\n\n\t// Test DecodeRuneInString\n\tr, size := utf8.DecodeRuneInString(s)\n\tprintln(\"First rune:\", r, \"size:\", size)\n\n\t// Test ValidString\n\tvalid := utf8.ValidString(s)\n\tprintln(\"Valid UTF-8:\", valid)\n\n\t// Test with bytes\n\tb := []byte(s)\n\n\t// Test RuneCount\n\tbyteCount := utf8.RuneCount(b)\n\tprintln(\"Byte rune count:\", byteCount)\n\n\t// Test DecodeRune\n\tbr, bsize := utf8.DecodeRune(b)\n\tprintln(\"First rune from bytes:\", br, \"size:\", bsize)\n\n\t// Test Valid\n\tbvalid := utf8.Valid(b)\n\tprintln(\"Valid UTF-8 bytes:\", bvalid)\n\n\t// Test EncodeRune\n\tvar buf [4]byte\n\tn := utf8.EncodeRune(buf[:], '')\n\tprintln(\"Encoded rune size:\", n)\n\n\t// Test RuneLen\n\truneLen := utf8.RuneLen('')\n\tprintln(\"Rune length:\", runeLen)\n\n\t// Test ValidRune\n\tvalidRune := utf8.ValidRune('')\n\tprintln(\"Valid rune:\", validRune)\n\n\t// Test constants\n\tprintln(\"RuneSelf:\", utf8.RuneSelf)\n\tprintln(\"MaxRune:\", utf8.MaxRune)\n\tprintln(\"UTFMax:\", utf8.UTFMax)\n}\n",
    "tsCode": "// Generated file based on package_import_unicode_utf8.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as utf8 from \"@goscript/unicode/utf8/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test basic UTF-8 functions\n\tlet s = \"Hello, \"\n\n\t// Test RuneCountInString\n\tlet count = utf8.RuneCountInString(s)\n\t$.println(\"Rune count:\", count)\n\n\t// Test DecodeRuneInString\n\tlet [r, size] = utf8.DecodeRuneInString(s)\n\t$.println(\"First rune:\", r, \"size:\", size)\n\n\t// Test ValidString\n\tlet valid = utf8.ValidString(s)\n\t$.println(\"Valid UTF-8:\", valid)\n\n\t// Test with bytes\n\tlet b = $.stringToBytes(s)\n\n\t// Test RuneCount\n\tlet byteCount = utf8.RuneCount(b)\n\t$.println(\"Byte rune count:\", byteCount)\n\n\t// Test DecodeRune\n\tlet [br, bsize] = utf8.DecodeRune(b)\n\t$.println(\"First rune from bytes:\", br, \"size:\", bsize)\n\n\t// Test Valid\n\tlet bvalid = utf8.Valid(b)\n\t$.println(\"Valid UTF-8 bytes:\", bvalid)\n\n\t// Test EncodeRune\n\tlet buf: number[] = [0, 0, 0, 0]\n\tlet n = utf8.EncodeRune($.goSlice(buf, undefined, undefined), 19990)\n\t$.println(\"Encoded rune size:\", n)\n\n\t// Test RuneLen\n\tlet runeLen = utf8.RuneLen(19990)\n\t$.println(\"Rune length:\", runeLen)\n\n\t// Test ValidRune\n\tlet validRune = utf8.ValidRune(19990)\n\t$.println(\"Valid rune:\", validRune)\n\n\t// Test constants\n\t$.println(\"RuneSelf:\", utf8.RuneSelf)\n\t$.println(\"MaxRune:\", utf8.MaxRune)\n\t$.println(\"UTFMax:\", utf8.UTFMax)\n}\n\n",
    "expectedOutput": "Rune count: 9\nFirst rune: 72 size: 1\nValid UTF-8: true\nByte rune count: 9\nFirst rune from bytes: 72 size: 1\nValid UTF-8 bytes: true\nEncoded rune size: 3\nRune length: 3\nValid rune: true\nRuneSelf: 128\nMaxRune: 1114111\nUTFMax: 4\n"
  },
  {
    "name": "package_var_async_method",
    "goCode": "package main\n\nimport (\n\t\"sync\"\n)\n\nvar cache sync.Map\n\n// This function calls an async method on a package-level variable\nfunc getValueFromCache(key string) (interface{}, bool) {\n\treturn cache.Load(key)\n}\n\nfunc main() {\n\tcache.Store(\"hello\", \"world\")\n\n\tval, ok := getValueFromCache(\"hello\")\n\tif ok {\n\t\tprintln(\"Found:\", val.(string))\n\t}\n}\n",
    "tsCode": "// Generated file based on package_var_async_method.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as sync from \"@goscript/sync/index.js\"\n\nexport let cache: $.VarRef<sync.Map> = $.varRef(new sync.Map())\n\n// This function calls an async method on a package-level variable\nexport async function getValueFromCache(key: string): Promise<[null | any, boolean]> {\n\treturn await cache!.value.Load(key)\n}\n\nexport async function main(): Promise<void> {\n\tawait cache!.value.Store(\"hello\", \"world\")\n\n\tlet [val, ok] = await getValueFromCache(\"hello\")\n\tif (ok) {\n\t\t$.println(\"Found:\", $.mustTypeAssert<string>(val, {kind: $.TypeKind.Basic, name: 'string'}))\n\t}\n}\n\n",
    "expectedOutput": "Found: world\n"
  },
  {
    "name": "path_error_constructor",
    "goCode": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Test creating a PathError using composite literal syntax\n\terr := &os.PathError{\n\t\tOp:   \"readlink\",\n\t\tPath: \"/some/path\",\n\t\tErr:  fmt.Errorf(\"not a symlink\"),\n\t}\n\n\tprintln(err.Op)\n\tprintln(err.Path)\n\tprintln(err.Err.Error())\n}\n",
    "tsCode": "// Generated file based on path_error_constructor.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as fmt from \"@goscript/fmt/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test creating a PathError using composite literal syntax\n\tlet err = new os.PathError({Err: fmt.Errorf(\"not a symlink\"), Op: \"readlink\", Path: \"/some/path\"})\n\n\t$.println(err!.Op)\n\t$.println(err!.Path)\n\t$.println(err!.Err!.Error())\n}\n\n",
    "expectedOutput": "readlink\n/some/path\nnot a symlink\n"
  },
  {
    "name": "pointer_assignment_no_copy",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\nfunc main() {\n\toriginal := &MyStruct{MyInt: 10, MyString: \"original\"}\n\n\t// === Pointer Assignment (No Copy) ===\n\t// Assigning a pointer variable to another pointer variable.\n\tpointerCopy := original\n\n\t// Modify the struct through the original pointer.\n\toriginal.MyString = \"modified original\"\n\n\t// The change should be reflected when accessing through the copied pointer.\n\t// Expected: \"modified original\"\n\tprintln(\"Pointer copy value: Expected: modified original, Actual: \" + pointerCopy.MyString)\n\n\t// Modify the struct through the copied pointer.\n\tpointerCopy.MyInt = 20\n\n\t// The change should be reflected when accessing through the original pointer.\n\t// Expected: 20\n\tprintln(\"Original value after pointer copy modification: Expected: 20, Actual:\", original.MyInt)\n}\n",
    "tsCode": "// Generated file based on pointer_assignment_no_copy.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet original = new MyStruct({MyInt: 10, MyString: \"original\"})\n\n\t// === Pointer Assignment (No Copy) ===\n\t// Assigning a pointer variable to another pointer variable.\n\tlet pointerCopy = original\n\n\t// Modify the struct through the original pointer.\n\toriginal!.MyString = \"modified original\"\n\n\t// The change should be reflected when accessing through the copied pointer.\n\t// Expected: \"modified original\"\n\t$.println(\"Pointer copy value: Expected: modified original, Actual: \" + pointerCopy!.MyString)\n\n\t// Modify the struct through the copied pointer.\n\tpointerCopy!.MyInt = 20\n\n\t// The change should be reflected when accessing through the original pointer.\n\t// Expected: 20\n\t$.println(\"Original value after pointer copy modification: Expected: 20, Actual:\", original!.MyInt)\n}\n\n",
    "expectedOutput": "Pointer copy value: Expected: modified original, Actual: modified original\nOriginal value after pointer copy modification: Expected: 20, Actual: 20"
  },
  {
    "name": "pointer_circular_ref",
    "goCode": "package main\n\n// This creates a circular reference through pointers\n// which should NOT cause a circular dependency error\n// because pointers don't require initialization dependencies\n\ntype Node struct {\n\tvalue    int\n\tnext     *Node   // Pointer to Node - this should NOT create a dependency\n\tparent   *Node   // Another pointer - also should NOT create a dependency\n\tchildren []*Node //nolint:unused // Slice of pointers - also should NOT create a dependency\n}\n\ntype TreeNode struct {\n\tdata   string    //nolint:unused\n\tleft   *TreeNode //nolint:unused\n\tright  *TreeNode //nolint:unused\n\tparent *TreeNode //nolint:unused\n}\n\n// This creates a mutual circular reference through pointers\ntype Person struct {\n\tname   string\n\tspouse *Employee // Pointer to Employee\n}\n\ntype Employee struct {\n\tid     int\n\tperson *Person // Pointer back to Person\n}\n\nfunc main() {\n\t// Create a simple linked list\n\tnode1 := &Node{value: 1}\n\tnode2 := &Node{value: 2}\n\tnode1.next = node2\n\tnode2.parent = node1\n\n\tprintln(\"Node 1 value:\", node1.value)\n\tprintln(\"Node 2 value:\", node2.value)\n\n\t// Create person/employee relationship\n\tperson := &Person{name: \"John\"}\n\temployee := &Employee{id: 123}\n\tperson.spouse = employee\n\temployee.person = person\n\n\tprintln(\"Person name:\", person.name)\n\tprintln(\"Employee ID:\", employee.id)\n\n\tprintln(\"Pointer circular references work fine!\")\n}\n",
    "tsCode": "// Generated file based on pointer_circular_ref.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Employee {\n\tpublic get id(): number {\n\t\treturn this._fields.id.value\n\t}\n\tpublic set id(value: number) {\n\t\tthis._fields.id.value = value\n\t}\n\n\t// Pointer back to Person\n\tpublic get person(): Person | null {\n\t\treturn this._fields.person.value\n\t}\n\tpublic set person(value: Person | null) {\n\t\tthis._fields.person.value = value\n\t}\n\n\tpublic _fields: {\n\t\tid: $.VarRef<number>;\n\t\tperson: $.VarRef<Person | null>;\n\t}\n\n\tconstructor(init?: Partial<{id?: number, person?: Person | null}>) {\n\t\tthis._fields = {\n\t\t\tid: $.varRef(init?.id ?? 0),\n\t\t\tperson: $.varRef(init?.person ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): Employee {\n\t\tconst cloned = new Employee()\n\t\tcloned._fields = {\n\t\t\tid: $.varRef(this._fields.id.value),\n\t\t\tperson: $.varRef(this._fields.person.value ? $.markAsStructValue(this._fields.person.value.clone()) : null)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Employee',\n\t  new Employee(),\n\t  [],\n\t  Employee,\n\t  {\"id\": { kind: $.TypeKind.Basic, name: \"int\" }, \"person\": { kind: $.TypeKind.Pointer, elemType: \"Person\" }}\n\t);\n}\n\nexport class Node {\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\t// Pointer to Node - this should NOT create a dependency\n\tpublic get next(): Node | null {\n\t\treturn this._fields.next.value\n\t}\n\tpublic set next(value: Node | null) {\n\t\tthis._fields.next.value = value\n\t}\n\n\t// Another pointer - also should NOT create a dependency\n\tpublic get parent(): Node | null {\n\t\treturn this._fields.parent.value\n\t}\n\tpublic set parent(value: Node | null) {\n\t\tthis._fields.parent.value = value\n\t}\n\n\t//nolint:unused // Slice of pointers - also should NOT create a dependency\n\tpublic get children(): $.Slice<Node | null> {\n\t\treturn this._fields.children.value\n\t}\n\tpublic set children(value: $.Slice<Node | null>) {\n\t\tthis._fields.children.value = value\n\t}\n\n\tpublic _fields: {\n\t\tvalue: $.VarRef<number>;\n\t\tnext: $.VarRef<Node | null>;\n\t\tparent: $.VarRef<Node | null>;\n\t\tchildren: $.VarRef<$.Slice<Node | null>>;\n\t}\n\n\tconstructor(init?: Partial<{children?: $.Slice<Node | null>, next?: Node | null, parent?: Node | null, value?: number}>) {\n\t\tthis._fields = {\n\t\t\tvalue: $.varRef(init?.value ?? 0),\n\t\t\tnext: $.varRef(init?.next ?? null),\n\t\t\tparent: $.varRef(init?.parent ?? null),\n\t\t\tchildren: $.varRef(init?.children ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): Node {\n\t\tconst cloned = new Node()\n\t\tcloned._fields = {\n\t\t\tvalue: $.varRef(this._fields.value.value),\n\t\t\tnext: $.varRef(this._fields.next.value ? $.markAsStructValue(this._fields.next.value.clone()) : null),\n\t\t\tparent: $.varRef(this._fields.parent.value ? $.markAsStructValue(this._fields.parent.value.clone()) : null),\n\t\t\tchildren: $.varRef(this._fields.children.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Node',\n\t  new Node(),\n\t  [],\n\t  Node,\n\t  {\"value\": { kind: $.TypeKind.Basic, name: \"int\" }, \"next\": { kind: $.TypeKind.Pointer, elemType: \"Node\" }, \"parent\": { kind: $.TypeKind.Pointer, elemType: \"Node\" }, \"children\": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Pointer, elemType: \"Node\" } }}\n\t);\n}\n\nexport class Person {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\t// Pointer to Employee\n\tpublic get spouse(): Employee | null {\n\t\treturn this._fields.spouse.value\n\t}\n\tpublic set spouse(value: Employee | null) {\n\t\tthis._fields.spouse.value = value\n\t}\n\n\tpublic _fields: {\n\t\tname: $.VarRef<string>;\n\t\tspouse: $.VarRef<Employee | null>;\n\t}\n\n\tconstructor(init?: Partial<{name?: string, spouse?: Employee | null}>) {\n\t\tthis._fields = {\n\t\t\tname: $.varRef(init?.name ?? \"\"),\n\t\t\tspouse: $.varRef(init?.spouse ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tname: $.varRef(this._fields.name.value),\n\t\t\tspouse: $.varRef(this._fields.spouse.value ? $.markAsStructValue(this._fields.spouse.value.clone()) : null)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"spouse\": { kind: $.TypeKind.Pointer, elemType: \"Employee\" }}\n\t);\n}\n\nexport class TreeNode {\n\t//nolint:unused\n\tpublic get data(): string {\n\t\treturn this._fields.data.value\n\t}\n\tpublic set data(value: string) {\n\t\tthis._fields.data.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get left(): TreeNode | null {\n\t\treturn this._fields.left.value\n\t}\n\tpublic set left(value: TreeNode | null) {\n\t\tthis._fields.left.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get right(): TreeNode | null {\n\t\treturn this._fields.right.value\n\t}\n\tpublic set right(value: TreeNode | null) {\n\t\tthis._fields.right.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get parent(): TreeNode | null {\n\t\treturn this._fields.parent.value\n\t}\n\tpublic set parent(value: TreeNode | null) {\n\t\tthis._fields.parent.value = value\n\t}\n\n\tpublic _fields: {\n\t\tdata: $.VarRef<string>;\n\t\tleft: $.VarRef<TreeNode | null>;\n\t\tright: $.VarRef<TreeNode | null>;\n\t\tparent: $.VarRef<TreeNode | null>;\n\t}\n\n\tconstructor(init?: Partial<{data?: string, left?: TreeNode | null, parent?: TreeNode | null, right?: TreeNode | null}>) {\n\t\tthis._fields = {\n\t\t\tdata: $.varRef(init?.data ?? \"\"),\n\t\t\tleft: $.varRef(init?.left ?? null),\n\t\t\tright: $.varRef(init?.right ?? null),\n\t\t\tparent: $.varRef(init?.parent ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): TreeNode {\n\t\tconst cloned = new TreeNode()\n\t\tcloned._fields = {\n\t\t\tdata: $.varRef(this._fields.data.value),\n\t\t\tleft: $.varRef(this._fields.left.value ? $.markAsStructValue(this._fields.left.value.clone()) : null),\n\t\t\tright: $.varRef(this._fields.right.value ? $.markAsStructValue(this._fields.right.value.clone()) : null),\n\t\t\tparent: $.varRef(this._fields.parent.value ? $.markAsStructValue(this._fields.parent.value.clone()) : null)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.TreeNode',\n\t  new TreeNode(),\n\t  [],\n\t  TreeNode,\n\t  {\"data\": { kind: $.TypeKind.Basic, name: \"string\" }, \"left\": { kind: $.TypeKind.Pointer, elemType: \"TreeNode\" }, \"right\": { kind: $.TypeKind.Pointer, elemType: \"TreeNode\" }, \"parent\": { kind: $.TypeKind.Pointer, elemType: \"TreeNode\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Create a simple linked list\n\tlet node1 = new Node({value: 1})\n\tlet node2 = new Node({value: 2})\n\tnode1!.next = node2\n\tnode2!.parent = node1\n\n\t$.println(\"Node 1 value:\", node1!.value)\n\t$.println(\"Node 2 value:\", node2!.value)\n\n\t// Create person/employee relationship\n\tlet person = new Person({name: \"John\"})\n\tlet employee = new Employee({id: 123})\n\tperson!.spouse = employee\n\temployee!.person = person\n\n\t$.println(\"Person name:\", person!.name)\n\t$.println(\"Employee ID:\", employee!.id)\n\n\t$.println(\"Pointer circular references work fine!\")\n}\n\n",
    "expectedOutput": "Node 1 value: 1\nNode 2 value: 2\nPerson name: John\nEmployee ID: 123\nPointer circular references work fine!\n"
  },
  {
    "name": "pointer_composite_literal_assignment",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\nfunc main() {\n\t// === Pointer Composite Literal Assignment ===\n\t// Creating a pointer to a struct directly using a composite literal with &\n\tstructPointer := &MyStruct{MyInt: 42, MyString: \"composite literal pointer\"}\n\n\t// Access fields through the pointer\n\t// Expected: 42\n\tprintln(\"MyInt via pointer: Expected: 42, Actual:\", structPointer.MyInt)\n\t// Expected: \"composite literal pointer\"\n\tprintln(\"MyString via pointer: Expected: composite literal pointer, Actual: \" + structPointer.MyString)\n\n\t// Modify through the pointer\n\tstructPointer.MyInt = 99\n\t// Expected: 99\n\tprintln(\"MyInt after modification: Expected: 99, Actual:\", structPointer.MyInt)\n}\n",
    "tsCode": "// Generated file based on pointer_composite_literal_assignment.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// === Pointer Composite Literal Assignment ===\n\t// Creating a pointer to a struct directly using a composite literal with &\n\tlet structPointer = new MyStruct({MyInt: 42, MyString: \"composite literal pointer\"})\n\n\t// Access fields through the pointer\n\t// Expected: 42\n\t$.println(\"MyInt via pointer: Expected: 42, Actual:\", structPointer!.MyInt)\n\t// Expected: \"composite literal pointer\"\n\t$.println(\"MyString via pointer: Expected: composite literal pointer, Actual: \" + structPointer!.MyString)\n\n\t// Modify through the pointer\n\tstructPointer!.MyInt = 99\n\t// Expected: 99\n\t$.println(\"MyInt after modification: Expected: 99, Actual:\", structPointer!.MyInt)\n}\n\n",
    "expectedOutput": "MyInt via pointer: Expected: 42, Actual: 42\nMyString via pointer: Expected: composite literal pointer, Actual: composite literal pointer\nMyInt after modification: Expected: 99, Actual: 99"
  },
  {
    "name": "pointer_composite_literal_untyped",
    "goCode": "package main\n\nfunc main() {\n\t// This should trigger \"unhandled composite literal type: *types.Pointer\"\n\t// because the composite literal {} has no explicit type, but its type gets inferred as a pointer\n\tvar ptr *struct{ x int }\n\tptr = &struct{ x int }{42}\n\tprintln(\"Pointer value x:\", ptr.x)\n\n\t// Now try to use an untyped composite literal that resolves to a pointer\n\t// This is the case that should trigger the error\n\tdata := []*struct{ x int }{{42}, {43}}\n\n\tprintln(\"First element x:\", data[0].x)\n\tprintln(\"Second element x:\", data[1].x)\n}\n",
    "tsCode": "// Generated file based on pointer_composite_literal_untyped.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// This should trigger \"unhandled composite literal type: *types.Pointer\"\n\t// because the composite literal {} has no explicit type, but its type gets inferred as a pointer\n\tlet ptr: { x?: number } | null = null\n\tptr = {x: 42}\n\t$.println(\"Pointer value x:\", ptr!.x)\n\n\t// Now try to use an untyped composite literal that resolves to a pointer\n\t// This is the case that should trigger the error\n\tlet data = $.arrayToSlice<{ x?: number } | null>([{x: 42}, {x: 43}])\n\n\t$.println(\"First element x:\", data![0]!.x)\n\t$.println(\"Second element x:\", data![1]!.x)\n}\n\n",
    "expectedOutput": "Pointer value x: 42\nFirst element x: 42\nSecond element x: 43\n"
  },
  {
    "name": "pointer_deref_multiassign",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n\tmyBool   bool\n}\n\nfunc main() {\n\tstructPointer := &MyStruct{MyInt: 4, MyString: \"hello world\"}\n\t// === Pointer Dereference and Multi-Assignment ===\n\t// Dereference structPointer to get a copy of the struct.\n\t// Also demonstrates multi-variable assignment and the use of the blank identifier '_'.\n\tdereferencedStructCopy, _, _, unusedString := *structPointer, structPointer.myBool, structPointer.MyInt, \"hello\" // testing _ set\n\t_ = unusedString                                                                                                 // Explicitly ignore unusedString to satisfy linters\n\t_ = dereferencedStructCopy\n}\n",
    "tsCode": "// Generated file based on pointer_deref_multiassign.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic get myBool(): boolean {\n\t\treturn this._fields.myBool.value\n\t}\n\tpublic set myBool(value: boolean) {\n\t\tthis._fields.myBool.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t\tmyBool: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string, myBool?: boolean}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\"),\n\t\t\tmyBool: $.varRef(init?.myBool ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value),\n\t\t\tmyBool: $.varRef(this._fields.myBool.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }, \"myBool\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet structPointer = new MyStruct({MyInt: 4, MyString: \"hello world\"})\n\t// === Pointer Dereference and Multi-Assignment ===\n\t// Dereference structPointer to get a copy of the struct.\n\t// Also demonstrates multi-variable assignment and the use of the blank identifier '_'.\n\tlet [dereferencedStructCopy, , , unusedString] = [structPointer!, structPointer!.myBool, structPointer!.MyInt, \"hello\"] // testing _ set\n\t/* _ = */ unusedString // Explicitly ignore unusedString to satisfy linters\n\t/* _ = */ dereferencedStructCopy\n}\n\n",
    "expectedOutput": ""
  },
  {
    "name": "pointer_initialization",
    "goCode": "package main\n\n// MyStruct demonstrates a simple struct with public and private fields.\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\nfunc main() {\n\t// === Pointer Initialization ===\n\t// Create a pointer to a MyStruct instance using a composite literal.\n\tstructPointer := &MyStruct{MyInt: 4, MyString: \"hello world\"}\n\t// Expected: \"hello world\"\n\tprintln(\"Initial MyString (via pointer): Expected: hello world, Actual: \" + structPointer.MyString)\n}\n",
    "tsCode": "// Generated file based on pointer_initialization.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// === Pointer Initialization ===\n\t// Create a pointer to a MyStruct instance using a composite literal.\n\tlet structPointer = new MyStruct({MyInt: 4, MyString: \"hello world\"})\n\t// Expected: \"hello world\"\n\t$.println(\"Initial MyString (via pointer): Expected: hello world, Actual: \" + structPointer!.MyString)\n}\n\n",
    "expectedOutput": "Initial MyString (via pointer): Expected: hello world, Actual: hello world"
  },
  {
    "name": "pointer_range_loop",
    "goCode": "package main\n\nfunc main() {\n\tarr := [3]int{1, 2, 3}\n\tarrPtr := &arr\n\n\tfor i, v := range arrPtr {\n\t\tprintln(\"index:\", i, \"value:\", v)\n\t}\n}\n",
    "tsCode": "// Generated file based on pointer_range_loop.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet arr = $.varRef($.arrayToSlice<number>([1, 2, 3]))\n\tlet arrPtr = arr\n\n\tfor (let i = 0; i < $.len(arrPtr!.value); i++) {\n\t\tlet v = arrPtr!.value![i]\n\t\t{\n\t\t\t$.println(\"index:\", i, \"value:\", v)\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "index: 0 value: 1\nindex: 1 value: 2\nindex: 2 value: 3\n"
  },
  {
    "name": "pointer_struct_assign_clone",
    "goCode": "package main\n\ntype MyStruct struct {\n\tValue int\n}\n\nfunc main() {\n\ts1 := MyStruct{Value: 10}\n\tvar p *MyStruct\n\tp = &MyStruct{Value: 20} // Initialize p to point to something\n\n\t// This assignment should trigger the .clone() on s1\n\t// because s1 is a struct and *p is being assigned.\n\t*p = s1\n\n\tprintln(p.Value) // Expected: 10\n\n\t// Modify s1 to ensure p is a clone and not a reference\n\ts1.Value = 30\n\tprintln(p.Value) // Expected: 10 (still, due to clone)\n\n\t// Test assignment from a pointer to a struct (should not clone)\n\ts2 := &MyStruct{Value: 40}\n\tp2 := &MyStruct{Value: 50}\n\t*p2 = *s2         // Assigning the struct pointed to by s2 to the struct pointed to by p2\n\tprintln(p2.Value) // Expected: 40\n\n\ts2.Value = 60     // Modify original s2\n\tprintln(p2.Value) // Expected: 40 (because *s2 was cloned implicitly by Go's value semantics for struct assignment)\n\t// GoScript should replicate this by cloning if the RHS is a struct value.\n\t// In *p2 = *s2, *s2 is a struct value.\n\n\t// Test assignment of a struct from a function call\n\ts3 := MyStruct{Value: 70}\n\tp3 := &MyStruct{Value: 80}\n\t*p3 = getStruct()\n\tprintln(p3.Value) // Expected: 100\n\tprintln(s3.Value) // Expected: 70\n\n\t// Test assignment of a struct from a pointer returned by a function call\n\tp4 := &MyStruct{Value: 90}\n\t*p4 = *getStructPointer()\n\tprintln(p4.Value) // Expected: 110\n}\n\nfunc getStruct() MyStruct {\n\treturn MyStruct{Value: 100}\n}\n\nfunc getStructPointer() *MyStruct {\n\treturn &MyStruct{Value: 110}\n}\n",
    "tsCode": "// Generated file based on pointer_struct_assign_clone.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet s1 = $.markAsStructValue(new MyStruct({Value: 10}))\n\tlet p: MyStruct | null = null\n\tp = new MyStruct({Value: 20}) // Initialize p to point to something\n\n\t// This assignment should trigger the .clone() on s1\n\t// because s1 is a struct and *p is being assigned.\n\tp!.value = $.markAsStructValue(s1.clone())\n\n\t$.println(p!.Value) // Expected: 10\n\n\t// Modify s1 to ensure p is a clone and not a reference\n\ts1.Value = 30\n\t$.println(p!.Value) // Expected: 10 (still, due to clone)\n\n\t// Test assignment from a pointer to a struct (should not clone)\n\tlet s2 = new MyStruct({Value: 40})\n\tlet p2 = new MyStruct({Value: 50})\n\tp2!.value = $.markAsStructValue(s2!.clone()) // Assigning the struct pointed to by s2 to the struct pointed to by p2\n\t$.println(p2!.Value) // Expected: 40\n\n\ts2!.Value = 60 // Modify original s2\n\n\t// GoScript should replicate this by cloning if the RHS is a struct value.\n\t// In *p2 = *s2, *s2 is a struct value.\n\t$.println(p2!.Value) // Expected: 40 (because *s2 was cloned implicitly by Go's value semantics for struct assignment)\n\n\t// Test assignment of a struct from a function call\n\tlet s3 = $.markAsStructValue(new MyStruct({Value: 70}))\n\tlet p3 = new MyStruct({Value: 80})\n\tp3!.value = $.markAsStructValue(getStruct().clone())\n\t$.println(p3!.Value) // Expected: 100\n\t$.println(s3.Value) // Expected: 70\n\n\t// Test assignment of a struct from a pointer returned by a function call\n\tlet p4 = new MyStruct({Value: 90})\n\tp4!.value = $.markAsStructValue(getStructPointer()!.clone())\n\t$.println(p4!.Value) // Expected: 110\n}\n\nexport function getStruct(): MyStruct {\n\treturn $.markAsStructValue(new MyStruct({Value: 100}))\n}\n\nexport function getStructPointer(): MyStruct | null {\n\treturn new MyStruct({Value: 110})\n}\n\n",
    "expectedOutput": "10\n10\n40\n40\n100\n70\n110"
  },
  {
    "name": "pointers",
    "goCode": "package main\n\n/* not currently working correctly */\n/* @ts-ignore */\n/* eslint-disable-file */\n\ntype MyStruct struct {\n\tVal int\n}\n\nfunc main() {\n\ts1 := MyStruct{Val: 1} // p1 takes the address of s1, so s1 is varrefed\n\ts2 := MyStruct{Val: 2} // p2 takes the address of s2, so s2 is varrefed\n\n\tp1 := &s1 // *MyStruct, points to s1, pp1 takes the address of p1, so p1 is varrefed\n\tp2 := &s1 // *MyStruct, points to s1, pp2 takes the address of p2, so p2 is varrefed\n\tp3 := &s2 // *MyStruct, points to s2, pp3 takes the address of p3, so p3 is varrefed\n\n\tp4 := &s1 // *MyStruct, points to s1, nothing takes the address of p4, so p4 is not varrefed\n\t_ = p4\n\n\tpp1 := &p1 // **MyStruct, points to p1\n\tpp2 := &p2 // **MyStruct, points to p2\n\tpp3 := &p3 // **MyStruct, points to p3\n\n\tppp1 := &pp1 // ***MyStruct, points to pp1, not varrefed as nothing takes address of ppp1\n\n\tprintln(\"--- Initial Values ---\")\n\tprintln(\"s1.Val:\", s1.Val)   // 1\n\tprintln(\"s2.Val:\", s2.Val)   // 2\n\tprintln(\"p1==p2:\", p1 == p2) // true\n\tprintln(\"p1==p3:\", p1 == p3) // false\n\n\t// --- Pointer Comparisons ---\n\tprintln(\"\\n--- Pointer Comparisons ---\")\n\tprintln(\"pp1==pp2:\", pp1 == pp2)                                   // false\n\tprintln(\"pp1==pp3:\", pp1 == pp3)                                   // false\n\tprintln(\"*pp1==*pp2:\", *pp1 == *pp2)                               // true\n\tprintln(\"*pp1==*pp3:\", *pp1 == *pp3)                               // false\n\tprintln(\"(**pp1).Val == (**pp2).Val:\", (**pp1).Val == (**pp2).Val) // true\n\tprintln(\"(**pp1).Val == (**pp3).Val:\", (**pp1).Val == (**pp3).Val) // false\n\n\t// Triple pointer comparisons\n\tprintln(\"ppp1==ppp1:\", ppp1 == ppp1)                         // true\n\tprintln(\"*ppp1==pp1:\", *ppp1 == pp1)                         // true\n\tprintln(\"**ppp1==p1:\", **ppp1 == p1)                         // true\n\tprintln(\"(***ppp1).Val == s1.Val:\", (***ppp1).Val == s1.Val) // true\n\n\t// --- Modifications through Pointers ---\n\tprintln(\"\\n--- Modifications ---\")\n\t*p1 = MyStruct{Val: 10} // Modify s1 via p1\n\tprintln(\"After *p1 = {Val: 10}:\")\n\tprintln(\"  s1.Val:\", s1.Val)               // 10\n\tprintln(\"  (*p2).Val:\", (*p2).Val)         // 10\n\tprintln(\"  (**pp1).Val:\", (**pp1).Val)     // 10\n\tprintln(\"  (***ppp1).Val:\", (***ppp1).Val) // 10\n\tprintln(\"  s2.Val:\", s2.Val)               // 2 (unmodified)\n\n\t**pp3 = MyStruct{Val: 20} // Modify s2 via pp3 -> p3\n\tprintln(\"After **pp3 = {Val: 20}:\")\n\tprintln(\"  s2.Val:\", s2.Val)       // 20\n\tprintln(\"  (*p3).Val:\", (*p3).Val) // 20\n\tprintln(\"  s1.Val:\", s1.Val)       // 10 (unmodified)\n\n\t// --- Nil Pointers ---\n\tprintln(\"\\n--- Nil Pointers ---\")\n\tvar np *MyStruct = nil\n\tvar npp **MyStruct = nil\n\tvar nppp ***MyStruct = nil\n\n\tprintln(\"np == nil:\", np == nil)     // true\n\tprintln(\"npp == nil:\", npp == nil)   // true\n\tprintln(\"nppp == nil:\", nppp == nil) // true\n\n\tnpp = &np // npp now points to np (which is nil)\n\tprintln(\"After npp = &np:\")\n\tprintln(\"  npp == nil:\", npp == nil)   // false\n\tprintln(\"  *npp == nil:\", *npp == nil) // true\n}\n",
    "tsCode": "// Generated file based on pointers.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get Val(): number {\n\t\treturn this._fields.Val.value\n\t}\n\tpublic set Val(value: number) {\n\t\tthis._fields.Val.value = value\n\t}\n\n\tpublic _fields: {\n\t\tVal: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Val?: number}>) {\n\t\tthis._fields = {\n\t\t\tVal: $.varRef(init?.Val ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tVal: $.varRef(this._fields.Val.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"Val\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet s1 = $.varRef($.markAsStructValue(new MyStruct({Val: 1}))) // p1 takes the address of s1, so s1 is varrefed\n\tlet s2 = $.varRef($.markAsStructValue(new MyStruct({Val: 2}))) // p2 takes the address of s2, so s2 is varrefed\n\n\tlet p1 = $.varRef(s1) // *MyStruct, points to s1, pp1 takes the address of p1, so p1 is varrefed\n\tlet p2 = $.varRef(s1) // *MyStruct, points to s1, pp2 takes the address of p2, so p2 is varrefed\n\tlet p3 = $.varRef(s2) // *MyStruct, points to s2, pp3 takes the address of p3, so p3 is varrefed\n\n\tlet p4 = s1 // *MyStruct, points to s1, nothing takes the address of p4, so p4 is not varrefed\n\t/* _ = */ p4!.value\n\n\tlet pp1 = $.varRef(p1) // **MyStruct, points to p1\n\tlet pp2 = p2 // **MyStruct, points to p2\n\tlet pp3 = p3 // **MyStruct, points to p3\n\n\tlet ppp1 = pp1 // ***MyStruct, points to pp1, not varrefed as nothing takes address of ppp1\n\n\t$.println(\"--- Initial Values ---\")\n\t$.println(\"s1.Val:\", s1!.value.Val) // 1\n\t$.println(\"s2.Val:\", s2!.value.Val) // 2\n\t$.println(\"p1==p2:\", (p1!.value === p2!.value)) // true\n\t$.println(\"p1==p3:\", (p1!.value === p3!.value)) // false\n\n\t// --- Pointer Comparisons ---\n\t$.println(\"\\n--- Pointer Comparisons ---\")\n\t$.println(\"pp1==pp2:\", (pp1!.value === pp2)) // false\n\t$.println(\"pp1==pp3:\", (pp1!.value === pp3)) // false\n\t$.println(\"*pp1==*pp2:\", (pp1!.value!.value === pp2!.value)) // true\n\t$.println(\"*pp1==*pp3:\", (pp1!.value!.value === pp3!.value)) // false\n\t$.println(\"(**pp1).Val == (**pp2).Val:\", pp1!.value!.value!!.value.Val == pp2!.value!!.value.Val) // true\n\t$.println(\"(**pp1).Val == (**pp3).Val:\", pp1!.value!.value!!.value.Val == pp3!.value!!.value.Val) // false\n\n\t// Triple pointer comparisons\n\t$.println(\"ppp1==ppp1:\", (ppp1 === ppp1)) // true\n\t$.println(\"*ppp1==pp1:\", (ppp1!.value === pp1!.value)) // true\n\t$.println(\"**ppp1==p1:\", (ppp1!.value!.value === p1!.value)) // true\n\t$.println(\"(***ppp1).Val == s1.Val:\", ppp1!.value!.value!!.value.Val == s1!.value.Val) // true\n\n\t// --- Modifications through Pointers ---\n\t$.println(\"\\n--- Modifications ---\")\n\tp1!.value!.value = $.markAsStructValue(new MyStruct({Val: 10})) // Modify s1 via p1\n\t$.println(\"After *p1 = {Val: 10}:\")\n\t$.println(\"  s1.Val:\", s1!.value.Val) // 10\n\t$.println(\"  (*p2).Val:\", p2!.value!!.value.Val) // 10\n\t$.println(\"  (**pp1).Val:\", pp1!.value!.value!!.value.Val) // 10\n\t$.println(\"  (***ppp1).Val:\", ppp1!.value!.value!!.value.Val) // 10\n\t$.println(\"  s2.Val:\", s2!.value.Val) // 2 (unmodified)\n\n\tpp3!.value!.value = $.markAsStructValue(new MyStruct({Val: 20})) // Modify s2 via pp3 -> p3\n\t$.println(\"After **pp3 = {Val: 20}:\")\n\t$.println(\"  s2.Val:\", s2!.value.Val) // 20\n\t$.println(\"  (*p3).Val:\", p3!.value!!.value.Val) // 20\n\t$.println(\"  s1.Val:\", s1!.value.Val) // 10 (unmodified)\n\n\t// --- Nil Pointers ---\n\t$.println(\"\\n--- Nil Pointers ---\")\n\tlet np: $.VarRef<MyStruct | null> = $.varRef(null)\n\tlet npp: $.VarRef<MyStruct | null> | null = null\n\tlet nppp: $.VarRef<$.VarRef<MyStruct | null> | null> | null = null\n\n\t$.println(\"np == nil:\", np!.value == null) // true\n\t$.println(\"npp == nil:\", npp == null) // true\n\t$.println(\"nppp == nil:\", nppp == null) // true\n\n\tnpp = np // npp now points to np (which is nil)\n\t$.println(\"After npp = &np:\")\n\t$.println(\"  npp == nil:\", npp == null) // false\n\t$.println(\"  *npp == nil:\", npp!.value == null) // true\n}\n\n",
    "expectedOutput": "--- Initial Values ---\ns1.Val: 1\ns2.Val: 2\np1==p2: true\np1==p3: false\n\n--- Pointer Comparisons ---\npp1==pp2: false\npp1==pp3: false\n*pp1==*pp2: true\n*pp1==*pp3: false\n(**pp1).Val == (**pp2).Val: true\n(**pp1).Val == (**pp3).Val: false\nppp1==ppp1: true\n*ppp1==pp1: true\n**ppp1==p1: true\n(***ppp1).Val == s1.Val: true\n\n--- Modifications ---\nAfter *p1 = {Val: 10}:\n  s1.Val: 10\n  (*p2).Val: 10\n  (**pp1).Val: 10\n  (***ppp1).Val: 10\n  s2.Val: 2\nAfter **pp3 = {Val: 20}:\n  s2.Val: 20\n  (*p3).Val: 20\n  s1.Val: 10\n\n--- Nil Pointers ---\nnp == nil: true\nnpp == nil: true\nnppp == nil: true\nAfter npp = &np:\n  npp == nil: false\n  *npp == nil: true"
  },
  {
    "name": "primitive_error_type",
    "goCode": "package main\n\n// MyError is a primitive int type that implements error\ntype MyError int\n\nfunc (e MyError) Error() string {\n\tif e == 0 {\n\t\treturn \"no error\"\n\t}\n\treturn \"error occurred\"\n}\n\n// mayFail returns an error if n is negative\nfunc mayFail(n int) error {\n\tif n < 0 {\n\t\treturn MyError(n)\n\t}\n\treturn nil\n}\n\nfunc main() {\n\terr := mayFail(5)\n\tif err == nil {\n\t\tprintln(\"mayFail(5): no error\")\n\t} else {\n\t\tprintln(\"mayFail(5):\", err.Error())\n\t}\n\n\terr = mayFail(-1)\n\tif err == nil {\n\t\tprintln(\"mayFail(-1): no error\")\n\t} else {\n\t\tprintln(\"mayFail(-1):\", err.Error())\n\t}\n}\n",
    "tsCode": "// Generated file based on primitive_error_type.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyError = number;\n\nexport function MyError_Error(e: MyError): string {\n\tif (e == 0) {\n\t\treturn \"no error\"\n\t}\n\treturn \"error occurred\"\n}\n\n\n// mayFail returns an error if n is negative\nexport function mayFail(n: number): $.GoError {\n\tif (n < 0) {\n\t\treturn $.wrapPrimitiveError((n as MyError), MyError_Error)\n\t}\n\treturn null\n}\n\nexport async function main(): Promise<void> {\n\tlet err = mayFail(5)\n\tif (err == null) {\n\t\t$.println(\"mayFail(5): no error\")\n\t} else {\n\t\t$.println(\"mayFail(5):\", err!.Error())\n\t}\n\n\terr = mayFail(-1)\n\tif (err == null) {\n\t\t$.println(\"mayFail(-1): no error\")\n\t} else {\n\t\t$.println(\"mayFail(-1):\", err!.Error())\n\t}\n}\n\n",
    "expectedOutput": "mayFail(5): no error\nmayFail(-1): error occurred\n"
  },
  {
    "name": "private_field_access",
    "goCode": "package main\n\ntype MyStruct struct {\n\tpublicField  string\n\tprivateField int\n}\n\nfunc NewMyStruct(pub string, priv int) MyStruct {\n\treturn MyStruct{\n\t\tpublicField:  pub,\n\t\tprivateField: priv,\n\t}\n}\n\nfunc accessPrivateField(s MyStruct) {\n\t// Accessing privateField directly from a function in the same package\n\t// This should trigger the generation of the _private field\n\tprintln(\"Accessing privateField:\", s.privateField)\n}\n\nfunc main() {\n\ts := NewMyStruct(\"hello\", 123)\n\taccessPrivateField(s)\n}\n",
    "tsCode": "// Generated file based on private_field_access.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get publicField(): string {\n\t\treturn this._fields.publicField.value\n\t}\n\tpublic set publicField(value: string) {\n\t\tthis._fields.publicField.value = value\n\t}\n\n\tpublic get privateField(): number {\n\t\treturn this._fields.privateField.value\n\t}\n\tpublic set privateField(value: number) {\n\t\tthis._fields.privateField.value = value\n\t}\n\n\tpublic _fields: {\n\t\tpublicField: $.VarRef<string>;\n\t\tprivateField: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{privateField?: number, publicField?: string}>) {\n\t\tthis._fields = {\n\t\t\tpublicField: $.varRef(init?.publicField ?? \"\"),\n\t\t\tprivateField: $.varRef(init?.privateField ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tpublicField: $.varRef(this._fields.publicField.value),\n\t\t\tprivateField: $.varRef(this._fields.privateField.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"publicField\": { kind: $.TypeKind.Basic, name: \"string\" }, \"privateField\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport function NewMyStruct(pub: string, priv: number): MyStruct {\n\treturn $.markAsStructValue(new MyStruct({privateField: priv, publicField: pub}))\n}\n\nexport function accessPrivateField(s: MyStruct): void {\n\t// Accessing privateField directly from a function in the same package\n\t// This should trigger the generation of the _private field\n\t$.println(\"Accessing privateField:\", s.privateField)\n}\n\nexport async function main(): Promise<void> {\n\tlet s = $.markAsStructValue(NewMyStruct(\"hello\", 123).clone())\n\taccessPrivateField(s)\n}\n\n",
    "expectedOutput": "Accessing privateField: 123"
  },
  {
    "name": "promise_return_type",
    "goCode": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype AsyncData struct {\n\tmu    sync.Mutex\n\tvalue int\n}\n\n// This returns a value and should be async due to mutex\nfunc (d *AsyncData) GetValue() int {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\treturn d.value\n}\n\n// This should handle the Promise return type correctly\nfunc processData(d *AsyncData) {\n\t// This should await the async method call\n\tresult := d.GetValue()\n\tfmt.Printf(\"Result: %d\\n\", result)\n}\n\nfunc main() {\n\tdata := &AsyncData{value: 42}\n\tprocessData(data)\n}\n",
    "tsCode": "// Generated file based on promise_return_type.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as fmt from \"@goscript/fmt/index.js\"\n\nimport * as sync from \"@goscript/sync/index.js\"\n\nexport class AsyncData {\n\tpublic get mu(): sync.Mutex {\n\t\treturn this._fields.mu.value\n\t}\n\tpublic set mu(value: sync.Mutex) {\n\t\tthis._fields.mu.value = value\n\t}\n\n\tpublic get value(): number {\n\t\treturn this._fields.value.value\n\t}\n\tpublic set value(value: number) {\n\t\tthis._fields.value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tmu: $.VarRef<sync.Mutex>;\n\t\tvalue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{mu?: sync.Mutex, value?: number}>) {\n\t\tthis._fields = {\n\t\t\tmu: $.varRef(init?.mu ? $.markAsStructValue(init.mu.clone()) : new sync.Mutex()),\n\t\t\tvalue: $.varRef(init?.value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): AsyncData {\n\t\tconst cloned = new AsyncData()\n\t\tcloned._fields = {\n\t\t\tmu: $.varRef($.markAsStructValue(this._fields.mu.value.clone())),\n\t\t\tvalue: $.varRef(this._fields.value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// This returns a value and should be async due to mutex\n\tpublic async GetValue(): Promise<number> {\n\t\tconst d = this\n\t\tusing __defer = new $.DisposableStack();\n\t\tawait d.mu.Lock()\n\t\t__defer.defer(() => {\n\t\t\td.mu.Unlock()\n\t\t});\n\t\treturn d.value\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.AsyncData',\n\t  new AsyncData(),\n\t  [{ name: \"GetValue\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  AsyncData,\n\t  {\"mu\": \"Mutex\", \"value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\n// This should handle the Promise return type correctly\nexport async function processData(d: AsyncData | null): Promise<void> {\n\t// This should await the async method call\n\tlet result = await d!.GetValue()\n\tfmt.Printf(\"Result: %d\\n\", result)\n}\n\nexport async function main(): Promise<void> {\n\tlet data = new AsyncData({value: 42})\n\tawait processData(data)\n}\n\n",
    "expectedOutput": "Result: 42\n"
  },
  {
    "name": "protobuf_lite_ts",
    "goCode": "package main\n\nfunc main() {\n\tmsg := &ExampleMsg{\n\t\tExampleField: []byte(\"hello\"),\n\t\tExampleText:  \"world\",\n\t}\n\n\tdata, err := msg.MarshalVT()\n\tif err != nil {\n\t\tprintln(\"error marshalling:\", err.Error())\n\t\treturn\n\t}\n\n\tprintln(\"data:\", data)\n\n\tout := &ExampleMsg{}\n\terr = out.UnmarshalVT(data)\n\tif err != nil {\n\t\tprintln(\"error unmarshalling:\", err.Error())\n\t\treturn\n\t}\n\n\tprintln(\"out:\", out)\n\n\tjdata, err := msg.MarshalJSON()\n\tif err != nil {\n\t\tprintln(\"error marshalling to json:\", err.Error())\n\t\treturn\n\t}\n\n\tprintln(\"json marshaled:\", string(jdata))\n\n\tout = &ExampleMsg{}\n\terr2 := out.UnmarshalJSON(jdata)\n\tif err2 != nil {\n\t\tprintln(\"error unmarshalling from json:\", err.Error())\n\t\treturn\n\t}\n\n\tprintln(\"json unmarshaled:\", out)\n}\n",
    "tsCode": "// Generated file based on protobuf_lite_ts.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\nimport { protobufPackage, ExampleMsg } from \"./protobuf_lite_ts.pb.js\";\n\nexport async function main(): Promise<void> {\n\tlet msg = ExampleMsg.create({exampleField: $.stringToBytes(\"hello\"), exampleText: \"world\"})\n\n\tconst data = ExampleMsg.toBinary(msg)\n\tlet err: $.GoError | null = null as $.GoError | null\n\tif (err != null) {\n\t\t$.println(\"error marshalling:\", err!.Error())\n\t\treturn \n\t}\n\n\t$.println(\"data:\", data)\n\n\tlet out = ExampleMsg.create({})\n\tout = ExampleMsg.fromBinary($.normalizeBytes(data))\n\terr = null as $.GoError | null\n\tif (err != null) {\n\t\t$.println(\"error unmarshalling:\", err!.Error())\n\t\treturn \n\t}\n\n\t$.println(\"out:\", out)\n\n\tconst jdata = ExampleMsg.toJsonString(msg)\n\terr = null as $.GoError | null\n\tif (err != null) {\n\t\t$.println(\"error marshalling to json:\", err!.Error())\n\t\treturn \n\t}\n\n\t$.println(\"json marshaled:\", $.bytesToString(jdata))\n\n\tout = ExampleMsg.create({})\n\tout = ExampleMsg.fromJsonString(jdata)\n\tlet err2: $.GoError | null = null as $.GoError | null\n\tif (err2 != null) {\n\t\t$.println(\"error unmarshalling from json:\", err!.Error())\n\t\treturn \n\t}\n\n\t$.println(\"json unmarshaled:\", out)\n}\n\n",
    "expectedOutput": "data: Uint8Array(14) [ 10, 5, 104, 101, 108, 108, 111, 18, 5, 119, 111, 114, 108, 100 ]\nout: {\n  exampleField: Uint8Array(5) [ 104, 101, 108, 108, 111 ],\n  exampleText: \"world\",\n}\njson marshaled: {\"exampleField\":\"aGVsbG8=\",\"exampleText\":\"world\"}\njson unmarshaled: {\n  exampleField: Uint8Array(5) [ 104, 101, 108, 108, 111 ],\n  exampleText: \"world\",\n}\n"
  },
  {
    "name": "range_const_reassign",
    "goCode": "package main\n\nfunc main() {\n\ts := \"abc\"\n\tfor _, c := range s {\n\t\tif c >= 'a' {\n\t\t\tc = c - 'a' + 10\n\t\t}\n\t\tprintln(int(c))\n\t}\n}\n",
    "tsCode": "// Generated file based on range_const_reassign.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet s = \"abc\"\n\t{\n\t\tconst _runes = $.stringToRunes(s)\n\t\tfor (let i = 0; i < _runes.length; i++) {\n\t\t\tlet c = _runes[i]\n\t\t\t{\n\t\t\t\tif (c >= 97) {\n\t\t\t\t\tc = c - 97 + 10\n\t\t\t\t}\n\t\t\t\t$.println($.int(c))\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "10\n11\n12\n"
  },
  {
    "name": "receiver_variable",
    "goCode": "package main\n\nimport (\n\t\"errors\"\n\t\"sync\"\n)\n\ntype content struct {\n\tname  string\n\tbytes []byte\n\tm     sync.RWMutex\n}\n\nfunc (c *content) WriteAt(p []byte, off int64) (int, error) {\n\tif off < 0 {\n\t\treturn 0, errors.New(\"negative offset\")\n\t}\n\n\tc.m.Lock()\n\tprev := len(c.bytes)\n\n\tdiff := int(off) - prev\n\tif diff > 0 {\n\t\tc.bytes = append(c.bytes, make([]byte, diff)...)\n\t}\n\n\tc.bytes = append(c.bytes[:off], p...)\n\tif len(c.bytes) < prev {\n\t\tc.bytes = c.bytes[:prev]\n\t}\n\tc.m.Unlock()\n\n\treturn len(p), nil\n}\n\nfunc (c *content) ReadAt(b []byte, off int64) (n int, err error) {\n\tif off < 0 {\n\t\treturn 0, errors.New(\"negative offset\")\n\t}\n\n\tc.m.RLock()\n\tsize := int64(len(c.bytes))\n\tif off >= size {\n\t\tc.m.RUnlock()\n\t\treturn 0, errors.New(\"EOF\")\n\t}\n\n\tl := int64(len(b))\n\tif off+l > size {\n\t\tl = size - off\n\t}\n\n\tbtr := c.bytes[off : off+l]\n\tn = copy(b, btr)\n\n\tif len(btr) < len(b) {\n\t\terr = errors.New(\"EOF\")\n\t}\n\tc.m.RUnlock()\n\n\treturn\n}\n\nfunc (c *content) Size() int {\n\tc.m.RLock()\n\tdefer func() {\n\t\tc.m.RUnlock()\n\t}()\n\treturn len(c.bytes)\n}\n\nfunc (c *content) Clear() {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\t// Variable shadowing that might cause scoping issues\n\tif len := len(c.bytes); len > 0 {\n\t\tc.bytes = make([]byte, 0)\n\t}\n}\n\n// Method with complex variable scoping\nfunc (c *content) ComplexMethod() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\t// Initial receiver usage\n\tif len(c.bytes) == 0 {\n\t\tc.bytes = make([]byte, 10)\n\t}\n\n\t// Variable shadowing in a loop\n\tfor i := 0; i < 3; i++ {\n\t\tif data, err := c.getData(i); err == nil {\n\t\t\t// Nested scope with receiver usage\n\t\t\tif len(data) > 0 {\n\t\t\t\tc.bytes = append(c.bytes, data...)\n\t\t\t}\n\t\t}\n\t}\n\n\t// More complex scoping with if statements\n\tif x := len(c.bytes); x > 20 {\n\t\t// Use receiver in nested scope\n\t\tc.bytes = c.bytes[:20]\n\n\t\t// Nested function literal that might affect scoping\n\t\tfn := func() {\n\t\t\tif len(c.bytes) > 0 {\n\t\t\t\tc.bytes[0] = 42\n\t\t\t}\n\t\t}\n\t\tfn()\n\t}\n\n\treturn nil\n}\n\nfunc (c *content) getData(index int) ([]byte, error) {\n\tif index < 0 {\n\t\treturn nil, errors.New(\"invalid index\")\n\t}\n\treturn []byte{byte(index), byte(index + 1)}, nil\n}\n\n// Simple methods that should trigger receiver binding but might not\nfunc (c *content) Truncate() {\n\tc.bytes = make([]byte, 0)\n}\n\nfunc (c *content) Len() int {\n\treturn len(c.bytes)\n}\n\nfunc main() {\n\tc := &content{\n\t\tname:  \"test\",\n\t\tbytes: make([]byte, 0),\n\t}\n\n\t// Test basic functionality that should work\n\tif err := c.ComplexMethod(); err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t\treturn\n\t}\n\n\tprintln(\"Complex method completed, size:\", c.Size())\n}\n",
    "tsCode": "// Generated file based on receiver_variable.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as errors from \"@goscript/errors/index.js\"\n\nimport * as sync from \"@goscript/sync/index.js\"\n\nexport class content {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic get bytes(): $.Bytes {\n\t\treturn this._fields.bytes.value\n\t}\n\tpublic set bytes(value: $.Bytes) {\n\t\tthis._fields.bytes.value = value\n\t}\n\n\tpublic get m(): sync.RWMutex {\n\t\treturn this._fields.m.value\n\t}\n\tpublic set m(value: sync.RWMutex) {\n\t\tthis._fields.m.value = value\n\t}\n\n\tpublic _fields: {\n\t\tname: $.VarRef<string>;\n\t\tbytes: $.VarRef<$.Bytes>;\n\t\tm: $.VarRef<sync.RWMutex>;\n\t}\n\n\tconstructor(init?: Partial<{bytes?: $.Bytes, m?: sync.RWMutex, name?: string}>) {\n\t\tthis._fields = {\n\t\t\tname: $.varRef(init?.name ?? \"\"),\n\t\t\tbytes: $.varRef(init?.bytes ?? new Uint8Array(0)),\n\t\t\tm: $.varRef(init?.m ? $.markAsStructValue(init.m.clone()) : new sync.RWMutex())\n\t\t}\n\t}\n\n\tpublic clone(): content {\n\t\tconst cloned = new content()\n\t\tcloned._fields = {\n\t\t\tname: $.varRef(this._fields.name.value),\n\t\t\tbytes: $.varRef(this._fields.bytes.value),\n\t\t\tm: $.varRef($.markAsStructValue(this._fields.m.value.clone()))\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic async WriteAt(p: $.Bytes, off: number): Promise<[number, $.GoError]> {\n\t\tconst c = this\n\t\tif (off < 0) {\n\t\t\treturn [0, errors.New(\"negative offset\")]\n\t\t}\n\t\tawait c.m.Lock()\n\t\tlet prev = $.len(c.bytes)\n\t\tlet diff = $.int(off) - prev\n\t\tif (diff > 0) {\n\t\t\tc.bytes = $.append(c.bytes, ...(new Uint8Array(diff) || []))\n\t\t}\n\t\tc.bytes = $.append($.goSlice(c.bytes, undefined, off), ...(p || []))\n\t\tif ($.len(c.bytes) < prev) {\n\t\t\tc.bytes = $.goSlice(c.bytes, undefined, prev)\n\t\t}\n\t\tc.m.Unlock()\n\t\treturn [$.len(p), null]\n\t}\n\n\tpublic async ReadAt(b: $.Bytes, off: number): Promise<[number, $.GoError]> {\n\t\tconst c = this\n\t\tlet n: number = 0\n\t\tlet err: $.GoError = null\n\t\tif (off < 0) {\n\t\t\treturn [0, errors.New(\"negative offset\")]\n\t\t}\n\t\tawait c.m.RLock()\n\t\tlet size = ($.len(c.bytes) as number)\n\t\tif (off >= size) {\n\t\t\tc.m.RUnlock()\n\t\t\treturn [0, errors.New(\"EOF\")]\n\t\t}\n\t\tlet l = ($.len(b) as number)\n\t\tif (off + l > size) {\n\t\t\tl = size - off\n\t\t}\n\t\tlet btr = $.goSlice(c.bytes, off, off + l)\n\t\tn = $.copy(b, btr)\n\t\tif ($.len(btr) < $.len(b)) {\n\t\t\terr = errors.New(\"EOF\")\n\t\t}\n\t\tc.m.RUnlock()\n\t\treturn [n, err]\n\t}\n\n\tpublic async Size(): Promise<number> {\n\t\tconst c = this\n\t\tusing __defer = new $.DisposableStack();\n\t\tawait c.m.RLock()\n\t\t__defer.defer(() => {\n\t\t\tc.m.RUnlock()\n\t\t});\n\t\treturn $.len(c.bytes)\n\t}\n\n\tpublic async Clear(): Promise<void> {\n\t\tconst c = this\n\t\tusing __defer = new $.DisposableStack();\n\t\tawait c.m.Lock()\n\t\t__defer.defer(() => {\n\t\t\tc.m.Unlock()\n\t\t});\n\t\tconst _temp_len = $.len\n\t\t{\n\t\t\tlet len = _temp_len(c.bytes)\n\t\t\tif (len > 0) {\n\t\t\t\tc.bytes = new Uint8Array(0)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Method with complex variable scoping\n\tpublic async ComplexMethod(): Promise<$.GoError> {\n\t\tconst c = this\n\t\tusing __defer = new $.DisposableStack();\n\t\tawait c.m.Lock()\n\t\t__defer.defer(() => {\n\t\t\tc.m.Unlock()\n\t\t});\n\t\tif ($.len(c.bytes) == 0) {\n\t\t\tc.bytes = new Uint8Array(10)\n\t\t}\n\t\tfor (let i = 0; i < 3; i++) {\n\n\t\t\t// Nested scope with receiver usage\n\t\t\t{\n\t\t\t\tlet [data, err] = c.getData(i)\n\t\t\t\tif (err == null) {\n\t\t\t\t\t// Nested scope with receiver usage\n\t\t\t\t\tif ($.len(data) > 0) {\n\t\t\t\t\t\tc.bytes = $.append(c.bytes, ...(data || []))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tlet x = $.len(c.bytes)\n\t\t\tif (x > 20) {\n\t\t\t\t// Use receiver in nested scope\n\t\t\t\tc.bytes = $.goSlice(c.bytes, undefined, 20)\n\n\t\t\t\t// Nested function literal that might affect scoping\n\t\t\t\tlet fn = (): void => {\n\t\t\t\t\tif ($.len(c.bytes) > 0) {\n\t\t\t\t\t\tc.bytes![0] = 42\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfn!()\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\tpublic getData(index: number): [$.Bytes, $.GoError] {\n\t\tif (index < 0) {\n\t\t\treturn [null, errors.New(\"invalid index\")]\n\t\t}\n\t\treturn [new Uint8Array([$.byte(index), $.byte(index + 1)]), null]\n\t}\n\n\t// Simple methods that should trigger receiver binding but might not\n\tpublic Truncate(): void {\n\t\tconst c = this\n\t\tc.bytes = new Uint8Array(0)\n\t}\n\n\tpublic Len(): number {\n\t\tconst c = this\n\t\treturn $.len(c.bytes)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.content',\n\t  new content(),\n\t  [{ name: \"WriteAt\", args: [{ name: \"p\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }, { name: \"off\", type: { kind: $.TypeKind.Basic, name: \"int64\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"ReadAt\", args: [{ name: \"b\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }, { name: \"off\", type: { kind: $.TypeKind.Basic, name: \"int64\" } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Size\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }, { name: \"Clear\", args: [], returns: [] }, { name: \"ComplexMethod\", args: [], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"getData\", args: [{ name: \"index\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [{ type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }, { name: \"Truncate\", args: [], returns: [] }, { name: \"Len\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  content,\n\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"bytes\": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } }, \"m\": \"RWMutex\"}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet c = new content({bytes: new Uint8Array(0), name: \"test\"})\n\n\t// Test basic functionality that should work\n\t{\n\t\tlet err = await c!.ComplexMethod()\n\t\tif (err != null) {\n\t\t\t$.println(\"Error:\", err!.Error())\n\t\t\treturn \n\t\t}\n\t}\n\n\t$.println(\"Complex method completed, size:\", await c!.Size())\n}\n\n",
    "expectedOutput": "Complex method completed, size: 16\n"
  },
  {
    "name": "recursive_type_definition",
    "goCode": "package main\n\ntype A interface {\n\tMethodA(a A)\n}\n\ntype B struct{}\n\nfunc (b *B) MethodB(valB *B) {}\n\n// It's also possible with mutually recursive types\ntype C interface {\n\tMethodC(d D)\n}\n\ntype D interface {\n\tMethodD(c C)\n}\n\nfunc main() {\n\tprintln(\"recursive type definition test\")\n}\n",
    "tsCode": "// Generated file based on recursive_type_definition.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type A = null | {\n\tMethodA(a: A): void\n}\n\n$.registerInterfaceType(\n  'main.A',\n  null, // Zero value for interface is null\n  [{ name: \"MethodA\", args: [{ name: \"a\", type: \"A\" }], returns: [] }]\n);\n\nexport class B {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): B {\n\t\tconst cloned = new B()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic MethodB(valB: B | null): void {\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.B',\n\t  new B(),\n\t  [{ name: \"MethodB\", args: [{ name: \"valB\", type: { kind: $.TypeKind.Pointer, elemType: \"B\" } }], returns: [] }],\n\t  B,\n\t  {}\n\t);\n}\n\nexport type C = null | {\n\tMethodC(d: D): void\n}\n\n$.registerInterfaceType(\n  'main.C',\n  null, // Zero value for interface is null\n  [{ name: \"MethodC\", args: [{ name: \"d\", type: \"D\" }], returns: [] }]\n);\n\nexport type D = null | {\n\tMethodD(c: C): void\n}\n\n$.registerInterfaceType(\n  'main.D',\n  null, // Zero value for interface is null\n  [{ name: \"MethodD\", args: [{ name: \"c\", type: \"C\" }], returns: [] }]\n);\n\nexport async function main(): Promise<void> {\n\t$.println(\"recursive type definition test\")\n}\n\n",
    "expectedOutput": "recursive type definition test\n"
  },
  {
    "name": "redeclaration_assign",
    "goCode": "package main\n\nfunc returnsOneIntOneBool() (int, bool) {\n\treturn 7, true\n}\n\nfunc main() {\n\tvar i int\n\tprintln(\"initial i:\", i) /* Use i to avoid unused error before := */\n\n\t// i already exists from the var declaration above.\n\t// err is a new variable being declared.\n\ti, err := returnsOneIntOneBool()\n\n\tprintln(\"after assign i:\", i) // Use i\n\tif err {                      // Use err\n\t\tprintln(\"err is true\")\n\t} else {\n\t\tprintln(\"err is false\")\n\t}\n}\n",
    "tsCode": "// Generated file based on redeclaration_assign.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function returnsOneIntOneBool(): [number, boolean] {\n\treturn [7, true]\n}\n\nexport async function main(): Promise<void> {\n\tlet i: number = 0\n\t$.println(\"initial i:\", i) // Use i to avoid unused error before :=\n\n\t// i already exists from the var declaration above.\n\t// err is a new variable being declared.\n\tlet err: boolean\n\t[i, err] = returnsOneIntOneBool()\n\n\t$.println(\"after assign i:\", i) // Use i\n\t// Use err\n\tif (err) {\n\t\t// Use err\n\t\t$.println(\"err is true\")\n\t} else {\n\t\t$.println(\"err is false\")\n\t}\n}\n\n",
    "expectedOutput": "initial i: 0\nafter assign i: 7\nerr is true"
  },
  {
    "name": "reflect_implements",
    "goCode": "package main\n\nimport \"reflect\"\n\ntype Stringer interface {\n\tString() string\n}\n\ntype MyType struct{}\n\nfunc (m MyType) String() string {\n\treturn \"MyType\"\n}\n\nfunc main() {\n\tt := reflect.TypeOf(MyType{})\n\tptr := reflect.PointerTo(t)\n\tiface := reflect.TypeOf((*Stringer)(nil)).Elem()\n\n\tprintln(\"MyType implements Stringer:\", t.Implements(iface))\n\tprintln(\"*MyType implements Stringer:\", ptr.Implements(iface))\n}\n",
    "tsCode": "// Generated file based on reflect_implements.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class MyType {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MyType {\n\t\tconst cloned = new MyType()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic String(): string {\n\t\treturn \"MyType\"\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyType',\n\t  new MyType(),\n\t  [{ name: \"String\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  MyType,\n\t  {}\n\t);\n}\n\nexport type Stringer = null | {\n\tString(): string\n}\n\n$.registerInterfaceType(\n  'main.Stringer',\n  null, // Zero value for interface is null\n  [{ name: \"String\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport async function main(): Promise<void> {\n\tlet t = reflect.TypeOf($.markAsStructValue(new MyType({})))\n\tlet ptr = reflect.PointerTo(t)\n\tlet iface = reflect.TypeOf($.typedNil(\"*main.Stringer\"))!.Elem()\n\n\t$.println(\"MyType implements Stringer:\", t!.Implements(iface))\n\t$.println(\"*MyType implements Stringer:\", ptr!.Implements(iface))\n}\n\n",
    "expectedOutput": "MyType implements Stringer: true\n*MyType implements Stringer: true\n"
  },
  {
    "name": "reflect_numfield",
    "goCode": "package main\n\nimport (\n\t\"reflect\"\n)\n\ntype Person struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tActive bool   `json:\"active\"`\n}\n\nfunc main() {\n\tp := Person{Name: \"Alice\", Age: 30, Active: true}\n\tt := reflect.TypeOf(p)\n\tprintln(\"Type:\", t.Name())\n\tprintln(\"Kind:\", t.Kind().String())\n\tprintln(\"NumField:\", t.NumField())\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tf := t.Field(i)\n\t\tprintln(\"Field\", i, \"Name:\", f.Name)\n\t\tprintln(\"Field\", i, \"Tag:\", string(f.Tag))\n\t\t// Test the Get method\n\t\tjsonTag := f.Tag.Get(\"json\")\n\t\tprintln(\"Field\", i, \"JsonTag:\", jsonTag)\n\t}\n}\n",
    "tsCode": "// Generated file based on reflect_numfield.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic get Active(): boolean {\n\t\treturn this._fields.Active.value\n\t}\n\tpublic set Active(value: boolean) {\n\t\tthis._fields.Active.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t\tActive: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{Active?: boolean, Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0),\n\t\t\tActive: $.varRef(init?.Active ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value),\n\t\t\tActive: $.varRef(this._fields.Active.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { type: { kind: $.TypeKind.Basic, name: \"string\" }, tag: \"json:\\\"name\\\"\" }, \"Age\": { type: { kind: $.TypeKind.Basic, name: \"int\" }, tag: \"json:\\\"age\\\"\" }, \"Active\": { type: { kind: $.TypeKind.Basic, name: \"bool\" }, tag: \"json:\\\"active\\\"\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p = $.markAsStructValue(new Person({Active: true, Age: 30, Name: \"Alice\"}))\n\tlet t = reflect.TypeOf(p)\n\t$.println(\"Type:\", t!.Name())\n\t$.println(\"Kind:\", reflect.Kind_String(t!.Kind()))\n\t$.println(\"NumField:\", t!.NumField())\n\n\t// Test the Get method\n\tfor (let i = 0; i < t!.NumField(); i++) {\n\t\tlet f = $.markAsStructValue(t!.Field(i).clone())\n\t\t$.println(\"Field\", i, \"Name:\", f.Name)\n\t\t$.println(\"Field\", i, \"Tag:\", f.Tag.toString())\n\t\t// Test the Get method\n\t\tlet jsonTag = reflect.StructTag_Get(f.Tag, \"json\")\n\t\t$.println(\"Field\", i, \"JsonTag:\", jsonTag)\n\t}\n}\n\n",
    "expectedOutput": "Type: Person\nKind: struct\nNumField: 3\nField 0 Name: Name\nField 0 Tag: json:\"name\"\nField 0 JsonTag: name\nField 1 Name: Age\nField 1 Tag: json:\"age\"\nField 1 JsonTag: age\nField 2 Name: Active\nField 2 Tag: json:\"active\"\nField 2 JsonTag: active\n"
  },
  {
    "name": "reflect_struct_basic",
    "goCode": "package main\n\nimport \"fmt\"\nimport \"reflect\"\n\ntype Person struct {\n  Name string\n  Age  int\n}\n\nfunc main() {\n  p := Person{Name: \"Alice\", Age: 30}\n  v := reflect.ValueOf(p)\n  if v.Kind() == reflect.Struct {\n    f := v.Field(0)\n    fmt.Println(f.String())\n  }\n}\n",
    "tsCode": "// Generated file based on reflect_struct_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as fmt from \"@goscript/fmt/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"Age\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p = $.markAsStructValue(new Person({Age: 30, Name: \"Alice\"}))\n\tlet v = $.markAsStructValue(reflect.ValueOf(p).clone())\n\tif (v.Kind() == reflect.Struct) {\n\t\tlet f = $.markAsStructValue(v.Field(0).clone())\n\t\tfmt.Println(f.String())\n\t}\n}\n\n",
    "expectedOutput": "Alice\n"
  },
  {
    "name": "reflect_struct_field",
    "goCode": "package main\n\nimport \"reflect\"\n\nfunc main() {\n\t// Test creating a StructField value\n\tfield := reflect.StructField{\n\t\tName: \"TestField\",\n\t\tType: reflect.TypeOf(\"\"),\n\t}\n\tprintln(\"StructField Name:\", field.Name)\n\tprintln(\"StructField Type:\", field.Type.String())\n}\n",
    "tsCode": "// Generated file based on reflect_struct_field.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test creating a StructField value\n\tlet field = $.markAsStructValue(new reflect.StructField({Name: \"TestField\", Type: reflect.TypeOf(\"\")}))\n\t$.println(\"StructField Name:\", field.Name)\n\t$.println(\"StructField Type:\", field.Type!.String())\n}\n\n",
    "expectedOutput": "StructField Name: TestField\nStructField Type: string\n"
  },
  {
    "name": "reflect_typefor",
    "goCode": "package main\n\nimport (\n\t\"reflect\"\n)\n\ntype MyStruct struct {\n\tName string\n\tAge  int\n}\n\ntype MyInterface interface {\n\tSomeMethod()\n}\n\nfunc main() {\n\t// Test TypeFor with named interface type\n\tt1 := reflect.TypeFor[MyInterface]()\n\tprintln(\"TypeFor interface:\", t1.String())\n\n\t// Test TypeFor with struct type\n\tt2 := reflect.TypeFor[MyStruct]()\n\tprintln(\"TypeFor struct:\", t2.String())\n\tprintln(\"TypeFor struct kind:\", t2.Kind() == reflect.Struct)\n\n\t// Test TypeFor with int type\n\tt3 := reflect.TypeFor[int]()\n\tprintln(\"TypeFor int:\", t3.String())\n\tprintln(\"TypeFor int kind:\", t3.Kind() == reflect.Int)\n\n\t// Test Pointer constant (should be same as Ptr)\n\tprintln(\"Pointer constant:\", reflect.Pointer == reflect.Ptr)\n\n\tprintln(\"reflect_typefor test finished\")\n}\n",
    "tsCode": "// Generated file based on reflect_typefor.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport type MyInterface = null | {\n\tSomeMethod(): void\n}\n\n$.registerInterfaceType(\n  'main.MyInterface',\n  null, // Zero value for interface is null\n  [{ name: \"SomeMethod\", args: [], returns: [] }]\n);\n\nexport class MyStruct {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"Name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"Age\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Test TypeFor with named interface type\n\tlet t1 = reflect.getInterfaceTypeByName(\"main.MyInterface\")\n\t$.println(\"TypeFor interface:\", t1!.String())\n\n\t// Test TypeFor with struct type\n\tlet t2 = reflect.TypeOf(new MyStruct())\n\t$.println(\"TypeFor struct:\", t2!.String())\n\t$.println(\"TypeFor struct kind:\", t2!.Kind() == reflect.Struct)\n\n\t// Test TypeFor with int type\n\tlet t3 = reflect.TypeOf(0)\n\t$.println(\"TypeFor int:\", t3!.String())\n\t$.println(\"TypeFor int kind:\", t3!.Kind() == reflect.Int)\n\n\t// Test Pointer constant (should be same as Ptr)\n\t$.println(\"Pointer constant:\", reflect.Ptr == reflect.Ptr)\n\n\t$.println(\"reflect_typefor test finished\")\n}\n\n",
    "expectedOutput": "TypeFor interface: interface { SomeMethod() }\nTypeFor struct: main.MyStruct\nTypeFor struct kind: true\nTypeFor int: int\nTypeFor int kind: true\nPointer constant: true\nreflect_typefor test finished\n"
  },
  {
    "name": "reserved_words",
    "goCode": "package main\n\nfunc main() {\n\t// Test reserved word conflicts that cause TypeScript compilation errors\n\t// This reproduces the \"let new: number = 0\" error we saw\n\tvar new int = 42\n\tvar class string = \"test\"\n\tvar typeof bool = true\n\n\tprintln(\"new:\", new)\n\tprintln(\"class:\", class)\n\tprintln(\"typeof:\", typeof)\n\n\t// Test function with named return that uses reserved word\n\tresult := testNamedReturn()\n\tprintln(\"named return result:\", result)\n\n\tprintln(\"test finished\")\n}\n\nfunc testNamedReturn() (new int) {\n\tnew = 100\n\treturn\n}\n",
    "tsCode": "// Generated file based on reserved_words.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test reserved word conflicts that cause TypeScript compilation errors\n\t// This reproduces the \"let new: number = 0\" error we saw\n\tlet _new: number = 42\n\tlet _class: string = \"test\"\n\tlet _typeof: boolean = true\n\n\t$.println(\"new:\", _new)\n\t$.println(\"class:\", _class)\n\t$.println(\"typeof:\", _typeof)\n\n\t// Test function with named return that uses reserved word\n\tlet result = testNamedReturn()\n\t$.println(\"named return result:\", result)\n\n\t$.println(\"test finished\")\n}\n\nexport function testNamedReturn(): number {\n\tlet _new: number = 0\n\t{\n\t\t_new = 100\n\t\treturn _new\n\t}\n}\n\n",
    "expectedOutput": "new: 42\nclass: test\ntypeof: true\nnamed return result: 100\ntest finished\n"
  },
  {
    "name": "return_async_call",
    "goCode": "package main\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\n// AsyncFunction simulates an async function\nfunc AsyncFunction() string {\n\ttime.Sleep(10 * time.Millisecond)\n\treturn \"result\"\n}\n\n// SyncWrapper directly returns result of async function - should be async\nfunc SyncWrapper() string {\n\treturn AsyncFunction()\n}\n\n// AnotherAsyncFunction simulates another async function\nfunc AnotherAsyncFunction(ctx context.Context) (string, error) {\n\ttime.Sleep(5 * time.Millisecond)\n\treturn \"async result\", nil\n}\n\n// WrapperWithError directly returns result of async function with error - should be async\nfunc WrapperWithError(ctx context.Context) (string, error) {\n\treturn AnotherAsyncFunction(ctx)\n}\n\nfunc main() {\n\t// These calls should work properly with async/await\n\tresult1 := SyncWrapper()\n\tprintln(\"Result1:\", result1)\n\n\tctx := context.Background()\n\tresult2, err := WrapperWithError(ctx)\n\tif err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t\treturn\n\t}\n\tprintln(\"Result2:\", result2)\n}\n",
    "tsCode": "// Generated file based on return_async_call.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as context from \"@goscript/context/index.js\"\n\nimport * as time from \"@goscript/time/index.js\"\n\n// AsyncFunction simulates an async function\nexport async function AsyncFunction(): Promise<string> {\n\tawait time.Sleep(10 * time.Millisecond)\n\treturn \"result\"\n}\n\n// SyncWrapper directly returns result of async function - should be async\nexport async function SyncWrapper(): Promise<string> {\n\treturn await AsyncFunction()\n}\n\n// AnotherAsyncFunction simulates another async function\nexport async function AnotherAsyncFunction(ctx: null | context.Context): Promise<[string, $.GoError]> {\n\tawait time.Sleep(5 * time.Millisecond)\n\treturn [\"async result\", null]\n}\n\n// WrapperWithError directly returns result of async function with error - should be async\nexport async function WrapperWithError(ctx: null | context.Context): Promise<[string, $.GoError]> {\n\treturn await AnotherAsyncFunction(ctx)\n}\n\nexport async function main(): Promise<void> {\n\t// These calls should work properly with async/await\n\tlet result1 = await SyncWrapper()\n\t$.println(\"Result1:\", result1)\n\n\tlet ctx = context.Background()\n\tlet [result2, err] = await WrapperWithError(ctx)\n\tif (err != null) {\n\t\t$.println(\"Error:\", err!.Error())\n\t\treturn \n\t}\n\t$.println(\"Result2:\", result2)\n}\n\n",
    "expectedOutput": "Result1: result\nResult2: async result\n"
  },
  {
    "name": "rune_const_import",
    "goCode": "package main\n\nimport \"github.com/aperturerobotics/goscript/tests/tests/rune_const_import/subpkg\"\n\nfunc main() {\n\t// Test importing rune constants from another package\n\tconst separator = subpkg.Separator\n\tconst newline = subpkg.Newline\n\tconst space = subpkg.Space\n\n\t// Print the imported rune constants\n\tprintln(\"separator:\", separator)\n\tprintln(\"newline:\", newline)\n\tprintln(\"space:\", space)\n\n\t// Use them in comparisons to ensure they're actually numbers\n\tif separator == '/' {\n\t\tprintln(\"separator matches '/'\")\n\t}\n\tif newline == '\\n' {\n\t\tprintln(\"newline matches '\\\\n'\")\n\t}\n\tif space == ' ' {\n\t\tprintln(\"space matches ' '\")\n\t}\n\n\t// Test arithmetic operations (only works with numbers)\n\tprintln(\"separator + 1:\", separator+1)\n\tprintln(\"space - 1:\", space-1)\n}\n",
    "tsCode": "// Generated file based on rune_const_import.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as subpkg from \"@goscript/github.com/aperturerobotics/goscript/tests/tests/rune_const_import/subpkg/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test importing rune constants from another package\n\tlet separator: number = subpkg.Separator\n\tlet newline: number = subpkg.Newline\n\tlet space: number = subpkg.Space\n\n\t// Print the imported rune constants\n\t$.println(\"separator:\", 47)\n\t$.println(\"newline:\", 10)\n\t$.println(\"space:\", 32)\n\n\t// Use them in comparisons to ensure they're actually numbers\n\tif (47 == 47) {\n\t\t$.println(\"separator matches '/'\")\n\t}\n\tif (10 == 10) {\n\t\t$.println(\"newline matches '\\\\n'\")\n\t}\n\tif (32 == 32) {\n\t\t$.println(\"space matches ' '\")\n\t}\n\n\t// Test arithmetic operations (only works with numbers)\n\t$.println(\"separator + 1:\", 47 + 1)\n\t$.println(\"space - 1:\", 32 - 1)\n}\n\n",
    "expectedOutput": "separator: 47\nnewline: 10\nspace: 32\nseparator matches '/'\nnewline matches '\\n'\nspace matches ' '\nseparator + 1: 48\nspace - 1: 31\n"
  },
  {
    "name": "rune_const_reference",
    "goCode": "package main\n\nimport \"github.com/aperturerobotics/goscript/tests/tests/rune_const_reference/subpkg\"\n\nfunc main() {\n\t// Test importing rune constants from another package\n\tconst separator = subpkg.Separator\n\tconst newline = subpkg.Newline\n\n\t// This should use the variable name instead of evaluating to numeric literal\n\tprintln(\"separator used in function:\", useInFunction(separator))\n\tprintln(\"newline used in function:\", useInFunction(newline))\n}\n\nfunc useInFunction(r rune) rune {\n\treturn r + 1\n}\n",
    "tsCode": "// Generated file based on rune_const_reference.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as subpkg from \"@goscript/github.com/aperturerobotics/goscript/tests/tests/rune_const_reference/subpkg/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test importing rune constants from another package\n\tlet separator: number = subpkg.Separator\n\tlet newline: number = subpkg.Newline\n\n\t// This should use the variable name instead of evaluating to numeric literal\n\t$.println(\"separator used in function:\", useInFunction(47))\n\t$.println(\"newline used in function:\", useInFunction(10))\n}\n\nexport function useInFunction(r: number): number {\n\treturn r + 1\n}\n\n",
    "expectedOutput": "separator used in function: 48\nnewline used in function: 11\n"
  },
  {
    "name": "select_mixed_returns",
    "goCode": "package main\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\nfunc testMixedReturns(ctx context.Context) string {\n\tch1 := make(chan string, 1)\n\tch2 := make(chan int, 1)\n\tch3 := make(chan bool, 1)\n\tch4 := make(chan float64, 1)\n\tch5 := make(chan []byte, 1)\n\n\t// Pre-populate only one channel to make the test deterministic\n\tch2 <- 42\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tprintln(\"Context done, returning\")\n\t\treturn \"context_done\"\n\tcase msg := <-ch1:\n\t\t// Case 1: Return with result\n\t\tprintln(\"Received from ch1:\", msg)\n\t\treturn \"ch1_result\"\n\tcase num := <-ch2:\n\t\t// Case 2: No return, just print and continue\n\t\tprintln(\"Received from ch2:\", num)\n\t\tprintln(\"Processing ch2 value...\")\n\tcase flag := <-ch3:\n\t\t// Case 3: Return with result\n\t\tprintln(\"Received from ch3:\", flag)\n\t\treturn \"ch3_result\"\n\tcase val := <-ch4:\n\t\t// Case 4: No return, just print and continue\n\t\tprintln(\"Received from ch4:\", val)\n\t\tprintln(\"Processing ch4 value...\")\n\tcase <-ch5:\n\t\t// Case 5: No return, just print and continue\n\t\tprintln(\"Received from ch5\")\n\t\tprintln(\"Processing ch5 data...\")\n\tdefault:\n\t\t// Default case: No return, just print and continue\n\t\tprintln(\"No channels ready, using default\")\n\t}\n\n\t// This code should execute when cases 2, 4, 5, or default are selected\n\tprintln(\"Continuing execution after select\")\n\tprintln(\"Performing additional work...\")\n\n\t// Simulate some work\n\ttime.Sleep(10 * time.Millisecond)\n\n\treturn \"completed_normally\"\n}\n\nfunc testReturnCase(ctx context.Context) string {\n\tch1 := make(chan string, 1)\n\tch2 := make(chan int, 1)\n\tch3 := make(chan bool, 1)\n\tch4 := make(chan float64, 1)\n\tch5 := make(chan []byte, 1)\n\n\t// Pre-populate ch1 to trigger a returning case\n\tch1 <- \"test_message\"\n\n\tselect {\n\tcase msg := <-ch1:\n\t\t// Case 1: Return with result\n\t\tprintln(\"Received from ch1:\", msg)\n\t\treturn \"ch1_result\"\n\tcase num := <-ch2:\n\t\t// Case 2: No return, just print and continue\n\t\tprintln(\"Received from ch2:\", num)\n\t\tprintln(\"Processing ch2 value...\")\n\tcase flag := <-ch3:\n\t\t// Case 3: Return with result\n\t\tprintln(\"Received from ch3:\", flag)\n\t\treturn \"ch3_result\"\n\tcase val := <-ch4:\n\t\t// Case 4: No return, just print and continue\n\t\tprintln(\"Received from ch4:\", val)\n\t\tprintln(\"Processing ch4 value...\")\n\tcase <-ch5:\n\t\t// Case 5: No return, just print and continue\n\t\tprintln(\"Received from ch5\")\n\t\tprintln(\"Processing ch5 data...\")\n\tdefault:\n\t\t// Default case: No return, just print and continue\n\t\tprintln(\"No channels ready, using default\")\n\t}\n\n\t// This code should NOT execute for ch1 case (which returns)\n\tprintln(\"Continuing execution after select\")\n\tprintln(\"Performing additional work...\")\n\n\t// Simulate some work\n\ttime.Sleep(10 * time.Millisecond)\n\n\treturn \"completed_normally\"\n}\n\nfunc main() {\n\tctx := context.Background()\n\n\tprintln(\"Test 1: Non-returning case (ch2)\")\n\tresult1 := testMixedReturns(ctx)\n\tprintln(\"Final result:\", result1)\n\n\tprintln()\n\tprintln(\"Test 2: Returning case (ch1)\")\n\tresult2 := testReturnCase(ctx)\n\tprintln(\"Final result:\", result2)\n\n\tprintln()\n\tprintln(\"All tests completed\")\n}\n",
    "tsCode": "// Generated file based on select_mixed_returns.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as context from \"@goscript/context/index.js\"\n\nimport * as time from \"@goscript/time/index.js\"\n\nexport async function testMixedReturns(ctx: null | context.Context): Promise<string> {\n\tlet ch1 = $.makeChannel<string>(1, \"\", 'both')\n\tlet ch2 = $.makeChannel<number>(1, 0, 'both')\n\tlet ch3 = $.makeChannel<boolean>(1, false, 'both')\n\tlet ch4 = $.makeChannel<number>(1, 0, 'both')\n\tlet ch5 = $.makeChannel<$.Bytes>(1, new Uint8Array(0), 'both')\n\n\t// Pre-populate only one channel to make the test deterministic\n\tawait $.chanSend(ch2, 42)\n\n\t// Case 1: Return with result\n\n\t// Case 2: No return, just print and continue\n\n\t// Case 3: Return with result\n\n\t// Case 4: No return, just print and continue\n\n\t// Case 5: No return, just print and continue\n\n\t// Default case: No return, just print and continue\n\tconst [_select_has_return_572f, _select_value_572f] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: ctx!.Done(),\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"Context done, returning\")\n\t\t\t\treturn \"context_done\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 1,\n\t\t\tisSend: false,\n\t\t\tchannel: ch1,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst msg = result.value\n\t\t\t\t$.println(\"Received from ch1:\", msg)\n\t\t\t\treturn \"ch1_result\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 2,\n\t\t\tisSend: false,\n\t\t\tchannel: ch2,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst num = result.value\n\t\t\t\t$.println(\"Received from ch2:\", num)\n\t\t\t\t$.println(\"Processing ch2 value...\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 3,\n\t\t\tisSend: false,\n\t\t\tchannel: ch3,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst flag = result.value\n\t\t\t\t$.println(\"Received from ch3:\", flag)\n\t\t\t\treturn \"ch3_result\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 4,\n\t\t\tisSend: false,\n\t\t\tchannel: ch4,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst val = result.value\n\t\t\t\t$.println(\"Received from ch4:\", val)\n\t\t\t\t$.println(\"Processing ch4 value...\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 5,\n\t\t\tisSend: false,\n\t\t\tchannel: ch5,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"Received from ch5\")\n\t\t\t\t$.println(\"Processing ch5 data...\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"No channels ready, using default\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_572f) {\n\t\treturn _select_value_572f!\n\t}\n\t// If _select_has_return_572f is false, continue execution\n\n\t// This code should execute when cases 2, 4, 5, or default are selected\n\t$.println(\"Continuing execution after select\")\n\t$.println(\"Performing additional work...\")\n\n\t// Simulate some work\n\tawait time.Sleep(10 * time.Millisecond)\n\n\treturn \"completed_normally\"\n}\n\nexport async function testReturnCase(ctx: null | context.Context): Promise<string> {\n\tlet ch1 = $.makeChannel<string>(1, \"\", 'both')\n\tlet ch2 = $.makeChannel<number>(1, 0, 'both')\n\tlet ch3 = $.makeChannel<boolean>(1, false, 'both')\n\tlet ch4 = $.makeChannel<number>(1, 0, 'both')\n\tlet ch5 = $.makeChannel<$.Bytes>(1, new Uint8Array(0), 'both')\n\n\t// Pre-populate ch1 to trigger a returning case\n\tawait $.chanSend(ch1, \"test_message\")\n\n\t// Case 1: Return with result\n\n\t// Case 2: No return, just print and continue\n\n\t// Case 3: Return with result\n\n\t// Case 4: No return, just print and continue\n\n\t// Case 5: No return, just print and continue\n\n\t// Default case: No return, just print and continue\n\tconst [_select_has_return_3d71, _select_value_3d71] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: ch1,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst msg = result.value\n\t\t\t\t$.println(\"Received from ch1:\", msg)\n\t\t\t\treturn \"ch1_result\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 1,\n\t\t\tisSend: false,\n\t\t\tchannel: ch2,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst num = result.value\n\t\t\t\t$.println(\"Received from ch2:\", num)\n\t\t\t\t$.println(\"Processing ch2 value...\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 2,\n\t\t\tisSend: false,\n\t\t\tchannel: ch3,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst flag = result.value\n\t\t\t\t$.println(\"Received from ch3:\", flag)\n\t\t\t\treturn \"ch3_result\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 3,\n\t\t\tisSend: false,\n\t\t\tchannel: ch4,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst val = result.value\n\t\t\t\t$.println(\"Received from ch4:\", val)\n\t\t\t\t$.println(\"Processing ch4 value...\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 4,\n\t\t\tisSend: false,\n\t\t\tchannel: ch5,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"Received from ch5\")\n\t\t\t\t$.println(\"Processing ch5 data...\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"No channels ready, using default\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_3d71) {\n\t\treturn _select_value_3d71!\n\t}\n\t// If _select_has_return_3d71 is false, continue execution\n\n\t// This code should NOT execute for ch1 case (which returns)\n\t$.println(\"Continuing execution after select\")\n\t$.println(\"Performing additional work...\")\n\n\t// Simulate some work\n\tawait time.Sleep(10 * time.Millisecond)\n\n\treturn \"completed_normally\"\n}\n\nexport async function main(): Promise<void> {\n\tlet ctx = context.Background()\n\n\t$.println(\"Test 1: Non-returning case (ch2)\")\n\tlet result1 = await testMixedReturns(ctx)\n\t$.println(\"Final result:\", result1)\n\n\t$.println()\n\t$.println(\"Test 2: Returning case (ch1)\")\n\tlet result2 = await testReturnCase(ctx)\n\t$.println(\"Final result:\", result2)\n\n\t$.println()\n\t$.println(\"All tests completed\")\n}\n\n",
    "expectedOutput": "Test 1: Non-returning case (ch2)\nReceived from ch2: 42\nProcessing ch2 value...\nContinuing execution after select\nPerforming additional work...\nFinal result: completed_normally\n\nTest 2: Returning case (ch1)\nReceived from ch1: test_message\nFinal result: ch1_result\n\nAll tests completed\n"
  },
  {
    "name": "select_receive_on_closed_channel_no_default",
    "goCode": "package main\n\nfunc main() {\n\tch := make(chan int) // Unbuffered\n\tclose(ch)\n\n\tselect { //nolint:staticcheck\n\tcase val, ok := <-ch:\n\t\tif ok {\n\t\t\tprintln(\"Received value with ok==true:\", val) // Should not be reached\n\t\t} else {\n\t\t\tprintln(\"Received zero value with ok==false:\", val) // Should be reached\n\t\t}\n\t}\n}\n",
    "tsCode": "// Generated file based on select_receive_on_closed_channel_no_default.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet ch = $.makeChannel<number>(0, 0, 'both') // Unbuffered\n\tch.close()\n\n\t//nolint:staticcheck\n\n\t// Should not be reached\n\n\t// Should be reached\n\tconst [_select_has_return_3efe, _select_value_3efe] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: ch,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst val = result.value\n\t\t\t\tconst ok = result.ok\n\t\t\t\tif (ok) {\n\t\t\t\t\t$.println(\"Received value with ok==true:\", val) // Should not be reached\n\t\t\t\t} else {\n\t\t\t\t\t$.println(\"Received zero value with ok==false:\", val) // Should be reached\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t], false)\n\tif (_select_has_return_3efe) {\n\t\treturn _select_value_3efe!\n\t}\n\t// If _select_has_return_3efe is false, continue execution\n}\n\n",
    "expectedOutput": "Received zero value with ok==false: 0"
  },
  {
    "name": "select_send_on_full_buffered_channel_with_default",
    "goCode": "package main\n\nfunc main() {\n\tch := make(chan int, 1)\n\tch <- 1 // Fill the buffer\n\n\t// TODO: The comments on the following cases are written twice in the output.\n\tselect {\n\tcase ch <- 2:\n\t\tprintln(\"Sent value\") // Should not be reached\n\tdefault:\n\t\tprintln(\"Default case hit\") // Should be reached\n\t}\n}\n",
    "tsCode": "// Generated file based on select_send_on_full_buffered_channel_with_default.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet ch = $.makeChannel<number>(1, 0, 'both')\n\tawait $.chanSend(ch, 1)\n\n\t// TODO: The comments on the following cases are written twice in the output.\n\n\t// Should not be reached\n\n\t// Should be reached\n\tconst [_select_has_return_5b5a, _select_value_5b5a] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: true,\n\t\t\tchannel: ch,\n\t\t\tvalue: 2,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"Sent value\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"Default case hit\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_5b5a) {\n\t\treturn _select_value_5b5a!\n\t}\n\t// If _select_has_return_5b5a is false, continue execution\n}\n\n",
    "expectedOutput": "Default case hit"
  },
  {
    "name": "select_statement",
    "goCode": "package main\n\nfunc main() {\n\t// Test 1: Simple deterministic select with default\n\t// Create a buffered channel so sends don't block\n\tch1 := make(chan string, 1)\n\n\t// First test: empty channel, should hit default\n\tselect {\n\tcase msg := <-ch1:\n\t\tprintln(\"TEST1: Received unexpected value:\", msg)\n\tdefault:\n\t\tprintln(\"TEST1: Default case hit correctly\")\n\t}\n\n\t// Now put something in the channel\n\tch1 <- \"hello\"\n\n\t// Second test: should read from channel\n\tselect {\n\tcase msg := <-ch1:\n\t\tprintln(\"TEST2: Received expected value:\", msg)\n\tdefault:\n\t\tprintln(\"TEST2: Default case hit unexpectedly\")\n\t}\n\n\t// Test 3: Select with channel closing and ok value\n\tch2 := make(chan int, 1)\n\tch2 <- 42\n\tclose(ch2)\n\n\t// First receive gets the buffered value\n\tselect {\n\tcase val, ok := <-ch2:\n\t\tif ok {\n\t\t\tprintln(\"TEST3: Received buffered value with ok==true:\", val)\n\t\t} else {\n\t\t\tprintln(\"TEST3: Unexpected ok==false\")\n\t\t}\n\tdefault:\n\t\tprintln(\"TEST3: Default hit unexpectedly\")\n\t}\n\n\t// Second receive gets the zero value with ok==false\n\tselect {\n\tcase val, ok := <-ch2:\n\t\tif ok {\n\t\t\tprintln(\"TEST4: Unexpected ok==true:\", val)\n\t\t} else {\n\t\t\tprintln(\"TEST4: Received zero value with ok==false:\", val)\n\t\t}\n\tdefault:\n\t\tprintln(\"TEST4: Default hit unexpectedly\")\n\t}\n\n\t// Test 5: Send operations\n\tch3 := make(chan int, 1)\n\n\t// First send should succeed (buffer not full)\n\tselect {\n\tcase ch3 <- 5:\n\t\tprintln(\"TEST5: Sent value successfully\")\n\tdefault:\n\t\tprintln(\"TEST5: Default hit unexpectedly\")\n\t}\n\n\t// Second send should hit default (buffer full)\n\tselect {\n\tcase ch3 <- 10:\n\t\tprintln(\"TEST6: Sent unexpectedly\")\n\tdefault:\n\t\tprintln(\"TEST6: Default hit correctly (channel full)\")\n\t}\n\n\t// Test 7: Multiple channel select (with known values)\n\tch4 := make(chan string, 1)\n\tch5 := make(chan string, 1)\n\n\tch4 <- \"from ch4\"\n\n\t// Should select ch4 because it has data, ch5 is empty\n\tselect {\n\tcase msg := <-ch4:\n\t\tprintln(\"TEST7: Selected ch4 correctly:\", msg)\n\tcase msg := <-ch5:\n\t\tprintln(\"TEST7: Selected ch5 unexpectedly:\", msg)\n\t}\n\n\t// Now ch4 is empty and ch5 is empty\n\tch5 <- \"from ch5\"\n\n\t// Should select ch5 because it has data, ch4 is empty\n\tselect {\n\tcase msg := <-ch4:\n\t\tprintln(\"TEST8: Selected ch4 unexpectedly:\", msg)\n\tcase msg := <-ch5:\n\t\tprintln(\"TEST8: Selected ch5 correctly:\", msg)\n\t}\n\n\t// Test 9: Channel closing test case for a separate test\n\tchClose := make(chan bool)\n\tclose(chClose)\n\tval, ok := <-chClose\n\tif !ok {\n\t\tprintln(\"TEST9: Channel is closed, ok is false, val:\", val)\n\t} else {\n\t\tprintln(\"TEST9: Channel reports as not closed\")\n\t}\n}\n",
    "tsCode": "// Generated file based on select_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test 1: Simple deterministic select with default\n\t// Create a buffered channel so sends don't block\n\tlet ch1 = $.makeChannel<string>(1, \"\", 'both')\n\n\t// First test: empty channel, should hit default\n\tconst [_select_has_return_286f, _select_value_286f] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: ch1,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst msg = result.value\n\t\t\t\t$.println(\"TEST1: Received unexpected value:\", msg)\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"TEST1: Default case hit correctly\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_286f) {\n\t\treturn _select_value_286f!\n\t}\n\t// If _select_has_return_286f is false, continue execution\n\n\t// Now put something in the channel\n\tawait $.chanSend(ch1, \"hello\")\n\n\t// Second test: should read from channel\n\tconst [_select_has_return_eaf0, _select_value_eaf0] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: ch1,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst msg = result.value\n\t\t\t\t$.println(\"TEST2: Received expected value:\", msg)\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"TEST2: Default case hit unexpectedly\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_eaf0) {\n\t\treturn _select_value_eaf0!\n\t}\n\t// If _select_has_return_eaf0 is false, continue execution\n\n\t// Test 3: Select with channel closing and ok value\n\tlet ch2 = $.makeChannel<number>(1, 0, 'both')\n\tawait $.chanSend(ch2, 42)\n\tch2.close()\n\n\t// First receive gets the buffered value\n\tconst [_select_has_return_4217, _select_value_4217] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: ch2,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst val = result.value\n\t\t\t\tconst ok = result.ok\n\t\t\t\tif (ok) {\n\t\t\t\t\t$.println(\"TEST3: Received buffered value with ok==true:\", val)\n\t\t\t\t} else {\n\t\t\t\t\t$.println(\"TEST3: Unexpected ok==false\")\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"TEST3: Default hit unexpectedly\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_4217) {\n\t\treturn _select_value_4217!\n\t}\n\t// If _select_has_return_4217 is false, continue execution\n\n\t// Second receive gets the zero value with ok==false\n\tconst [_select_has_return_3807, _select_value_3807] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: ch2,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst val = result.value\n\t\t\t\tconst ok = result.ok\n\t\t\t\tif (ok) {\n\t\t\t\t\t$.println(\"TEST4: Unexpected ok==true:\", val)\n\t\t\t\t} else {\n\t\t\t\t\t$.println(\"TEST4: Received zero value with ok==false:\", val)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"TEST4: Default hit unexpectedly\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_3807) {\n\t\treturn _select_value_3807!\n\t}\n\t// If _select_has_return_3807 is false, continue execution\n\n\t// Test 5: Send operations\n\tlet ch3 = $.makeChannel<number>(1, 0, 'both')\n\n\t// First send should succeed (buffer not full)\n\tconst [_select_has_return_7b82, _select_value_7b82] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: true,\n\t\t\tchannel: ch3,\n\t\t\tvalue: 5,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"TEST5: Sent value successfully\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"TEST5: Default hit unexpectedly\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_7b82) {\n\t\treturn _select_value_7b82!\n\t}\n\t// If _select_has_return_7b82 is false, continue execution\n\n\t// Second send should hit default (buffer full)\n\tconst [_select_has_return_c3e4, _select_value_c3e4] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: true,\n\t\t\tchannel: ch3,\n\t\t\tvalue: 10,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"TEST6: Sent unexpectedly\")\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: -1,\n\t\t\tisSend: false,\n\t\t\tchannel: null,\n\t\t\tonSelected: async (result) => {\n\t\t\t\t$.println(\"TEST6: Default hit correctly (channel full)\")\n\t\t\t}\n\t\t},\n\t], true)\n\tif (_select_has_return_c3e4) {\n\t\treturn _select_value_c3e4!\n\t}\n\t// If _select_has_return_c3e4 is false, continue execution\n\n\t// Test 7: Multiple channel select (with known values)\n\tlet ch4 = $.makeChannel<string>(1, \"\", 'both')\n\tlet ch5 = $.makeChannel<string>(1, \"\", 'both')\n\n\tawait $.chanSend(ch4, \"from ch4\")\n\n\t// Should select ch4 because it has data, ch5 is empty\n\tconst [_select_has_return_4cfd, _select_value_4cfd] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: ch4,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst msg = result.value\n\t\t\t\t$.println(\"TEST7: Selected ch4 correctly:\", msg)\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 1,\n\t\t\tisSend: false,\n\t\t\tchannel: ch5,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst msg = result.value\n\t\t\t\t$.println(\"TEST7: Selected ch5 unexpectedly:\", msg)\n\t\t\t}\n\t\t},\n\t], false)\n\tif (_select_has_return_4cfd) {\n\t\treturn _select_value_4cfd!\n\t}\n\t// If _select_has_return_4cfd is false, continue execution\n\n\t// Now ch4 is empty and ch5 is empty\n\tawait $.chanSend(ch5, \"from ch5\")\n\n\t// Should select ch5 because it has data, ch4 is empty\n\tconst [_select_has_return_5d67, _select_value_5d67] = await $.selectStatement([\n\t\t{\n\t\t\tid: 0,\n\t\t\tisSend: false,\n\t\t\tchannel: ch4,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst msg = result.value\n\t\t\t\t$.println(\"TEST8: Selected ch4 unexpectedly:\", msg)\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 1,\n\t\t\tisSend: false,\n\t\t\tchannel: ch5,\n\t\t\tonSelected: async (result) => {\n\t\t\t\tconst msg = result.value\n\t\t\t\t$.println(\"TEST8: Selected ch5 correctly:\", msg)\n\t\t\t}\n\t\t},\n\t], false)\n\tif (_select_has_return_5d67) {\n\t\treturn _select_value_5d67!\n\t}\n\t// If _select_has_return_5d67 is false, continue execution\n\n\t// Test 9: Channel closing test case for a separate test\n\tlet chClose = $.makeChannel<boolean>(0, false, 'both')\n\tchClose.close()\n\tconst { value: val, ok: ok } = await $.chanRecvWithOk(chClose)\n\tif (!ok) {\n\t\t$.println(\"TEST9: Channel is closed, ok is false, val:\", val)\n\t} else {\n\t\t$.println(\"TEST9: Channel reports as not closed\")\n\t}\n}\n\n",
    "expectedOutput": "TEST1: Default case hit correctly\nTEST2: Received expected value: hello\nTEST3: Received buffered value with ok==true: 42\nTEST4: Received zero value with ok==false: 0\nTEST5: Sent value successfully\nTEST6: Default hit correctly (channel full)\nTEST7: Selected ch4 correctly: from ch4\nTEST8: Selected ch5 correctly: from ch5\nTEST9: Channel is closed, ok is false, val: false"
  },
  {
    "name": "selective_exports",
    "goCode": "package main\n\nfunc main() {\n\tprintln(\"=== Selective Exports Test ===\")\n\n\t// Call exported function\n\tExportedFunc()\n\n\t// Call unexported function from same file\n\tunexportedFunc()\n\n\t// Call exported function from another file\n\tExportedFromUtils()\n\n\t// Call unexported function from another file (should work due to auto-imports)\n\tunexportedFromUtils()\n\n\tprintln(\"=== End Selective Exports Test ===\")\n}\n\n// ExportedFunc is exported (uppercase) - should appear in index.ts\nfunc ExportedFunc() {\n\tprintln(\"ExportedFunc called\")\n}\n\n// unexportedFunc is not exported (lowercase) - should NOT appear in index.ts\nfunc unexportedFunc() {\n\tprintln(\"unexportedFunc called\")\n}\n",
    "tsCode": "// Generated file based on selective_exports.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\nimport { ExportedFromUtils, unexportedFromUtils } from \"./utils.gs.js\";\n\nexport async function main(): Promise<void> {\n\t$.println(\"=== Selective Exports Test ===\")\n\n\t// Call exported function\n\tExportedFunc()\n\n\t// Call unexported function from same file\n\tunexportedFunc()\n\n\t// Call exported function from another file\n\tExportedFromUtils()\n\n\t// Call unexported function from another file (should work due to auto-imports)\n\tunexportedFromUtils()\n\n\t$.println(\"=== End Selective Exports Test ===\")\n}\n\n// ExportedFunc is exported (uppercase) - should appear in index.ts\nexport function ExportedFunc(): void {\n\t$.println(\"ExportedFunc called\")\n}\n\n// unexportedFunc is not exported (lowercase) - should NOT appear in index.ts\nexport function unexportedFunc(): void {\n\t$.println(\"unexportedFunc called\")\n}\n\n",
    "expectedOutput": "=== Selective Exports Test ===\nExportedFunc called\nunexportedFunc called\nExportedFromUtils called\nunexportedFromUtils called\n=== End Selective Exports Test === "
  },
  {
    "name": "selector_expr_lhs_multi_assign",
    "goCode": "package main\n\ntype Point struct {\n\tX int\n\tY int\n}\n\nfunc getCoords() (int, int) {\n\treturn 10, 20\n}\n\nfunc main() {\n\tvar p Point\n\t// p.X and p.Y are *ast.SelectorExpr\n\t// test writeMultiVarAssignFromCall in WriteStmtAssign\n\tp.X, p.Y = getCoords()\n\tprintln(p.X, p.Y)\n}\n",
    "tsCode": "// Generated file based on selector_expr_lhs_multi_assign.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Point {\n\tpublic get X(): number {\n\t\treturn this._fields.X.value\n\t}\n\tpublic set X(value: number) {\n\t\tthis._fields.X.value = value\n\t}\n\n\tpublic get Y(): number {\n\t\treturn this._fields.Y.value\n\t}\n\tpublic set Y(value: number) {\n\t\tthis._fields.Y.value = value\n\t}\n\n\tpublic _fields: {\n\t\tX: $.VarRef<number>;\n\t\tY: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{X?: number, Y?: number}>) {\n\t\tthis._fields = {\n\t\t\tX: $.varRef(init?.X ?? 0),\n\t\t\tY: $.varRef(init?.Y ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Point {\n\t\tconst cloned = new Point()\n\t\tcloned._fields = {\n\t\t\tX: $.varRef(this._fields.X.value),\n\t\t\tY: $.varRef(this._fields.Y.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Point',\n\t  new Point(),\n\t  [],\n\t  Point,\n\t  {\"X\": { kind: $.TypeKind.Basic, name: \"int\" }, \"Y\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport function getCoords(): [number, number] {\n\treturn [10, 20]\n}\n\nexport async function main(): Promise<void> {\n\tlet p: Point = new Point()\n\t// p.X and p.Y are *ast.SelectorExpr\n\t// test writeMultiVarAssignFromCall in WriteStmtAssign\n\t{\n\t  const _tmp = getCoords()\n\t  p.X = _tmp[0]\n\t  p.Y = _tmp[1]\n\t}\n\t$.println(p.X, p.Y)\n}\n\n",
    "expectedOutput": "10 20"
  },
  {
    "name": "selector_expr_ok_variable",
    "goCode": "package main\n\ntype Result struct {\n\tok bool\n}\n\nfunc main() {\n\tvar x interface{} = 42\n\tresult := Result{}\n\n\t// This should trigger the error: ok expression is not an identifier: *ast.SelectorExpr\n\t// The 'ok' variable is result.ok (a selector expression) instead of a simple identifier\n\t_, result.ok = x.(int)\n\n\tprintln(\"Type assertion successful:\", result.ok)\n}\n",
    "tsCode": "// Generated file based on selector_expr_ok_variable.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Result {\n\tpublic get ok(): boolean {\n\t\treturn this._fields.ok.value\n\t}\n\tpublic set ok(value: boolean) {\n\t\tthis._fields.ok.value = value\n\t}\n\n\tpublic _fields: {\n\t\tok: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{ok?: boolean}>) {\n\t\tthis._fields = {\n\t\t\tok: $.varRef(init?.ok ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Result {\n\t\tconst cloned = new Result()\n\t\tcloned._fields = {\n\t\t\tok: $.varRef(this._fields.ok.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Result',\n\t  new Result(),\n\t  [],\n\t  Result,\n\t  {\"ok\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet x: null | any = 42\n\tlet result = $.markAsStructValue(new Result({}))\n\n\t// This should trigger the error: ok expression is not an identifier: *ast.SelectorExpr\n\t// The 'ok' variable is result.ok (a selector expression) instead of a simple identifier\n\tlet _gs_ta_val_7689: number\n\tlet _gs_ta_ok_7689: boolean\n\t({ value: _gs_ta_val_7689, ok: _gs_ta_ok_7689 } = $.typeAssert<number>(x, {kind: $.TypeKind.Basic, name: 'number'}))\n\tresult.ok = _gs_ta_ok_7689\n\n\t$.println(\"Type assertion successful:\", result.ok)\n}\n\n",
    "expectedOutput": "Type assertion successful: true\n"
  },
  {
    "name": "simple",
    "goCode": "package main\n\nfunc main() {\n\tprintln(\"Hello world!\")\n}\n",
    "tsCode": "// Generated file based on simple.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t$.println(\"Hello world!\")\n}\n\n",
    "expectedOutput": "Hello world!"
  },
  {
    "name": "simple_deref_assignment",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\nfunc main() {\n\tstructPointer := &MyStruct{MyInt: 4, MyString: \"hello world\"}\n\t// === Simple Dereference Assignment (Value Copy) ===\n\tsimpleDereferencedCopy := *structPointer\n\t// Modifying the copy does not affect the original struct pointed to by structPointer.\n\tsimpleDereferencedCopy.MyString = \"modified dereferenced copy\"\n\t// Expected: \"hello world\"\n\tprintln(\"Original structPointer after modifying simpleDereferencedCopy: Expected: hello world, Actual: \" + structPointer.MyString)\n\t// Expected: \"modified dereferenced copy\"\n\tprintln(\"Simple Dereferenced Copy: Expected: modified dereferenced copy, Actual: \" + simpleDereferencedCopy.MyString)\n}\n",
    "tsCode": "// Generated file based on simple_deref_assignment.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet structPointer = new MyStruct({MyInt: 4, MyString: \"hello world\"})\n\t// === Simple Dereference Assignment (Value Copy) ===\n\tlet simpleDereferencedCopy = $.markAsStructValue(structPointer!.clone())\n\t// Modifying the copy does not affect the original struct pointed to by structPointer.\n\tsimpleDereferencedCopy.MyString = \"modified dereferenced copy\"\n\t// Expected: \"hello world\"\n\t$.println(\"Original structPointer after modifying simpleDereferencedCopy: Expected: hello world, Actual: \" + structPointer!.MyString)\n\t// Expected: \"modified dereferenced copy\"\n\t$.println(\"Simple Dereferenced Copy: Expected: modified dereferenced copy, Actual: \" + simpleDereferencedCopy.MyString)\n}\n\n",
    "expectedOutput": "Original structPointer after modifying simpleDereferencedCopy: Expected: hello world, Actual: hello world\nSimple Dereferenced Copy: Expected: modified dereferenced copy, Actual: modified dereferenced copy"
  },
  {
    "name": "simple_interface",
    "goCode": "package main\n\ntype MyStruct struct {\n\tValue int\n}\n\nfunc main() {\n\toriginal := MyStruct{Value: 30}\n\tpAlias := &original\n\n\tvar jAlias interface{} = pAlias\n\n\t_, ok := jAlias.(*MyStruct)\n\tprintln(\"pointer assertion result:\", ok)\n}\n",
    "tsCode": "// Generated file based on simple_interface.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet original = $.varRef($.markAsStructValue(new MyStruct({Value: 30})))\n\tlet pAlias = original\n\n\tlet jAlias: null | any = pAlias\n\n\tlet { ok: ok } = $.typeAssert<MyStruct | null>(jAlias, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"pointer assertion result:\", ok)\n}\n\n",
    "expectedOutput": "pointer assertion result: true\n"
  },
  {
    "name": "simple_pointer_assign",
    "goCode": "package main\n\nfunc main() {\n\t// Simple case that should work\n\tx := 10\n\tp1 := &x // p1 is *int, not varref'd\n\tp2 := p1 // p2 is *int, not varref'd, should copy p1\n\n\tprintln(\"p1==p2:\", p1 == p2) // Should be true\n\tprintln(\"*p1:\", *p1)         // Should be 10\n\tprintln(\"*p2:\", *p2)         // Should be 10\n}\n",
    "tsCode": "// Generated file based on simple_pointer_assign.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Simple case that should work\n\tlet x = $.varRef(10)\n\tlet p1 = x // p1 is *int, not varref'd\n\tlet p2 = p1 // p2 is *int, not varref'd, should copy p1\n\n\t$.println(\"p1==p2:\", (p1 === p2)) // Should be true\n\t$.println(\"*p1:\", p1!.value) // Should be 10\n\t$.println(\"*p2:\", p2!.value) // Should be 10\n}\n\n",
    "expectedOutput": "p1==p2: true\n*p1: 10\n*p2: 10\n"
  },
  {
    "name": "slice",
    "goCode": "package main\n\nfunc main() {\n\t// --- Original Tests ---\n\tprintln(\"--- Original Tests ---\")\n\t// Create a slice of integers with length 5 and capacity 10\n\ts := make([]int, 5, 10)\n\tprintln(len(s)) // 5\n\tprintln(cap(s)) // 10\n\n\t// Create a slice of strings with length 3\n\ts2 := make([]string, 3)\n\tprintln(len(s2)) // 3\n\tprintln(cap(s2)) // 3\n\n\t// Assign values\n\ts[0] = 10\n\ts[4] = 20\n\ts2[1] = \"hello\"\n\n\tprintln(s[0])  // 10\n\tprintln(s[4])  // 20\n\tprintln(s2[1]) // hello\n\n\t// --- New Tests ---\n\tprintln(\"--- New Tests ---\")\n\n\t// Create slice from array literal\n\tarrLit := [5]int{1, 2, 3, 4, 5}\n\tsliceFromLit := arrLit[:]\n\tprintln(len(sliceFromLit)) // 5\n\tprintln(cap(sliceFromLit)) // 5\n\tprintln(sliceFromLit[0])   // 1\n\tprintln(sliceFromLit[4])   // 5\n\n\t// Create slice from array variable\n\tarrVar := [4]string{\"a\", \"b\", \"c\", \"d\"}\n\tsliceFromVar := arrVar[:]\n\tprintln(len(sliceFromVar)) // 4\n\tprintln(cap(sliceFromVar)) // 4\n\tprintln(sliceFromVar[0])   // a\n\tprintln(sliceFromVar[3])   // d\n\n\t// Create slice with specific indices\n\tsliceIndices := arrVar[1:3] // [\"b\", \"c\"]\n\tprintln(len(sliceIndices))  // 2\n\tprintln(cap(sliceIndices))  // 3 (cap is from start index to end of original array)\n\tprintln(sliceIndices[0])    // b\n\tprintln(sliceIndices[1])    // c\n\n\t// Create slice with 0 len/cap and append\n\tprintln(\"--- Zero len/cap append ---\")\n\tzeroSlice := make([]int, 0, 0)\n\tprintln(len(zeroSlice)) // 0\n\tprintln(cap(zeroSlice)) // 0\n\tzeroSlice = append(zeroSlice, 100)\n\tprintln(len(zeroSlice)) // 1\n\tprintln(cap(zeroSlice)) // 1 (or more, implementation dependent)\n\tprintln(zeroSlice[0])   // 100\n\tzeroSlice = append(zeroSlice, 200)\n\tprintln(len(zeroSlice)) // 2\n\tprintln(cap(zeroSlice)) // 2 (or more)\n\tprintln(zeroSlice[1])   // 200\n\n\t// Modify slice, check original array\n\tprintln(\"--- Modify slice, check array ---\")\n\tmodArr := [3]int{10, 20, 30}\n\tmodSlice := modArr[:]\n\tmodSlice[1] = 25     // Modify slice\n\tprintln(modArr[1])   // 25 (original array should be modified)\n\tprintln(modSlice[1]) // 25\n\n\t// Modify array, check slice\n\tprintln(\"--- Modify array, check slice ---\")\n\tmodArr[0] = 15       // Modify array\n\tprintln(modArr[0])   // 15\n\tprintln(modSlice[0]) // 15 (slice should reflect change)\n\n\t// Append to sub-slice within capacity\n\tprintln(\"--- Append sub-slice w/in capacity ---\")\n\tappendArr := [5]int{1, 2, 3, 4, 5}\n\tappendSlice1 := appendArr[0:2]           // len 2, cap 5; [1, 2]\n\tprintln(len(appendSlice1))               // 2\n\tprintln(cap(appendSlice1))               // 5\n\tappendSlice2 := append(appendSlice1, 99) // Appends within original capacity\n\tprintln(len(appendSlice2))               // 3\n\tprintln(cap(appendSlice2))               // 5\n\tprintln(appendSlice2[2])                 // 99\n\tprintln(appendArr[2])                    // 99 (original array modified)\n\n\t// Append to sub-slice exceeding capacity\n\tprintln(\"--- Append sub-slice exceed capacity ---\")\n\tappendSlice3 := appendArr[3:5]            // len 2, cap 2; [4, 5]\n\tprintln(len(appendSlice3))                // 2\n\tprintln(cap(appendSlice3))                // 2\n\tappendSlice4 := append(appendSlice3, 101) // Appends beyond original capacity\n\tprintln(len(appendSlice4))                // 3\n\tprintln(cap(appendSlice4))                // 4 (or more, new underlying array)\n\tprintln(appendSlice4[0])                  // 4\n\tprintln(appendSlice4[1])                  // 5\n\tprintln(appendSlice4[2])                  // 101\n\t// Original array should NOT be modified beyond its bounds by this append\n\tprintln(appendArr[0]) // 1\n\tprintln(appendArr[1]) // 2\n\tprintln(appendArr[2]) // 99 (from previous append)\n\tprintln(appendArr[3]) // 4\n\tprintln(appendArr[4]) // 5\n\n\t// Slicing a slice\n\tprintln(\"--- Slicing a slice ---\")\n\tbaseSlice := []int{0, 10, 20, 30, 40, 50}\n\tsubSlice1 := baseSlice[1:4] // [10, 20, 30], len 3, cap 5\n\tprintln(len(subSlice1))     // 3\n\tprintln(cap(subSlice1))     // 5\n\tprintln(subSlice1[0])       // 10\n\tsubSlice2 := subSlice1[1:3] // [20, 30], len 2, cap 4 (cap from subSlice1's start)\n\tprintln(len(subSlice2))     // 2\n\tprintln(cap(subSlice2))     // 4\n\tprintln(subSlice2[0])       // 20\n\tprintln(subSlice2[1])       // 30\n\tsubSlice2[0] = 22           // Modify sub-sub-slice\n\tprintln(subSlice1[1])       // 22 (subSlice1 modified)\n\tprintln(baseSlice[2])       // 22 (baseSlice modified)\n\n\t// Three-index slicing (if supported) - Check capacity\n\tprintln(\"--- Three-index slicing ---\")\n\tthreeIndexArr := [6]int{0, 1, 2, 3, 4, 5}\n\tthreeIndexSlice := threeIndexArr[1:3:4] // [1, 2], len 2, cap 3 (4-1)\n\tprintln(len(threeIndexSlice))           // 2\n\tprintln(cap(threeIndexSlice))           // 3\n\tprintln(threeIndexSlice[0])             // 1\n\tprintln(threeIndexSlice[1])             // 2\n\t// Appending should modify original array up to new capacity limit\n\tthreeIndexSlice = append(threeIndexSlice, 99)\n\tprintln(len(threeIndexSlice)) // 3\n\tprintln(cap(threeIndexSlice)) // 3\n\tprintln(threeIndexSlice[2])   // 99\n\tprintln(threeIndexArr[3])     // 99 (original modified)\n\t// Appending again should reallocate\n\tthreeIndexSlice = append(threeIndexSlice, 101)\n\tprintln(len(threeIndexSlice)) // 4\n\tprintln(cap(threeIndexSlice)) // 6 (or more)\n\tprintln(threeIndexSlice[3])   // 101\n\tprintln(threeIndexArr[4])     // 4 (original NOT modified by reallocating append)\n\n\t// --- Additional Tests for Full Coverage ---\n\tprintln(\"--- Additional Tests ---\")\n\n\t// Slice literal\n\tsliceLiteral := []int{10, 20, 30}\n\tprintln(\"Slice literal len:\", len(sliceLiteral)) // 3\n\tprintln(\"Slice literal cap:\", cap(sliceLiteral)) // 3\n\tprintln(\"Slice literal[1]:\", sliceLiteral[1])    // 20\n\n\t// Nil slice\n\tvar nilSlice []int\n\tprintln(\"Nil slice len:\", len(nilSlice)) // 0\n\tprintln(\"Nil slice cap:\", cap(nilSlice)) // 0\n\tnilSlice = append(nilSlice, 5)\n\tprintln(\"Append to nil slice len:\", len(nilSlice)) // 1\n\tprintln(\"Append to nil slice cap:\", cap(nilSlice)) // 1 (or more)\n\tprintln(\"Append to nil slice[0]:\", nilSlice[0])    // 5\n\n\t// Out-of-bounds indexing (should panic)\n\t// Note: Testing panics in compliance tests requires specific handling in the test runner.\n\t// For now, we'll add the code but expect it to fail if panics are not caught.\n\t// The runner should ideally catch these panics and verify the error type/message.\n\n\t// println(\"--- Testing out-of-bounds panic ---\")\n\t// smallSlice := []int{1}\n\t// println(smallSlice[1]) // Index out of bounds (len 1, cap 1) - should panic\n\t// smallSlice[1] = 10     // Index out of bounds - should panic\n\t// println(smallSlice[-1]) // Negative index - should panic\n\n\t// --- Slices of Slices Tests ---\n\tprintln(\"--- Slices of Slices Tests ---\")\n\n\t// Create a slice of slices of integers\n\tsliceOfSlices := [][]int{\n\t\t{1, 2, 3},\n\t\t{4, 5},\n\t\t{6, 7, 8, 9},\n\t}\n\n\tprintln(\"Length of sliceOfSlices:\", len(sliceOfSlices))   // 3\n\tprintln(\"Capacity of sliceOfSlices:\", cap(sliceOfSlices)) // 3\n\n\t// Access elements\n\tprintln(\"sliceOfSlices[0][1]:\", sliceOfSlices[0][1]) // 2\n\tprintln(\"sliceOfSlices[1][0]:\", sliceOfSlices[1][0]) // 4\n\tprintln(\"sliceOfSlices[2][3]:\", sliceOfSlices[2][3]) // 9\n\n\t// Append to inner slice (should modify the inner slice)\n\tprintln(\"--- Append to inner slice ---\")\n\tinnerSlice := sliceOfSlices[1]                      // {4, 5}, len 2, cap 2\n\tprintln(\"Length of innerSlice:\", len(innerSlice))   // 2\n\tprintln(\"Capacity of innerSlice:\", cap(innerSlice)) // 2\n\n\tinnerSlice = append(innerSlice, 50)                              // {4, 5, 50}\n\tprintln(\"Length of innerSlice after append:\", len(innerSlice))   // 3\n\tprintln(\"Capacity of innerSlice after append:\", cap(innerSlice)) // 4 (or more)\n\tprintln(\"innerSlice[2]:\", innerSlice[2])                         // 50\n\n\t// Check if the original slice of slices reflects the change (it should, as innerSlice is a view)\n\t// Note: Appending to innerSlice might reallocate its underlying array if capacity is exceeded.\n\t// If reallocated, the original sliceOfSlices will *not* see the change at that index.\n\t// This test case specifically checks the scenario where the append happens within the original capacity\n\t// or if the reallocation behavior is correctly handled by GoScript.\n\t// For this simple case, appending 50 to {4, 5} will likely cause reallocation.\n\t// Let's test appending within capacity first.\n\n\t// Create a slice of slices where inner slice has capacity for append\n\tsliceOfSlicesWithCap := [][]int{\n\t\t{1, 2, 3},\n\t\tmake([]int, 2, 5), // {0, 0}, len 2, cap 5\n\t\t{6, 7, 8, 9},\n\t}\n\tsliceOfSlicesWithCap[1][0] = 40\n\tsliceOfSlicesWithCap[1][1] = 50\n\n\tprintln(\"--- Append to inner slice with capacity ---\")\n\tinnerSliceWithCap := sliceOfSlicesWithCap[1]                      // {40, 50}, len 2, cap 5\n\tprintln(\"Length of innerSliceWithCap:\", len(innerSliceWithCap))   // 2\n\tprintln(\"Capacity of innerSliceWithCap:\", cap(innerSliceWithCap)) // 5\n\n\tinnerSliceWithCap = append(innerSliceWithCap, 60)                              // {40, 50, 60}\n\tprintln(\"Length of innerSliceWithCap after append:\", len(innerSliceWithCap))   // 3\n\tprintln(\"Capacity of innerSliceWithCap after append:\", cap(innerSliceWithCap)) // 5\n\tprintln(\"innerSliceWithCap[2]:\", innerSliceWithCap[2])                         // 60\n\n\t// Check if the original slice of slices reflects the change (it should, as append was within capacity)\n\tprintln(\"sliceOfSlicesWithCap[1][2]:\", sliceOfSlicesWithCap[1][:3][2]) // 60\n\n\t// Append to inner slice exceeding capacity\n\tprintln(\"--- Append to inner slice exceeding capacity ---\")\n\tinnerSliceExceedCap := sliceOfSlices[0]                               // {1, 2, 3}, len 3, cap 3\n\tprintln(\"Length of innerSliceExceedCap:\", len(innerSliceExceedCap))   // 3\n\tprintln(\"Capacity of innerSliceExceedCap:\", cap(innerSliceExceedCap)) // 3\n\n\tinnerSliceExceedCap = append(innerSliceExceedCap, 10, 20)                          // {1, 2, 3, 10, 20} - will reallocate\n\tprintln(\"Length of innerSliceExceedCap after append:\", len(innerSliceExceedCap))   // 5\n\tprintln(\"Capacity of innerSliceExceedCap after append:\", cap(innerSliceExceedCap)) // 6 (or more)\n\tprintln(\"innerSliceExceedCap[3]:\", innerSliceExceedCap[3])                         // 10\n\tprintln(\"innerSliceExceedCap[4]:\", innerSliceExceedCap[4])                         // 20\n\n\t// Check if the original slice of slices reflects the change (it should NOT, due to reallocation)\n\t// The original sliceOfSlices[0] should still be {1, 2, 3}\n\tprintln(\"Original sliceOfSlices[0] after inner append:\", sliceOfSlices[0][0], sliceOfSlices[0][1], sliceOfSlices[0][2]) // 1 2 3\n\n\t// Slicing a slice of slices\n\tprintln(\"--- Slicing a slice of slices ---\")\n\tsubSliceOfSlices := sliceOfSlices[1:3]                          // {{4, 5}, {6, 7, 8, 9}}, len 2, cap 2\n\tprintln(\"Length of subSliceOfSlices:\", len(subSliceOfSlices))   // 2\n\tprintln(\"Capacity of subSliceOfSlices:\", cap(subSliceOfSlices)) // 2\n\tprintln(\"subSliceOfSlices[0][0]:\", subSliceOfSlices[0][0])      // 4\n\tprintln(\"subSliceOfSlices[1][2]:\", subSliceOfSlices[1][2])      // 8\n\n\t// Modify element in sub-slice of slices (should affect original)\n\tprintln(\"--- Modify element in sub-slice of slices ---\")\n\tsubSliceOfSlices[0][1] = 55\n\tprintln(\"sliceOfSlices[1][1] after sub-slice modification:\", sliceOfSlices[1][1]) // 55\n\n\t// Append a new slice to the slice of slices\n\tprintln(\"--- Append a new slice to slice of slices ---\")\n\tsliceOfSlices = append(sliceOfSlices, []int{100, 110})\n\tprintln(\"Length of sliceOfSlices after append:\", len(sliceOfSlices))   // 4\n\tprintln(\"Capacity of sliceOfSlices after append:\", cap(sliceOfSlices)) // 6 (or more)\n\tprintln(\"sliceOfSlices[3][0]:\", sliceOfSlices[3][0])                   // 100\n\n\t// Append an existing slice to the slice of slices\n\tprintln(\"--- Append an existing slice to slice of slices ---\")\n\texistingSlice := []int{200, 210}\n\tsliceOfSlices = append(sliceOfSlices, existingSlice)\n\tprintln(\"Length of sliceOfSlices after appending existing:\", len(sliceOfSlices))   // 5\n\tprintln(\"Capacity of sliceOfSlices after appending existing:\", cap(sliceOfSlices)) // 6 (or more)\n\tprintln(\"sliceOfSlices[4][1]:\", sliceOfSlices[4][1])                               // 210\n\n\t// Modify the appended existing slice (should NOT affect the slice in sliceOfSlices if it was copied)\n\t// Go's append copies the slice header, but the underlying array is shared unless reallocation occurs.\n\t// Modifying existingSlice *after* appending it should not affect the copy in sliceOfSlices\n\t// unless they still share the underlying array and the modification is within the shared capacity.\n\t// Let's test this carefully.\n\tprintln(\"--- Modify appended existing slice ---\")\n\texistingSlice[0] = 205\n\tprintln(\"sliceOfSlices[4][0] after modifying existingSlice:\", sliceOfSlices[4][0]) // Should still be 200 if copied or shared but not modified at index 0\n\n\t// If we modify an element in the slice within sliceOfSlices, it *should* affect the original existingSlice\n\t// if they share the underlying array.\n\tprintln(\"--- Modify slice within sliceOfSlices ---\")\n\tsliceOfSlices[4][1] = 215\n\tprintln(\"existingSlice[1] after modifying slice within sliceOfSlices:\", existingSlice[1]) // Should be 215\n\n\t// Create a slice of slices using make\n\tprintln(\"--- Make slice of slices ---\")\n\tmakeSliceOfSlices := make([][]int, 2, 4)                          // len 2, cap 4\n\tprintln(\"Length of makeSliceOfSlices:\", len(makeSliceOfSlices))   // 2\n\tprintln(\"Capacity of makeSliceOfSlices:\", cap(makeSliceOfSlices)) // 4\n\n\t// Initialize inner slices\n\tmakeSliceOfSlices[0] = []int{1000, 2000}\n\tmakeSliceOfSlices[1] = make([]int, 1, 3)\n\tmakeSliceOfSlices[1][0] = 3000\n\n\tprintln(\"makeSliceOfSlices[0][1]:\", makeSliceOfSlices[0][1]) // 2000\n\tprintln(\"makeSliceOfSlices[1][0]:\", makeSliceOfSlices[1][0]) // 3000\n\n\t// Append a new inner slice\n\tmakeSliceOfSlices = append(makeSliceOfSlices, []int{4000, 5000})\n\tprintln(\"Length of makeSliceOfSlices after append:\", len(makeSliceOfSlices))   // 3\n\tprintln(\"Capacity of makeSliceOfSlices after append:\", cap(makeSliceOfSlices)) // 4\n\tprintln(\"makeSliceOfSlices[2][1]:\", makeSliceOfSlices[2][1])                   // 5000\n\n\t// Append another new inner slice (should exceed capacity and reallocate outer slice)\n\tmakeSliceOfSlices = append(makeSliceOfSlices, []int{6000})\n\tprintln(\"Length of makeSliceOfSlices after second append:\", len(makeSliceOfSlices))   // 4\n\tprintln(\"Capacity of makeSliceOfSlices after second append:\", cap(makeSliceOfSlices)) // 8 (or more)\n\tprintln(\"makeSliceOfSlices[3][0]:\", makeSliceOfSlices[3][0])                          // 6000\n\n\t// Nil slice of slices\n\tprintln(\"--- Nil slice of slices ---\")\n\tvar nilSliceOfSlices [][]int\n\tprintln(\"Nil slice of slices len:\", len(nilSliceOfSlices)) // 0\n\tprintln(\"Nil slice of slices cap:\", cap(nilSliceOfSlices)) // 0\n\n\t// Append to nil slice of slices\n\tnilSliceOfSlices = append(nilSliceOfSlices, []int{10000})\n\tprintln(\"Length of nilSliceOfSlices after append:\", len(nilSliceOfSlices))   // 1\n\tprintln(\"Capacity of nilSliceOfSlices after append:\", cap(nilSliceOfSlices)) // 1 (or more)\n\tprintln(\"nilSliceOfSlices[0][0]:\", nilSliceOfSlices[0][0])                   // 10000\n\n\t// Append another slice to the nil slice of slices\n\tnilSliceOfSlices = append(nilSliceOfSlices, []int{20000, 30000})\n\tprintln(\"Length of nilSliceOfSlices after second append:\", len(nilSliceOfSlices))   // 2\n\tprintln(\"Capacity of nilSliceOfSlices after second append:\", cap(nilSliceOfSlices)) // 2 (or more)\n\tprintln(\"nilSliceOfSlices[1][1]:\", nilSliceOfSlices[1][1])                          // 30000\n\n\t// Empty slice of slices (not nil)\n\tprintln(\"--- Empty slice of slices ---\")\n\temptySliceOfSlices := make([][]int, 0)\n\tprintln(\"Empty slice of slices len:\", len(emptySliceOfSlices)) // 0\n\tprintln(\"Empty slice of slices cap:\", cap(emptySliceOfSlices)) // 0 (or more, implementation dependent)\n\n\t// Append to empty slice of slices\n\temptySliceOfSlices = append(emptySliceOfSlices, []int{40000})\n\tprintln(\"Length of emptySliceOfSlices after append:\", len(emptySliceOfSlices))   // 1\n\tprintln(\"Capacity of emptySliceOfSlices after append:\", cap(emptySliceOfSlices)) // 1 (or more)\n\tprintln(\"emptySliceOfSlices[0][0]:\", emptySliceOfSlices[0][0])                   // 40000\n}\n",
    "tsCode": "// Generated file based on slice.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// --- Original Tests ---\n\t$.println(\"--- Original Tests ---\")\n\t// Create a slice of integers with length 5 and capacity 10\n\tlet s = $.makeSlice<number>(5, 10, 'number')\n\t$.println($.len(s)) // 5\n\t$.println($.cap(s)) // 10\n\n\t// Create a slice of strings with length 3\n\tlet s2 = $.makeSlice<string>(3, undefined, 'string')\n\t$.println($.len(s2)) // 3\n\t$.println($.cap(s2)) // 3\n\n\t// Assign values\n\ts![0] = 10\n\ts![4] = 20\n\ts2![1] = \"hello\"\n\n\t$.println(s![0]) // 10\n\t$.println(s![4]) // 20\n\t$.println(s2![1]) // hello\n\n\t// --- New Tests ---\n\t$.println(\"--- New Tests ---\")\n\n\t// Create slice from array literal\n\tlet arrLit = $.arrayToSlice<number>([1, 2, 3, 4, 5])\n\tlet sliceFromLit = $.goSlice(arrLit, undefined, undefined)\n\t$.println($.len(sliceFromLit)) // 5\n\t$.println($.cap(sliceFromLit)) // 5\n\t$.println(sliceFromLit![0]) // 1\n\t$.println(sliceFromLit![4]) // 5\n\n\t// Create slice from array variable\n\tlet arrVar = $.arrayToSlice<string>([\"a\", \"b\", \"c\", \"d\"])\n\tlet sliceFromVar = $.goSlice(arrVar, undefined, undefined)\n\t$.println($.len(sliceFromVar)) // 4\n\t$.println($.cap(sliceFromVar)) // 4\n\t$.println(sliceFromVar![0]) // a\n\t$.println(sliceFromVar![3]) // d\n\n\t// Create slice with specific indices\n\tlet sliceIndices = $.goSlice(arrVar, 1, 3) // [\"b\", \"c\"]\n\t$.println($.len(sliceIndices)) // 2\n\t$.println($.cap(sliceIndices)) // 3 (cap is from start index to end of original array)\n\t$.println(sliceIndices![0]) // b\n\t$.println(sliceIndices![1]) // c\n\n\t// Create slice with 0 len/cap and append\n\t$.println(\"--- Zero len/cap append ---\")\n\tlet zeroSlice = $.makeSlice<number>(0, 0, 'number')\n\t$.println($.len(zeroSlice)) // 0\n\t$.println($.cap(zeroSlice)) // 0\n\tzeroSlice = $.append(zeroSlice, 100)\n\t$.println($.len(zeroSlice)) // 1\n\t$.println($.cap(zeroSlice)) // 1 (or more, implementation dependent)\n\t$.println(zeroSlice![0]) // 100\n\tzeroSlice = $.append(zeroSlice, 200)\n\t$.println($.len(zeroSlice)) // 2\n\t$.println($.cap(zeroSlice)) // 2 (or more)\n\t$.println(zeroSlice![1]) // 200\n\n\t// Modify slice, check original array\n\t$.println(\"--- Modify slice, check array ---\")\n\tlet modArr = $.arrayToSlice<number>([10, 20, 30])\n\tlet modSlice = $.goSlice(modArr, undefined, undefined)\n\tmodSlice![1] = 25 // Modify slice\n\t$.println(modArr![1]) // 25 (original array should be modified)\n\t$.println(modSlice![1]) // 25\n\n\t// Modify array, check slice\n\t$.println(\"--- Modify array, check slice ---\")\n\tmodArr![0] = 15 // Modify array\n\t$.println(modArr![0]) // 15\n\t$.println(modSlice![0]) // 15 (slice should reflect change)\n\n\t// Append to sub-slice within capacity\n\t$.println(\"--- Append sub-slice w/in capacity ---\")\n\tlet appendArr = $.arrayToSlice<number>([1, 2, 3, 4, 5])\n\tlet appendSlice1 = $.goSlice(appendArr, 0, 2) // len 2, cap 5; [1, 2]\n\t$.println($.len(appendSlice1)) // 2\n\t$.println($.cap(appendSlice1)) // 5\n\tlet appendSlice2 = $.append(appendSlice1, 99) // Appends within original capacity\n\t$.println($.len(appendSlice2)) // 3\n\t$.println($.cap(appendSlice2)) // 5\n\t$.println(appendSlice2![2]) // 99\n\t$.println(appendArr![2]) // 99 (original array modified)\n\n\t// Append to sub-slice exceeding capacity\n\t$.println(\"--- Append sub-slice exceed capacity ---\")\n\tlet appendSlice3 = $.goSlice(appendArr, 3, 5) // len 2, cap 2; [4, 5]\n\t$.println($.len(appendSlice3)) // 2\n\t$.println($.cap(appendSlice3)) // 2\n\tlet appendSlice4 = $.append(appendSlice3, 101) // Appends beyond original capacity\n\t$.println($.len(appendSlice4)) // 3\n\t$.println($.cap(appendSlice4)) // 4 (or more, new underlying array)\n\t$.println(appendSlice4![0]) // 4\n\t$.println(appendSlice4![1]) // 5\n\t$.println(appendSlice4![2]) // 101\n\t// Original array should NOT be modified beyond its bounds by this append\n\t$.println(appendArr![0]) // 1\n\t$.println(appendArr![1]) // 2\n\t$.println(appendArr![2]) // 99 (from previous append)\n\t$.println(appendArr![3]) // 4\n\t$.println(appendArr![4]) // 5\n\n\t// Slicing a slice\n\t$.println(\"--- Slicing a slice ---\")\n\tlet baseSlice = $.arrayToSlice<number>([0, 10, 20, 30, 40, 50])\n\tlet subSlice1 = $.goSlice(baseSlice, 1, 4) // [10, 20, 30], len 3, cap 5\n\t$.println($.len(subSlice1)) // 3\n\t$.println($.cap(subSlice1)) // 5\n\t$.println(subSlice1![0]) // 10\n\tlet subSlice2 = $.goSlice(subSlice1, 1, 3) // [20, 30], len 2, cap 4 (cap from subSlice1's start)\n\t$.println($.len(subSlice2)) // 2\n\t$.println($.cap(subSlice2)) // 4\n\t$.println(subSlice2![0]) // 20\n\t$.println(subSlice2![1]) // 30\n\tsubSlice2![0] = 22 // Modify sub-sub-slice\n\t$.println(subSlice1![1]) // 22 (subSlice1 modified)\n\t$.println(baseSlice![2]) // 22 (baseSlice modified)\n\n\t// Three-index slicing (if supported) - Check capacity\n\t$.println(\"--- Three-index slicing ---\")\n\tlet threeIndexArr = $.arrayToSlice<number>([0, 1, 2, 3, 4, 5])\n\tlet threeIndexSlice = $.goSlice(threeIndexArr, 1, 3, 4) // [1, 2], len 2, cap 3 (4-1)\n\t$.println($.len(threeIndexSlice)) // 2\n\t$.println($.cap(threeIndexSlice)) // 3\n\t$.println(threeIndexSlice![0]) // 1\n\t$.println(threeIndexSlice![1]) // 2\n\t// Appending should modify original array up to new capacity limit\n\tthreeIndexSlice = $.append(threeIndexSlice, 99)\n\t$.println($.len(threeIndexSlice)) // 3\n\t$.println($.cap(threeIndexSlice)) // 3\n\t$.println(threeIndexSlice![2]) // 99\n\t$.println(threeIndexArr![3]) // 99 (original modified)\n\t// Appending again should reallocate\n\tthreeIndexSlice = $.append(threeIndexSlice, 101)\n\t$.println($.len(threeIndexSlice)) // 4\n\t$.println($.cap(threeIndexSlice)) // 6 (or more)\n\t$.println(threeIndexSlice![3]) // 101\n\t$.println(threeIndexArr![4]) // 4 (original NOT modified by reallocating append)\n\n\t// --- Additional Tests for Full Coverage ---\n\t$.println(\"--- Additional Tests ---\")\n\n\t// Slice literal\n\tlet sliceLiteral = $.arrayToSlice<number>([10, 20, 30])\n\t$.println(\"Slice literal len:\", $.len(sliceLiteral)) // 3\n\t$.println(\"Slice literal cap:\", $.cap(sliceLiteral)) // 3\n\t$.println(\"Slice literal[1]:\", sliceLiteral![1]) // 20\n\n\t// Nil slice\n\tlet nilSlice: $.Slice<number> = null\n\t$.println(\"Nil slice len:\", $.len(nilSlice)) // 0\n\t$.println(\"Nil slice cap:\", $.cap(nilSlice)) // 0\n\tnilSlice = $.append(nilSlice, 5)\n\t$.println(\"Append to nil slice len:\", $.len(nilSlice)) // 1\n\t$.println(\"Append to nil slice cap:\", $.cap(nilSlice)) // 1 (or more)\n\t$.println(\"Append to nil slice[0]:\", nilSlice![0]) // 5\n\n\t// Out-of-bounds indexing (should panic)\n\t// Note: Testing panics in compliance tests requires specific handling in the test runner.\n\t// For now, we'll add the code but expect it to fail if panics are not caught.\n\t// The runner should ideally catch these panics and verify the error type/message.\n\n\t// println(\"--- Testing out-of-bounds panic ---\")\n\t// smallSlice := []int{1}\n\t// println(smallSlice[1]) // Index out of bounds (len 1, cap 1) - should panic\n\t// smallSlice[1] = 10     // Index out of bounds - should panic\n\t// println(smallSlice[-1]) // Negative index - should panic\n\n\t// --- Slices of Slices Tests ---\n\t$.println(\"--- Slices of Slices Tests ---\")\n\n\t// Create a slice of slices of integers\n\tlet sliceOfSlices = $.arrayToSlice<$.Slice<number>>([[ 1, 2, 3 ], [ 4, 5 ], [ 6, 7, 8, 9 ]], 2)\n\n\t$.println(\"Length of sliceOfSlices:\", $.len(sliceOfSlices)) // 3\n\t$.println(\"Capacity of sliceOfSlices:\", $.cap(sliceOfSlices)) // 3\n\n\t// Access elements\n\t$.println(\"sliceOfSlices[0][1]:\", sliceOfSlices![0]![1]) // 2\n\t$.println(\"sliceOfSlices[1][0]:\", sliceOfSlices![1]![0]) // 4\n\t$.println(\"sliceOfSlices[2][3]:\", sliceOfSlices![2]![3]) // 9\n\n\t// Append to inner slice (should modify the inner slice)\n\t$.println(\"--- Append to inner slice ---\")\n\tlet innerSlice = sliceOfSlices![1] // {4, 5}, len 2, cap 2\n\t$.println(\"Length of innerSlice:\", $.len(innerSlice)) // 2\n\t$.println(\"Capacity of innerSlice:\", $.cap(innerSlice)) // 2\n\n\tinnerSlice = $.append(innerSlice, 50) // {4, 5, 50}\n\t$.println(\"Length of innerSlice after append:\", $.len(innerSlice)) // 3\n\t$.println(\"Capacity of innerSlice after append:\", $.cap(innerSlice)) // 4 (or more)\n\t$.println(\"innerSlice[2]:\", innerSlice![2]) // 50\n\n\t// Check if the original slice of slices reflects the change (it should, as innerSlice is a view)\n\t// Note: Appending to innerSlice might reallocate its underlying array if capacity is exceeded.\n\t// If reallocated, the original sliceOfSlices will *not* see the change at that index.\n\t// This test case specifically checks the scenario where the append happens within the original capacity\n\t// or if the reallocation behavior is correctly handled by GoScript.\n\t// For this simple case, appending 50 to {4, 5} will likely cause reallocation.\n\t// Let's test appending within capacity first.\n\n\t// Create a slice of slices where inner slice has capacity for append\n\n\t// {0, 0}, len 2, cap 5\n\tlet sliceOfSlicesWithCap = $.arrayToSlice<$.Slice<number>>([[ 1, 2, 3 ], $.makeSlice<number>(2, 5, 'number'), [ 6, 7, 8, 9 ]], 2)\n\tsliceOfSlicesWithCap![1]![0] = 40\n\tsliceOfSlicesWithCap![1]![1] = 50\n\n\t$.println(\"--- Append to inner slice with capacity ---\")\n\tlet innerSliceWithCap = sliceOfSlicesWithCap![1] // {40, 50}, len 2, cap 5\n\t$.println(\"Length of innerSliceWithCap:\", $.len(innerSliceWithCap)) // 2\n\t$.println(\"Capacity of innerSliceWithCap:\", $.cap(innerSliceWithCap)) // 5\n\n\tinnerSliceWithCap = $.append(innerSliceWithCap, 60) // {40, 50, 60}\n\t$.println(\"Length of innerSliceWithCap after append:\", $.len(innerSliceWithCap)) // 3\n\t$.println(\"Capacity of innerSliceWithCap after append:\", $.cap(innerSliceWithCap)) // 5\n\t$.println(\"innerSliceWithCap[2]:\", innerSliceWithCap![2]) // 60\n\n\t// Check if the original slice of slices reflects the change (it should, as append was within capacity)\n\t$.println(\"sliceOfSlicesWithCap[1][2]:\", $.goSlice(sliceOfSlicesWithCap![1], undefined, 3)![2]) // 60\n\n\t// Append to inner slice exceeding capacity\n\t$.println(\"--- Append to inner slice exceeding capacity ---\")\n\tlet innerSliceExceedCap = sliceOfSlices![0] // {1, 2, 3}, len 3, cap 3\n\t$.println(\"Length of innerSliceExceedCap:\", $.len(innerSliceExceedCap)) // 3\n\t$.println(\"Capacity of innerSliceExceedCap:\", $.cap(innerSliceExceedCap)) // 3\n\n\tinnerSliceExceedCap = $.append(innerSliceExceedCap, 10, 20) // {1, 2, 3, 10, 20} - will reallocate\n\t$.println(\"Length of innerSliceExceedCap after append:\", $.len(innerSliceExceedCap)) // 5\n\t$.println(\"Capacity of innerSliceExceedCap after append:\", $.cap(innerSliceExceedCap)) // 6 (or more)\n\t$.println(\"innerSliceExceedCap[3]:\", innerSliceExceedCap![3]) // 10\n\t$.println(\"innerSliceExceedCap[4]:\", innerSliceExceedCap![4]) // 20\n\n\t// Check if the original slice of slices reflects the change (it should NOT, due to reallocation)\n\t// The original sliceOfSlices[0] should still be {1, 2, 3}\n\t$.println(\"Original sliceOfSlices[0] after inner append:\", sliceOfSlices![0]![0], sliceOfSlices![0]![1], sliceOfSlices![0]![2]) // 1 2 3\n\n\t// Slicing a slice of slices\n\t$.println(\"--- Slicing a slice of slices ---\")\n\tlet subSliceOfSlices = $.goSlice(sliceOfSlices, 1, 3) // {{4, 5}, {6, 7, 8, 9}}, len 2, cap 2\n\t$.println(\"Length of subSliceOfSlices:\", $.len(subSliceOfSlices)) // 2\n\t$.println(\"Capacity of subSliceOfSlices:\", $.cap(subSliceOfSlices)) // 2\n\t$.println(\"subSliceOfSlices[0][0]:\", subSliceOfSlices![0]![0]) // 4\n\t$.println(\"subSliceOfSlices[1][2]:\", subSliceOfSlices![1]![2]) // 8\n\n\t// Modify element in sub-slice of slices (should affect original)\n\t$.println(\"--- Modify element in sub-slice of slices ---\")\n\tsubSliceOfSlices![0]![1] = 55\n\t$.println(\"sliceOfSlices[1][1] after sub-slice modification:\", sliceOfSlices![1]![1]) // 55\n\n\t// Append a new slice to the slice of slices\n\t$.println(\"--- Append a new slice to slice of slices ---\")\n\tsliceOfSlices = $.append(sliceOfSlices, $.arrayToSlice<number>([100, 110]))\n\t$.println(\"Length of sliceOfSlices after append:\", $.len(sliceOfSlices)) // 4\n\t$.println(\"Capacity of sliceOfSlices after append:\", $.cap(sliceOfSlices)) // 6 (or more)\n\t$.println(\"sliceOfSlices[3][0]:\", sliceOfSlices![3]![0]) // 100\n\n\t// Append an existing slice to the slice of slices\n\t$.println(\"--- Append an existing slice to slice of slices ---\")\n\tlet existingSlice = $.arrayToSlice<number>([200, 210])\n\tsliceOfSlices = $.append(sliceOfSlices, existingSlice)\n\t$.println(\"Length of sliceOfSlices after appending existing:\", $.len(sliceOfSlices)) // 5\n\t$.println(\"Capacity of sliceOfSlices after appending existing:\", $.cap(sliceOfSlices)) // 6 (or more)\n\t$.println(\"sliceOfSlices[4][1]:\", sliceOfSlices![4]![1]) // 210\n\n\t// Modify the appended existing slice (should NOT affect the slice in sliceOfSlices if it was copied)\n\t// Go's append copies the slice header, but the underlying array is shared unless reallocation occurs.\n\t// Modifying existingSlice *after* appending it should not affect the copy in sliceOfSlices\n\t// unless they still share the underlying array and the modification is within the shared capacity.\n\t// Let's test this carefully.\n\t$.println(\"--- Modify appended existing slice ---\")\n\texistingSlice![0] = 205\n\t$.println(\"sliceOfSlices[4][0] after modifying existingSlice:\", sliceOfSlices![4]![0]) // Should still be 200 if copied or shared but not modified at index 0\n\n\t// If we modify an element in the slice within sliceOfSlices, it *should* affect the original existingSlice\n\t// if they share the underlying array.\n\t$.println(\"--- Modify slice within sliceOfSlices ---\")\n\tsliceOfSlices![4]![1] = 215\n\t$.println(\"existingSlice[1] after modifying slice within sliceOfSlices:\", existingSlice![1]) // Should be 215\n\n\t// Create a slice of slices using make\n\t$.println(\"--- Make slice of slices ---\")\n\tlet makeSliceOfSlices = $.makeSlice<$.Slice<number>>(2, 4) // len 2, cap 4\n\t$.println(\"Length of makeSliceOfSlices:\", $.len(makeSliceOfSlices)) // 2\n\t$.println(\"Capacity of makeSliceOfSlices:\", $.cap(makeSliceOfSlices)) // 4\n\n\t// Initialize inner slices\n\tmakeSliceOfSlices![0] = $.arrayToSlice<number>([1000, 2000])\n\tmakeSliceOfSlices![1] = $.makeSlice<number>(1, 3, 'number')\n\tmakeSliceOfSlices![1]![0] = 3000\n\n\t$.println(\"makeSliceOfSlices[0][1]:\", makeSliceOfSlices![0]![1]) // 2000\n\t$.println(\"makeSliceOfSlices[1][0]:\", makeSliceOfSlices![1]![0]) // 3000\n\n\t// Append a new inner slice\n\tmakeSliceOfSlices = $.append(makeSliceOfSlices, $.arrayToSlice<number>([4000, 5000]))\n\t$.println(\"Length of makeSliceOfSlices after append:\", $.len(makeSliceOfSlices)) // 3\n\t$.println(\"Capacity of makeSliceOfSlices after append:\", $.cap(makeSliceOfSlices)) // 4\n\t$.println(\"makeSliceOfSlices[2][1]:\", makeSliceOfSlices![2]![1]) // 5000\n\n\t// Append another new inner slice (should exceed capacity and reallocate outer slice)\n\tmakeSliceOfSlices = $.append(makeSliceOfSlices, $.arrayToSlice<number>([6000]))\n\t$.println(\"Length of makeSliceOfSlices after second append:\", $.len(makeSliceOfSlices)) // 4\n\t$.println(\"Capacity of makeSliceOfSlices after second append:\", $.cap(makeSliceOfSlices)) // 8 (or more)\n\t$.println(\"makeSliceOfSlices[3][0]:\", makeSliceOfSlices![3]![0]) // 6000\n\n\t// Nil slice of slices\n\t$.println(\"--- Nil slice of slices ---\")\n\tlet nilSliceOfSlices: $.Slice<$.Slice<number>> = null\n\t$.println(\"Nil slice of slices len:\", $.len(nilSliceOfSlices)) // 0\n\t$.println(\"Nil slice of slices cap:\", $.cap(nilSliceOfSlices)) // 0\n\n\t// Append to nil slice of slices\n\tnilSliceOfSlices = $.append(nilSliceOfSlices, $.arrayToSlice<number>([10000]))\n\t$.println(\"Length of nilSliceOfSlices after append:\", $.len(nilSliceOfSlices)) // 1\n\t$.println(\"Capacity of nilSliceOfSlices after append:\", $.cap(nilSliceOfSlices)) // 1 (or more)\n\t$.println(\"nilSliceOfSlices[0][0]:\", nilSliceOfSlices![0]![0]) // 10000\n\n\t// Append another slice to the nil slice of slices\n\tnilSliceOfSlices = $.append(nilSliceOfSlices, $.arrayToSlice<number>([20000, 30000]))\n\t$.println(\"Length of nilSliceOfSlices after second append:\", $.len(nilSliceOfSlices)) // 2\n\t$.println(\"Capacity of nilSliceOfSlices after second append:\", $.cap(nilSliceOfSlices)) // 2 (or more)\n\t$.println(\"nilSliceOfSlices[1][1]:\", nilSliceOfSlices![1]![1]) // 30000\n\n\t// Empty slice of slices (not nil)\n\t$.println(\"--- Empty slice of slices ---\")\n\tlet emptySliceOfSlices = $.makeSlice<$.Slice<number>>(0)\n\t$.println(\"Empty slice of slices len:\", $.len(emptySliceOfSlices)) // 0\n\t$.println(\"Empty slice of slices cap:\", $.cap(emptySliceOfSlices)) // 0 (or more, implementation dependent)\n\n\t// Append to empty slice of slices\n\temptySliceOfSlices = $.append(emptySliceOfSlices, $.arrayToSlice<number>([40000]))\n\t$.println(\"Length of emptySliceOfSlices after append:\", $.len(emptySliceOfSlices)) // 1\n\t$.println(\"Capacity of emptySliceOfSlices after append:\", $.cap(emptySliceOfSlices)) // 1 (or more)\n\t$.println(\"emptySliceOfSlices[0][0]:\", emptySliceOfSlices![0]![0]) // 40000\n}\n\n",
    "expectedOutput": "--- Original Tests ---\n5\n10\n3\n3\n10\n20\nhello\n--- New Tests ---\n5\n5\n1\n5\n4\n4\na\nd\n2\n3\nb\nc\n--- Zero len/cap append ---\n0\n0\n1\n1\n100\n2\n2\n200\n--- Modify slice, check array ---\n25\n25\n--- Modify array, check slice ---\n15\n15\n--- Append sub-slice w/in capacity ---\n2\n5\n3\n5\n99\n99\n--- Append sub-slice exceed capacity ---\n2\n2\n3\n4\n4\n5\n101\n1\n2\n99\n4\n5\n--- Slicing a slice ---\n3\n5\n10\n2\n4\n20\n30\n22\n22\n--- Three-index slicing ---\n2\n3\n1\n2\n3\n3\n99\n99\n4\n6\n101\n4\n--- Additional Tests ---\nSlice literal len: 3\nSlice literal cap: 3\nSlice literal[1]: 20\nNil slice len: 0\nNil slice cap: 0\nAppend to nil slice len: 1\nAppend to nil slice cap: 1\nAppend to nil slice[0]: 5\n--- Slices of Slices Tests ---\nLength of sliceOfSlices: 3\nCapacity of sliceOfSlices: 3\nsliceOfSlices[0][1]: 2\nsliceOfSlices[1][0]: 4\nsliceOfSlices[2][3]: 9\n--- Append to inner slice ---\nLength of innerSlice: 2\nCapacity of innerSlice: 2\nLength of innerSlice after append: 3\nCapacity of innerSlice after append: 4\ninnerSlice[2]: 50\n--- Append to inner slice with capacity ---\nLength of innerSliceWithCap: 2\nCapacity of innerSliceWithCap: 5\nLength of innerSliceWithCap after append: 3\nCapacity of innerSliceWithCap after append: 5\ninnerSliceWithCap[2]: 60\nsliceOfSlicesWithCap[1][2]: 60\n--- Append to inner slice exceeding capacity ---\nLength of innerSliceExceedCap: 3\nCapacity of innerSliceExceedCap: 3\nLength of innerSliceExceedCap after append: 5\nCapacity of innerSliceExceedCap after append: 6\ninnerSliceExceedCap[3]: 10\ninnerSliceExceedCap[4]: 20\nOriginal sliceOfSlices[0] after inner append: 1 2 3\n--- Slicing a slice of slices ---\nLength of subSliceOfSlices: 2\nCapacity of subSliceOfSlices: 2\nsubSliceOfSlices[0][0]: 4\nsubSliceOfSlices[1][2]: 8\n--- Modify element in sub-slice of slices ---\nsliceOfSlices[1][1] after sub-slice modification: 55\n--- Append a new slice to slice of slices ---\nLength of sliceOfSlices after append: 4\nCapacity of sliceOfSlices after append: 6\nsliceOfSlices[3][0]: 100\n--- Append an existing slice to slice of slices ---\nLength of sliceOfSlices after appending existing: 5\nCapacity of sliceOfSlices after appending existing: 6\nsliceOfSlices[4][1]: 210\n--- Modify appended existing slice ---\nsliceOfSlices[4][0] after modifying existingSlice: 205\n--- Modify slice within sliceOfSlices ---\nexistingSlice[1] after modifying slice within sliceOfSlices: 215\n--- Make slice of slices ---\nLength of makeSliceOfSlices: 2\nCapacity of makeSliceOfSlices: 4\nmakeSliceOfSlices[0][1]: 2000\nmakeSliceOfSlices[1][0]: 3000\nLength of makeSliceOfSlices after append: 3\nCapacity of makeSliceOfSlices after append: 4\nmakeSliceOfSlices[2][1]: 5000\nLength of makeSliceOfSlices after second append: 4\nCapacity of makeSliceOfSlices after second append: 4\nmakeSliceOfSlices[3][0]: 6000\n--- Nil slice of slices ---\nNil slice of slices len: 0\nNil slice of slices cap: 0\nLength of nilSliceOfSlices after append: 1\nCapacity of nilSliceOfSlices after append: 1\nnilSliceOfSlices[0][0]: 10000\nLength of nilSliceOfSlices after second append: 2\nCapacity of nilSliceOfSlices after second append: 2\nnilSliceOfSlices[1][1]: 30000\n--- Empty slice of slices ---\nEmpty slice of slices len: 0\nEmpty slice of slices cap: 0\nLength of emptySliceOfSlices after append: 1\nCapacity of emptySliceOfSlices after append: 1\nemptySliceOfSlices[0][0]: 40000"
  },
  {
    "name": "slice_nil",
    "goCode": "package main\n\nfunc main() {\n\tvar s []int\n\tprintln(\"s == nil:\", s == nil)\n\n\t// Slicing nil with valid bounds should work\n\ts2 := s[0:0]\n\tprintln(\"s[0:0] == nil:\", s2 == nil)\n\n\ts3 := s[:0]\n\tprintln(\"s[:0] == nil:\", s3 == nil)\n\n\ts4 := s[:]\n\tprintln(\"s[:] == nil:\", s4 == nil)\n\n\tprintln(\"slice_nil test passed\")\n}\n",
    "tsCode": "// Generated file based on slice_nil.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet s: $.Slice<number> = null\n\t$.println(\"s == nil:\", s == null)\n\n\t// Slicing nil with valid bounds should work\n\tlet s2 = $.goSlice(s, 0, 0)\n\t$.println(\"s[0:0] == nil:\", s2 == null)\n\n\tlet s3 = $.goSlice(s, undefined, 0)\n\t$.println(\"s[:0] == nil:\", s3 == null)\n\n\tlet s4 = $.goSlice(s, undefined, undefined)\n\t$.println(\"s[:] == nil:\", s4 == null)\n\n\t$.println(\"slice_nil test passed\")\n}\n\n",
    "expectedOutput": "s == nil: true\ns[0:0] == nil: true\ns[:0] == nil: true\ns[:] == nil: true\nslice_nil test passed\n"
  },
  {
    "name": "slices_grow",
    "goCode": "package main\n\nimport \"slices\"\n\nfunc main() {\n\ts := []int{1, 2, 3}\n\tprintln(\"Before Grow: len=\", len(s), \"cap=\", cap(s))\n\ts = slices.Grow(s, 5)\n\tprintln(\"After Grow: len=\", len(s), \"cap=\", cap(s))\n\tprintln(\"slices.Grow test finished\")\n}\n",
    "tsCode": "// Generated file based on slices_grow.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as slices from \"@goscript/slices/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet s = $.arrayToSlice<number>([1, 2, 3])\n\t$.println(\"Before Grow: len=\", $.len(s), \"cap=\", $.cap(s))\n\ts = slices.Grow(s, 5)\n\t$.println(\"After Grow: len=\", $.len(s), \"cap=\", $.cap(s))\n\t$.println(\"slices.Grow test finished\")\n}\n\n",
    "expectedOutput": "Before Grow: len= 3 cap= 3\nAfter Grow: len= 3 cap= 8\nslices.Grow test finished\n"
  },
  {
    "name": "slices_sortfunc",
    "goCode": "package main\n\nimport \"slices\"\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc main() {\n\tpeople := []Person{\n\t\t{Name: \"Charlie\", Age: 30},\n\t\t{Name: \"Alice\", Age: 25},\n\t\t{Name: \"Bob\", Age: 35},\n\t}\n\n\tslices.SortFunc(people, func(a, b Person) int {\n\t\tif a.Age < b.Age {\n\t\t\treturn -1\n\t\t}\n\t\tif a.Age > b.Age {\n\t\t\treturn 1\n\t\t}\n\t\treturn 0\n\t})\n\n\tfor _, p := range people {\n\t\tprintln(p.Name, p.Age)\n\t}\n}\n",
    "tsCode": "// Generated file based on slices_sortfunc.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as slices from \"@goscript/slices/index.js\"\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [],\n\t  Person,\n\t  {\"Name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"Age\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet people = $.arrayToSlice<Person>([$.markAsStructValue(new Person({Age: 30, Name: \"Charlie\"})), $.markAsStructValue(new Person({Age: 25, Name: \"Alice\"})), $.markAsStructValue(new Person({Age: 35, Name: \"Bob\"}))])\n\n\tslices.SortFunc(people, (a: Person, b: Person): number => {\n\t\tif (a.Age < b.Age) {\n\t\t\treturn -1\n\t\t}\n\t\tif (a.Age > b.Age) {\n\t\t\treturn 1\n\t\t}\n\t\treturn 0\n\t})\n\n\tfor (let _i = 0; _i < $.len(people); _i++) {\n\t\tlet p = people![_i]\n\t\t{\n\t\t\t$.println(p.Name, p.Age)\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Alice 25\nCharlie 30\nBob 35\n"
  },
  {
    "name": "slices_sortfunc_nil",
    "goCode": "package main\n\nimport \"slices\"\n\ntype field struct {\n\tname string\n}\n\nfunc main() {\n\tvar fields []field\n\tprintln(\"fields before:\", fields)\n\n\tslices.SortFunc(fields, func(a, b field) int {\n\t\tif a.name < b.name {\n\t\t\treturn -1\n\t\t}\n\t\tif a.name > b.name {\n\t\t\treturn 1\n\t\t}\n\t\treturn 0\n\t})\n\n\tprintln(\"fields after:\", fields)\n}\n",
    "tsCode": "// Generated file based on slices_sortfunc_nil.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as slices from \"@goscript/slices/index.js\"\n\nexport class field {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic _fields: {\n\t\tname: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{name?: string}>) {\n\t\tthis._fields = {\n\t\t\tname: $.varRef(init?.name ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): field {\n\t\tconst cloned = new field()\n\t\tcloned._fields = {\n\t\t\tname: $.varRef(this._fields.name.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.field',\n\t  new field(),\n\t  [],\n\t  field,\n\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet fields: $.Slice<field> = null\n\t$.println(\"fields before:\", fields)\n\n\tslices.SortFunc(fields, (a: field, b: field): number => {\n\t\tif (a.name < b.name) {\n\t\t\treturn -1\n\t\t}\n\t\tif (a.name > b.name) {\n\t\t\treturn 1\n\t\t}\n\t\treturn 0\n\t})\n\n\t$.println(\"fields after:\", fields)\n}\n\n",
    "expectedOutput": "fields before: null\nfields after: null\n"
  },
  {
    "name": "star_compound_assign",
    "goCode": "package main\n\nfunc main() {\n\tvar x int = 2\n\tvar p *int = &x\n\n\t*p += 3\n\tprintln(x) // Expected: 5\n\n\t*p &^= 1\n\t// 5 (0101) &^ 1 (0001) = 4 (0100)\n\tprintln(x) // Expected: 4\n}\n",
    "tsCode": "// Generated file based on star_compound_assign.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet x: $.VarRef<number> = $.varRef(2)\n\tlet p: $.VarRef<number> | null = x\n\n\tp!.value += 3\n\t$.println(x!.value) // Expected: 5\n\n\tp!.value &= ~(1)\n\t// 5 (0101) &^ 1 (0001) = 4 (0100)\n\t$.println(x!.value) // Expected: 4\n}\n\n",
    "expectedOutput": "5\n4\n"
  },
  {
    "name": "star_expr_destructuring",
    "goCode": "package main\n\nfunc returnTwoValues() (int, string) {\n\treturn 42, \"hello\"\n}\n\nfunc main() {\n\tvar a int = 0\n\tvar b string = \"\"\n\n\t// Create pointers - these will be properly varrefed\n\tvar pA *int = &a\n\tvar pB *string = &b\n\n\t// This should trigger the \"unhandled LHS expression in destructuring: *ast.StarExpr\" error\n\t*pA, *pB = returnTwoValues()\n\n\tprintln(\"a:\", a)\n\tprintln(\"b:\", b)\n}\n",
    "tsCode": "// Generated file based on star_expr_destructuring.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function returnTwoValues(): [number, string] {\n\treturn [42, \"hello\"]\n}\n\nexport async function main(): Promise<void> {\n\tlet a: $.VarRef<number> = $.varRef(0)\n\tlet b: $.VarRef<string> = $.varRef(\"\")\n\n\t// Create pointers - these will be properly varrefed\n\tlet pA: $.VarRef<number> | null = a\n\tlet pB: $.VarRef<string> | null = b\n\n\t// This should trigger the \"unhandled LHS expression in destructuring: *ast.StarExpr\" error\n\t{\n\t  const _tmp = returnTwoValues()\n\t  pA!.value = _tmp[0]\n\t  pB!.value = _tmp[1]\n\t}\n\n\t$.println(\"a:\", a!.value)\n\t$.println(\"b:\", b!.value)\n}\n\n",
    "expectedOutput": "a: 42\nb: hello\n"
  },
  {
    "name": "string_conversion",
    "goCode": "package main\n\nfunc main() {\n\t// === string(string) Conversion ===\n\tmyVar := string(\"hello world\")\n\tprintln(myVar)\n\n\t// === string(rune) Conversion ===\n\tr := 'A'\n\ts := string(r)\n\tprintln(s)\n\n\tvar r2 rune = 97 // 'a'\n\ts2 := string(r2)\n\tprintln(s2)\n\n\tvar r3 rune = 0x20AC // ''\n\ts3 := string(r3)\n\tprintln(s3)\n\n\t// === string([]rune) Conversion ===\n\tmyRunes := []rune{'G', 'o', 'S', 'c', 'r', 'i', 'p', 't'}\n\tmyStringFromRunes := string(myRunes)\n\tprintln(myStringFromRunes)\n\n\temptyRunes := []rune{}\n\temptyStringFromRunes := string(emptyRunes)\n\tprintln(emptyStringFromRunes)\n\n\t// === []rune(string) and string([]rune) Round Trip ===\n\toriginalString := \"\" // Example with multi-byte characters\n\trunesFromString := []rune(originalString)\n\tstringFromRunes := string(runesFromString)\n\tprintln(originalString)\n\tprintln(stringFromRunes)\n\tprintln(originalString == stringFromRunes)\n\n\t// === Modify []rune and convert back to string ===\n\tmutableRunes := []rune(\"Mutable String\")\n\tmutableRunes[0] = 'm'\n\tmutableRunes[8] = 's'\n\tmodifiedString := string(mutableRunes)\n\tprintln(modifiedString)\n\n\t// === Test cases that might trigger \"unhandled string conversion\" ===\n\n\t// string([]byte) conversion\n\tbytes := []byte{72, 101, 108, 108, 111}\n\tbytesString := string(bytes)\n\tprintln(bytesString)\n\n\t// string(int32) conversion\n\ti32 := int32(66)\n\ti32String := string(i32)\n\tprintln(i32String)\n\n\t// Test with interface{} type assertion\n\tvar v interface{} = \"interface test\"\n\tinterfaceString := string(v.(string))\n\tprintln(interfaceString)\n\n\t// Test with type conversion through variable\n\tvar myString string = \"variable test\"\n\tconvertedString := string(myString)\n\tprintln(convertedString)\n\n\t// === Test string(byte) conversion ===\n\tvar b byte = 65\n\tbyteString := string(b)\n\tprintln(byteString)\n}\n",
    "tsCode": "// Generated file based on string_conversion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// === string(string) Conversion ===\n\tlet myVar = \"hello world\"\n\t$.println(myVar)\n\n\t// === string(rune) Conversion ===\n\tlet r = 65\n\tlet s = $.runeOrStringToString(r)\n\t$.println(s)\n\n\t// 'a'\n\tlet r2: number = 97\n\tlet s2 = $.runeOrStringToString(r2)\n\t$.println(s2)\n\n\t// ''\n\tlet r3: number = 0x20AC\n\tlet s3 = $.runeOrStringToString(r3)\n\t$.println(s3)\n\n\t// === string([]rune) Conversion ===\n\tlet myRunes = $.arrayToSlice<number>([71, 111, 83, 99, 114, 105, 112, 116])\n\tlet myStringFromRunes = $.runesToString(myRunes)\n\t$.println(myStringFromRunes)\n\n\tlet emptyRunes = $.arrayToSlice<number>([])\n\tlet emptyStringFromRunes = $.runesToString(emptyRunes)\n\t$.println(emptyStringFromRunes)\n\n\t// === []rune(string) and string([]rune) Round Trip ===\n\tlet originalString = \"\" // Example with multi-byte characters\n\tlet runesFromString = $.stringToRunes(originalString)\n\tlet stringFromRunes = $.runesToString(runesFromString)\n\t$.println(originalString)\n\t$.println(stringFromRunes)\n\t$.println(originalString == stringFromRunes)\n\n\t// === Modify []rune and convert back to string ===\n\tlet mutableRunes = $.stringToRunes(\"Mutable String\")\n\tmutableRunes![0] = 109\n\tmutableRunes![8] = 115\n\tlet modifiedString = $.runesToString(mutableRunes)\n\t$.println(modifiedString)\n\n\t// === Test cases that might trigger \"unhandled string conversion\" ===\n\n\t// string([]byte) conversion\n\tlet bytes = new Uint8Array([72, 101, 108, 108, 111])\n\tlet bytesString = $.bytesToString(bytes)\n\t$.println(bytesString)\n\n\t// string(int32) conversion\n\tlet i32 = (66 as number)\n\tlet i32String = $.runeOrStringToString(i32)\n\t$.println(i32String)\n\n\t// Test with interface{} type assertion\n\tlet v: null | any = \"interface test\"\n\tlet interfaceString = $.mustTypeAssert<string>(v, {kind: $.TypeKind.Basic, name: 'string'})\n\t$.println(interfaceString)\n\n\t// Test with type conversion through variable\n\tlet myString: string = \"variable test\"\n\tlet convertedString = myString\n\t$.println(convertedString)\n\n\t// === Test string(byte) conversion ===\n\tlet b: number = 65\n\tlet byteString = $.runeOrStringToString(b)\n\t$.println(byteString)\n}\n\n",
    "expectedOutput": "hello world\nA\na\n\nGoScript\n\n\n\ntrue\nmutable string\nHello\nB\ninterface test\nvariable test\nA"
  },
  {
    "name": "string_copy_to_array",
    "goCode": "package main\n\nfunc main() {\n\tvar arr [10]byte\n\tdecodeMapInitialize := \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n\tcopy(arr[:], decodeMapInitialize)\n\n\t// Check that arr is initialized with 255 values\n\tfor i := 0; i < len(arr); i++ {\n\t\tif arr[i] != 255 {\n\t\t\tpanic(\"copy failed\")\n\t\t}\n\t}\n\tprintln(\"Copy succeeded\")\n}\n",
    "tsCode": "// Generated file based on string_copy_to_array.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet arr: number[] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\tlet decodeMapInitialize = \"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\"\n\t$.copy($.goSlice(arr, undefined, undefined), decodeMapInitialize)\n\n\t// Check that arr is initialized with 255 values\n\tfor (let i = 0; i < $.len(arr); i++) {\n\t\tif (arr![i] != 255) {\n\t\t\t$.panic(\"copy failed\")\n\t\t}\n\t}\n\t$.println(\"Copy succeeded\")\n}\n\n",
    "expectedOutput": "Copy succeeded\n"
  },
  {
    "name": "string_index_access",
    "goCode": "package main\n\nfunc main() {\n\tmyStr1 := \"testing\"\n\tprintln(\"Byte from myStr1[0]:\", myStr1[0]) // Expected: t (byte value 116)\n\tprintln(\"Byte from myStr1[2]:\", myStr1[2]) // Expected: s (byte value 115)\n\tprintln(\"Byte from myStr1[6]:\", myStr1[6]) // Expected: g (byte value 103)\n\n\tmyStr2 := \"\" // \"Hello World\" in Chinese\n\t// Accessing bytes of multi-byte characters\n\t// '' is E4 BD A0 in UTF-8\n\t// '' is E5 A5 BD in UTF-8\n\t// '' is E4 B8 96 in UTF-8\n\t// '' is E7 95 C2 8C in UTF-8 ( seems to be E7 95 8C, let's assume 3 bytes for simplicity in this example)\n\t// For \"\", bytes are: E4 BD A0 E5 A5 BD E4 B8 96 E7 95 8C\n\tprintln(\"Byte from myStr2[0]:\", myStr2[0]) // Expected: E4 (byte value 228) - First byte of ''\n\tprintln(\"Byte from myStr2[1]:\", myStr2[1]) // Expected: BD (byte value 189) - Second byte of ''\n\tprintln(\"Byte from myStr2[2]:\", myStr2[2]) // Expected: A0 (byte value 160) - Third byte of ''\n\tprintln(\"Byte from myStr2[3]:\", myStr2[3]) // Expected: E5 (byte value 229) - First byte of ''\n}\n",
    "tsCode": "// Generated file based on string_index_access.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet myStr1 = \"testing\"\n\t$.println(\"Byte from myStr1[0]:\", $.indexString(myStr1, 0)) // Expected: t (byte value 116)\n\t$.println(\"Byte from myStr1[2]:\", $.indexString(myStr1, 2)) // Expected: s (byte value 115)\n\t$.println(\"Byte from myStr1[6]:\", $.indexString(myStr1, 6)) // Expected: g (byte value 103)\n\n\tlet myStr2 = \"\" // \"Hello World\" in Chinese\n\t// Accessing bytes of multi-byte characters\n\t// '' is E4 BD A0 in UTF-8\n\t// '' is E5 A5 BD in UTF-8\n\t// '' is E4 B8 96 in UTF-8\n\t// '' is E7 95 C2 8C in UTF-8 ( seems to be E7 95 8C, let's assume 3 bytes for simplicity in this example)\n\t// For \"\", bytes are: E4 BD A0 E5 A5 BD E4 B8 96 E7 95 8C\n\t$.println(\"Byte from myStr2[0]:\", $.indexString(myStr2, 0)) // Expected: E4 (byte value 228) - First byte of ''\n\t$.println(\"Byte from myStr2[1]:\", $.indexString(myStr2, 1)) // Expected: BD (byte value 189) - Second byte of ''\n\t$.println(\"Byte from myStr2[2]:\", $.indexString(myStr2, 2)) // Expected: A0 (byte value 160) - Third byte of ''\n\t$.println(\"Byte from myStr2[3]:\", $.indexString(myStr2, 3)) // Expected: E5 (byte value 229) - First byte of ''\n}\n\n",
    "expectedOutput": "Byte from myStr1[0]: 116\nByte from myStr1[2]: 115\nByte from myStr1[6]: 103\nByte from myStr2[0]: 228\nByte from myStr2[1]: 189\nByte from myStr2[2]: 160\nByte from myStr2[3]: 229\n"
  },
  {
    "name": "string_index_array_access",
    "goCode": "package main\n\nfunc main() {\n\tencoder := \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n\n\tvar decodeMap [256]byte\n\tfor i := range decodeMap {\n\t\tdecodeMap[i] = 255\n\t}\n\n\tfor i := 0; i < len(encoder); i++ {\n\t\tif decodeMap[encoder[i]] != 255 {\n\t\t\tpanic(\"duplicate symbol\")\n\t\t}\n\t\tdecodeMap[encoder[i]] = byte(i)\n\t}\n\n\tprintln(\"Success: no duplicates\")\n}\n",
    "tsCode": "// Generated file based on string_index_array_access.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet encoder = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n\n\tlet decodeMap: number[] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\tfor (let i = 0; i < $.len(decodeMap); i++) {\n\t\t{\n\t\t\tdecodeMap![i] = 255\n\t\t}\n\t}\n\n\tfor (let i = 0; i < $.len(encoder); i++) {\n\t\tif (decodeMap![$.indexString(encoder, i)] != 255) {\n\t\t\t$.panic(\"duplicate symbol\")\n\t\t}\n\t\tdecodeMap![$.indexString(encoder, i)] = $.byte(i)\n\t}\n\n\t$.println(\"Success: no duplicates\")\n}\n\n",
    "expectedOutput": "Success: no duplicates\n"
  },
  {
    "name": "string_slice",
    "goCode": "package main\n\nfunc main() {\n\tmyStr1 := \"testing\"\n\tprintln(\"myStr1:\", myStr1)\n\tprintln(\"len(myStr1):\", len(myStr1))\n\n\t// Basic slicing\n\tprintln(\"myStr1[0:2]:\", myStr1[0:2]) // Expected: \"te\"\n\tprintln(\"myStr1[2:5]:\", myStr1[2:5]) // Expected: \"sti\"\n\tprintln(\"myStr1[5:7]:\", myStr1[5:7]) // Expected: \"ng\"\n\n\t// Slicing to the end\n\tprintln(\"myStr1[3:]:\", myStr1[3:]) // Expected: \"ting\"\n\n\t// Slicing from the beginning\n\tprintln(\"myStr1[:4]:\", myStr1[:4]) // Expected: \"test\"\n\n\t// Slicing the entire string\n\tprintln(\"myStr1[:]:\", myStr1[:]) // Expected: \"testing\"\n\n\t// Slicing with Unicode characters\n\tmyStr2 := \"\" // \"Hello World\" in Chinese\n\t// UTF-8 bytes:\n\t// : E4 BD A0\n\t// : E5 A5 BD\n\t// : E4 B8 96\n\t// : E7 95 8C\n\t// Combined: E4 BD A0 E5 A5 BD E4 B8 96 E7 95 8C\n\tprintln(\"myStr2:\", myStr2)\n\tprintln(\"len(myStr2):\", len(myStr2)) // Expected: 12 (3 bytes per char * 4 chars)\n\n\t// Slice the first character '' (3 bytes)\n\tprintln(\"myStr2[0:3]:\", myStr2[0:3]) // Expected: \"\"\n\n\t// Slice the second character '' (next 3 bytes)\n\tprintln(\"myStr2[3:6]:\", myStr2[3:6]) // Expected: \"\"\n\n\t// Slice '' (first 6 bytes)\n\tprintln(\"myStr2[0:6]:\", myStr2[0:6]) // Expected: \"\"\n\n\t// Slice from middle of a multi-byte char to middle of another - result might be invalid UTF-8 but still a valid slice\n\t// byteSlice := []byte(myStr2[1:5])\n\t// NOTE: this would throw an error since this is not possible in JavaScript (converting string to invalid utf-8 then indexing it)\n\t// instead of implementing this with a hack we chose to just throw an error in this case.\n\t// println(\"myStr2[1:5] => bytes:\", byteSlice[0], byteSlice[1], byteSlice[2], byteSlice[3]) // Expected: bytes BD A0 E5 A5 (partial , partial )\n\n\t// Empty slices\n\tprintln(\"myStr1[1:1]:\", myStr1[1:1]) // Expected: \"\"\n\tprintln(\"myStr1[0:0]:\", myStr1[0:0]) // Expected: \"\"\n\tprintln(\"myStr1[7:7]:\", myStr1[7:7]) // Expected: \"\" (len is 7, so index 7 is valid for end of slice)\n\n\ts := \"abc\"\n\ts1 := s[0:1]\n\ts2 := s[1:2]\n\ts3 := s[2:3]\n\tprintln(s1, s2, s3) // Expected: a b c\n}\n",
    "tsCode": "// Generated file based on string_slice.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet myStr1 = \"testing\"\n\t$.println(\"myStr1:\", myStr1)\n\t$.println(\"len(myStr1):\", $.len(myStr1))\n\n\t// Basic slicing\n\t$.println(\"myStr1[0:2]:\", $.sliceString(myStr1, 0, 2)) // Expected: \"te\"\n\t$.println(\"myStr1[2:5]:\", $.sliceString(myStr1, 2, 5)) // Expected: \"sti\"\n\t$.println(\"myStr1[5:7]:\", $.sliceString(myStr1, 5, 7)) // Expected: \"ng\"\n\n\t// Slicing to the end\n\t$.println(\"myStr1[3:]:\", $.sliceString(myStr1, 3, undefined)) // Expected: \"ting\"\n\n\t// Slicing from the beginning\n\t$.println(\"myStr1[:4]:\", $.sliceString(myStr1, undefined, 4)) // Expected: \"test\"\n\n\t// Slicing the entire string\n\t$.println(\"myStr1[:]:\", $.sliceString(myStr1, undefined, undefined)) // Expected: \"testing\"\n\n\t// Slicing with Unicode characters\n\tlet myStr2 = \"\" // \"Hello World\" in Chinese\n\t// UTF-8 bytes:\n\t// : E4 BD A0\n\t// : E5 A5 BD\n\t// : E4 B8 96\n\t// : E7 95 8C\n\t// Combined: E4 BD A0 E5 A5 BD E4 B8 96 E7 95 8C\n\t$.println(\"myStr2:\", myStr2)\n\t$.println(\"len(myStr2):\", $.len(myStr2)) // Expected: 12 (3 bytes per char * 4 chars)\n\n\t// Slice the first character '' (3 bytes)\n\t$.println(\"myStr2[0:3]:\", $.sliceString(myStr2, 0, 3)) // Expected: \"\"\n\n\t// Slice the second character '' (next 3 bytes)\n\t$.println(\"myStr2[3:6]:\", $.sliceString(myStr2, 3, 6)) // Expected: \"\"\n\n\t// Slice '' (first 6 bytes)\n\t$.println(\"myStr2[0:6]:\", $.sliceString(myStr2, 0, 6)) // Expected: \"\"\n\n\t// Slice from middle of a multi-byte char to middle of another - result might be invalid UTF-8 but still a valid slice\n\t// byteSlice := []byte(myStr2[1:5])\n\t// NOTE: this would throw an error since this is not possible in JavaScript (converting string to invalid utf-8 then indexing it)\n\t// instead of implementing this with a hack we chose to just throw an error in this case.\n\t// println(\"myStr2[1:5] => bytes:\", byteSlice[0], byteSlice[1], byteSlice[2], byteSlice[3]) // Expected: bytes BD A0 E5 A5 (partial , partial )\n\n\t// Empty slices\n\t$.println(\"myStr1[1:1]:\", $.sliceString(myStr1, 1, 1)) // Expected: \"\"\n\t$.println(\"myStr1[0:0]:\", $.sliceString(myStr1, 0, 0)) // Expected: \"\"\n\t$.println(\"myStr1[7:7]:\", $.sliceString(myStr1, 7, 7)) // Expected: \"\" (len is 7, so index 7 is valid for end of slice)\n\n\tlet s = \"abc\"\n\tlet s1 = $.sliceString(s, 0, 1)\n\tlet s2 = $.sliceString(s, 1, 2)\n\tlet s3 = $.sliceString(s, 2, 3)\n\t$.println(s1, s2, s3) // Expected: a b c\n}\n\n",
    "expectedOutput": "myStr1: testing\nlen(myStr1): 7\nmyStr1[0:2]: te\nmyStr1[2:5]: sti\nmyStr1[5:7]: ng\nmyStr1[3:]: ting\nmyStr1[:4]: test\nmyStr1[:]: testing\nmyStr2: \nlen(myStr2): 12\nmyStr2[0:3]: \nmyStr2[3:6]: \nmyStr2[0:6]: \nmyStr1[1:1]: \nmyStr1[0:0]: \nmyStr1[7:7]: \na b c\n"
  },
  {
    "name": "string_type_assertion",
    "goCode": "package main\n\nfunc main() {\n\tvar w interface{} = \"test\"\n\tprintln(\"value is\", w.(string))\n}\n",
    "tsCode": "// Generated file based on string_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet w: null | any = \"test\"\n\t$.println(\"value is\", $.mustTypeAssert<string>(w, {kind: $.TypeKind.Basic, name: 'string'}))\n}\n\n",
    "expectedOutput": "value is test\n"
  },
  {
    "name": "struct_embedding",
    "goCode": "package main\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc (p Person) Greet() {\n\tprintln(\"Hello, my name is \" + p.Name)\n}\n\ntype Employee struct {\n\tPerson // Embedded struct\n\tID     int\n}\n\n// --- Multiple Embedding Structs/Methods ---\ntype Address struct {\n\tStreet string\n\tCity   string\n}\n\nfunc (a Address) FullAddress() string {\n\treturn a.Street + \", \" + a.City\n}\n\ntype Contact struct {\n\tPhone string\n}\n\nfunc (c Contact) Call() {\n\tprintln(\"Calling \" + c.Phone)\n}\n\ntype Manager struct {\n\tPerson  // Embed Person\n\tAddress // Embed Address\n\tContact // Embed Contact\n\tLevel   int\n}\n\nfunc main() {\n\t// --- Single Embedding Tests ---\n\te := Employee{\n\t\tPerson: Person{\n\t\t\tName: \"Alice\",\n\t\t\tAge:  30,\n\t\t},\n\t\tID: 123,\n\t}\n\n\t// Accessing embedded fields\n\tprintln(\"Employee Name:\", e.Name)\n\tprintln(\"Employee Age:\", e.Age)\n\tprintln(\"Employee ID:\", e.ID)\n\n\t// Calling embedded method\n\te.Greet()\n\n\t// Test with a pointer to Employee\n\tep := &Employee{\n\t\tPerson: Person{\n\t\t\tName: \"Bob\",\n\t\t\tAge:  25,\n\t\t},\n\t\tID: 456,\n\t}\n\n\t// Accessing embedded fields via pointer\n\tprintln(\"Employee Pointer Name:\", ep.Name)\n\tprintln(\"Employee Pointer Age:\", ep.Age)\n\tprintln(\"Employee Pointer ID:\", ep.ID)\n\n\t// Calling embedded method via pointer\n\tep.Greet()\n\n\t// --- Multiple Embedding Tests ---\n\tprintln(\"\\n--- Multiple Embedding ---\")\n\tm := Manager{\n\t\tPerson: Person{\n\t\t\tName: \"Charlie\",\n\t\t\tAge:  40,\n\t\t},\n\t\tAddress: Address{\n\t\t\tStreet: \"123 Main St\",\n\t\t\tCity:   \"Anytown\",\n\t\t},\n\t\tContact: Contact{\n\t\t\tPhone: \"555-1234\",\n\t\t},\n\t\tLevel: 5,\n\t}\n\n\t// Accessing fields from all embedded structs and the outer struct\n\tprintln(\"Manager Name:\", m.Name)     // From Person\n\tprintln(\"Manager Age:\", m.Age)       // From Person\n\tprintln(\"Manager Street:\", m.Street) // From Address\n\tprintln(\"Manager City:\", m.City)     // From Address\n\tprintln(\"Manager Phone:\", m.Phone)   // From Contact\n\tprintln(\"Manager Level:\", m.Level)   // From Manager\n\n\t// Calling methods from embedded structs\n\tm.Greet()                                         // From Person\n\tprintln(\"Manager Full Address:\", m.FullAddress()) // From Address\n\tm.Call()                                          // From Contact\n\n\t// Test with a pointer\n\tmp := &m\n\tprintln(\"\\n--- Multiple Embedding (Pointer) ---\")\n\tprintln(\"Manager Pointer Name:\", mp.Name)\n\tmp.Greet()\n\tprintln(\"Manager Pointer Full Address:\", mp.FullAddress())\n\tmp.Call()\n\n\t// Modify through pointer\n\tmp.Age = 41\n\tmp.City = \"New City\"\n\tprintln(\"Modified Manager Age:\", m.Age)\n\tprintln(\"Modified Manager City:\", m.City)\n}\n",
    "tsCode": "// Generated file based on struct_embedding.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Address {\n\tpublic get Street(): string {\n\t\treturn this._fields.Street.value\n\t}\n\tpublic set Street(value: string) {\n\t\tthis._fields.Street.value = value\n\t}\n\n\tpublic get City(): string {\n\t\treturn this._fields.City.value\n\t}\n\tpublic set City(value: string) {\n\t\tthis._fields.City.value = value\n\t}\n\n\tpublic _fields: {\n\t\tStreet: $.VarRef<string>;\n\t\tCity: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{City?: string, Street?: string}>) {\n\t\tthis._fields = {\n\t\t\tStreet: $.varRef(init?.Street ?? \"\"),\n\t\t\tCity: $.varRef(init?.City ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): Address {\n\t\tconst cloned = new Address()\n\t\tcloned._fields = {\n\t\t\tStreet: $.varRef(this._fields.Street.value),\n\t\t\tCity: $.varRef(this._fields.City.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic FullAddress(): string {\n\t\tconst a = this\n\t\treturn a.Street + \", \" + a.City\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Address',\n\t  new Address(),\n\t  [{ name: \"FullAddress\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  Address,\n\t  {\"Street\": { kind: $.TypeKind.Basic, name: \"string\" }, \"City\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport class Contact {\n\tpublic get Phone(): string {\n\t\treturn this._fields.Phone.value\n\t}\n\tpublic set Phone(value: string) {\n\t\tthis._fields.Phone.value = value\n\t}\n\n\tpublic _fields: {\n\t\tPhone: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{Phone?: string}>) {\n\t\tthis._fields = {\n\t\t\tPhone: $.varRef(init?.Phone ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): Contact {\n\t\tconst cloned = new Contact()\n\t\tcloned._fields = {\n\t\t\tPhone: $.varRef(this._fields.Phone.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Call(): void {\n\t\tconst c = this\n\t\t$.println(\"Calling \" + c.Phone)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Contact',\n\t  new Contact(),\n\t  [{ name: \"Call\", args: [], returns: [] }],\n\t  Contact,\n\t  {\"Phone\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport class Person {\n\tpublic get Name(): string {\n\t\treturn this._fields.Name.value\n\t}\n\tpublic set Name(value: string) {\n\t\tthis._fields.Name.value = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this._fields.Age.value\n\t}\n\tpublic set Age(value: number) {\n\t\tthis._fields.Age.value = value\n\t}\n\n\tpublic _fields: {\n\t\tName: $.VarRef<string>;\n\t\tAge: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Age?: number, Name?: string}>) {\n\t\tthis._fields = {\n\t\t\tName: $.varRef(init?.Name ?? \"\"),\n\t\t\tAge: $.varRef(init?.Age ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Person {\n\t\tconst cloned = new Person()\n\t\tcloned._fields = {\n\t\t\tName: $.varRef(this._fields.Name.value),\n\t\t\tAge: $.varRef(this._fields.Age.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Greet(): void {\n\t\tconst p = this\n\t\t$.println(\"Hello, my name is \" + p.Name)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Person',\n\t  new Person(),\n\t  [{ name: \"Greet\", args: [], returns: [] }],\n\t  Person,\n\t  {\"Name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"Age\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport class Employee {\n\tpublic get ID(): number {\n\t\treturn this._fields.ID.value\n\t}\n\tpublic set ID(value: number) {\n\t\tthis._fields.ID.value = value\n\t}\n\n\tpublic get Person(): Person {\n\t\treturn this._fields.Person.value\n\t}\n\tpublic set Person(value: Person) {\n\t\tthis._fields.Person.value = value\n\t}\n\n\tpublic _fields: {\n\t\tPerson: $.VarRef<Person>;\n\t\tID: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{ID?: number, Person?: Partial<ConstructorParameters<typeof Person>[0]>}>) {\n\t\tthis._fields = {\n\t\t\tPerson: $.varRef(new Person(init?.Person)),\n\t\t\tID: $.varRef(init?.ID ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Employee {\n\t\tconst cloned = new Employee()\n\t\tcloned._fields = {\n\t\t\tPerson: $.varRef($.markAsStructValue(this._fields.Person.value.clone())),\n\t\t\tID: $.varRef(this._fields.ID.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic get Name(): string {\n\t\treturn this.Person.Name\n\t}\n\tpublic set Name(value: string) {\n\t\tthis.Person.Name = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this.Person.Age\n\t}\n\tpublic set Age(value: number) {\n\t\tthis.Person.Age = value\n\t}\n\n\tpublic Greet(): void {\n\t\tthis.Person.Greet()\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Employee',\n\t  new Employee(),\n\t  [],\n\t  Employee,\n\t  {\"Person\": \"Person\", \"ID\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport class Manager {\n\tpublic get Level(): number {\n\t\treturn this._fields.Level.value\n\t}\n\tpublic set Level(value: number) {\n\t\tthis._fields.Level.value = value\n\t}\n\n\tpublic get Person(): Person {\n\t\treturn this._fields.Person.value\n\t}\n\tpublic set Person(value: Person) {\n\t\tthis._fields.Person.value = value\n\t}\n\n\tpublic get Address(): Address {\n\t\treturn this._fields.Address.value\n\t}\n\tpublic set Address(value: Address) {\n\t\tthis._fields.Address.value = value\n\t}\n\n\tpublic get Contact(): Contact {\n\t\treturn this._fields.Contact.value\n\t}\n\tpublic set Contact(value: Contact) {\n\t\tthis._fields.Contact.value = value\n\t}\n\n\tpublic _fields: {\n\t\tPerson: $.VarRef<Person>;\n\t\tAddress: $.VarRef<Address>;\n\t\tContact: $.VarRef<Contact>;\n\t\tLevel: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Address?: Partial<ConstructorParameters<typeof Address>[0]>, Contact?: Partial<ConstructorParameters<typeof Contact>[0]>, Level?: number, Person?: Partial<ConstructorParameters<typeof Person>[0]>}>) {\n\t\tthis._fields = {\n\t\t\tPerson: $.varRef(new Person(init?.Person)),\n\t\t\tAddress: $.varRef(new Address(init?.Address)),\n\t\t\tContact: $.varRef(new Contact(init?.Contact)),\n\t\t\tLevel: $.varRef(init?.Level ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Manager {\n\t\tconst cloned = new Manager()\n\t\tcloned._fields = {\n\t\t\tPerson: $.varRef($.markAsStructValue(this._fields.Person.value.clone())),\n\t\t\tAddress: $.varRef($.markAsStructValue(this._fields.Address.value.clone())),\n\t\t\tContact: $.varRef($.markAsStructValue(this._fields.Contact.value.clone())),\n\t\t\tLevel: $.varRef(this._fields.Level.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic get Name(): string {\n\t\treturn this.Person.Name\n\t}\n\tpublic set Name(value: string) {\n\t\tthis.Person.Name = value\n\t}\n\n\tpublic get Age(): number {\n\t\treturn this.Person.Age\n\t}\n\tpublic set Age(value: number) {\n\t\tthis.Person.Age = value\n\t}\n\n\tpublic Greet(): void {\n\t\tthis.Person.Greet()\n\t}\n\n\tpublic get Street(): string {\n\t\treturn this.Address.Street\n\t}\n\tpublic set Street(value: string) {\n\t\tthis.Address.Street = value\n\t}\n\n\tpublic get City(): string {\n\t\treturn this.Address.City\n\t}\n\tpublic set City(value: string) {\n\t\tthis.Address.City = value\n\t}\n\n\tpublic FullAddress(): string {\n\t\treturn this.Address.FullAddress()\n\t}\n\n\tpublic get Phone(): string {\n\t\treturn this.Contact.Phone\n\t}\n\tpublic set Phone(value: string) {\n\t\tthis.Contact.Phone = value\n\t}\n\n\tpublic Call(): void {\n\t\tthis.Contact.Call()\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Manager',\n\t  new Manager(),\n\t  [],\n\t  Manager,\n\t  {\"Person\": \"Person\", \"Address\": \"Address\", \"Contact\": \"Contact\", \"Level\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// --- Single Embedding Tests ---\n\tlet e = $.markAsStructValue(new Employee({ID: 123, Person: {Name: \"Alice\", Age: 30}}))\n\n\t// Accessing embedded fields\n\t$.println(\"Employee Name:\", e.Name)\n\t$.println(\"Employee Age:\", e.Age)\n\t$.println(\"Employee ID:\", e.ID)\n\n\t// Calling embedded method\n\te.Greet()\n\n\t// Test with a pointer to Employee\n\tlet ep = new Employee({ID: 456, Person: {Name: \"Bob\", Age: 25}})\n\n\t// Accessing embedded fields via pointer\n\t$.println(\"Employee Pointer Name:\", ep!.Name)\n\t$.println(\"Employee Pointer Age:\", ep!.Age)\n\t$.println(\"Employee Pointer ID:\", ep!.ID)\n\n\t// Calling embedded method via pointer\n\tep!.Greet()\n\n\t// --- Multiple Embedding Tests ---\n\t$.println(\"\\n--- Multiple Embedding ---\")\n\tlet m = $.varRef($.markAsStructValue(new Manager({Level: 5, Address: {Street: \"123 Main St\", City: \"Anytown\"}, Contact: {Phone: \"555-1234\"}, Person: {Name: \"Charlie\", Age: 40}})))\n\n\t// Accessing fields from all embedded structs and the outer struct\n\t$.println(\"Manager Name:\", m!.value.Name) // From Person\n\t$.println(\"Manager Age:\", m!.value.Age) // From Person\n\t$.println(\"Manager Street:\", m!.value.Street) // From Address\n\t$.println(\"Manager City:\", m!.value.City) // From Address\n\t$.println(\"Manager Phone:\", m!.value.Phone) // From Contact\n\t$.println(\"Manager Level:\", m!.value.Level) // From Manager\n\n\t// Calling methods from embedded structs\n\tm!.value.Greet() // From Person\n\t$.println(\"Manager Full Address:\", m!.value.FullAddress()) // From Address\n\tm!.value.Call() // From Contact\n\n\t// Test with a pointer\n\tlet mp = m\n\t$.println(\"\\n--- Multiple Embedding (Pointer) ---\")\n\t$.println(\"Manager Pointer Name:\", mp!.value!.Name)\n\tmp!.value!.Greet()\n\t$.println(\"Manager Pointer Full Address:\", mp!.value!.FullAddress())\n\tmp!.value!.Call()\n\n\t// Modify through pointer\n\tmp!.value!.Age = 41\n\tmp!.value!.City = \"New City\"\n\t$.println(\"Modified Manager Age:\", m!.value.Age)\n\t$.println(\"Modified Manager City:\", m!.value.City)\n}\n\n",
    "expectedOutput": "Employee Name: Alice\nEmployee Age: 30\nEmployee ID: 123\nHello, my name is Alice\nEmployee Pointer Name: Bob\nEmployee Pointer Age: 25\nEmployee Pointer ID: 456\nHello, my name is Bob\n\n--- Multiple Embedding ---\nManager Name: Charlie\nManager Age: 40\nManager Street: 123 Main St\nManager City: Anytown\nManager Phone: 555-1234\nManager Level: 5\nHello, my name is Charlie\nManager Full Address: 123 Main St, Anytown\nCalling 555-1234\n\n--- Multiple Embedding (Pointer) ---\nManager Pointer Name: Charlie\nHello, my name is Charlie\nManager Pointer Full Address: 123 Main St, Anytown\nCalling 555-1234\nModified Manager Age: 41\nModified Manager City: New City"
  },
  {
    "name": "struct_embedding_bytes_buffer",
    "goCode": "package main\n\nimport \"bytes\"\n\ntype MyWriter struct {\n\tbytes.Buffer // Embedded Buffer\n\tcount        int\n}\n\nfunc main() {\n\tvar w MyWriter\n\n\t// Call promoted method WriteString from bytes.Buffer\n\tw.WriteString(\"Hello \")\n\tw.WriteString(\"World\")\n\n\tprintln(\"Content:\", w.String())\n\tprintln(\"Length:\", w.Len())\n\n\tprintln(\"test finished\")\n}\n",
    "tsCode": "// Generated file based on struct_embedding_bytes_buffer.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\nimport * as io from \"@goscript/io/index.js\"\n\nimport * as bytes from \"@goscript/bytes/index.js\"\n\nexport class MyWriter {\n\tpublic get count(): number {\n\t\treturn this._fields.count.value\n\t}\n\tpublic set count(value: number) {\n\t\tthis._fields.count.value = value\n\t}\n\n\tpublic get Buffer(): bytes.Buffer {\n\t\treturn this._fields.Buffer.value\n\t}\n\tpublic set Buffer(value: bytes.Buffer) {\n\t\tthis._fields.Buffer.value = value\n\t}\n\n\tpublic _fields: {\n\t\tBuffer: $.VarRef<bytes.Buffer>;\n\t\tcount: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Buffer?: Partial<ConstructorParameters<typeof bytes.Buffer>[0]>, count?: number}>) {\n\t\tthis._fields = {\n\t\t\tBuffer: $.varRef(new bytes.Buffer(init?.Buffer)),\n\t\t\tcount: $.varRef(init?.count ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyWriter {\n\t\tconst cloned = new MyWriter()\n\t\tcloned._fields = {\n\t\t\tBuffer: $.varRef($.markAsStructValue(this._fields.Buffer.value.clone())),\n\t\t\tcount: $.varRef(this._fields.count.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Available(): number {\n\t\treturn this.Buffer.Available()\n\t}\n\n\tpublic AvailableBuffer(): $.Bytes {\n\t\treturn this.Buffer.AvailableBuffer()\n\t}\n\n\tpublic Bytes(): $.Bytes {\n\t\treturn this.Buffer.Bytes()\n\t}\n\n\tpublic Cap(): number {\n\t\treturn this.Buffer.Cap()\n\t}\n\n\tpublic Grow(n: number): void {\n\t\tthis.Buffer.Grow(n)\n\t}\n\n\tpublic Len(): number {\n\t\treturn this.Buffer.Len()\n\t}\n\n\tpublic Next(n: number): $.Bytes {\n\t\treturn this.Buffer.Next(n)\n\t}\n\n\tpublic Read(p: $.Bytes): [number, $.GoError] {\n\t\treturn this.Buffer.Read(p)\n\t}\n\n\tpublic ReadByte(): [number, $.GoError] {\n\t\treturn this.Buffer.ReadByte()\n\t}\n\n\tpublic ReadBytes(delim: number): [$.Bytes, $.GoError] {\n\t\treturn this.Buffer.ReadBytes(delim)\n\t}\n\n\tpublic ReadFrom(r: io.Reader): [number, $.GoError] {\n\t\treturn this.Buffer.ReadFrom(r)\n\t}\n\n\tpublic ReadRune(): [number, number, $.GoError] {\n\t\treturn this.Buffer.ReadRune()\n\t}\n\n\tpublic ReadString(delim: number): [string, $.GoError] {\n\t\treturn this.Buffer.ReadString(delim)\n\t}\n\n\tpublic Reset(): void {\n\t\tthis.Buffer.Reset()\n\t}\n\n\tpublic String(): string {\n\t\treturn this.Buffer.String()\n\t}\n\n\tpublic Truncate(n: number): void {\n\t\tthis.Buffer.Truncate(n)\n\t}\n\n\tpublic UnreadByte(): $.GoError {\n\t\treturn this.Buffer.UnreadByte()\n\t}\n\n\tpublic UnreadRune(): $.GoError {\n\t\treturn this.Buffer.UnreadRune()\n\t}\n\n\tpublic Write(p: $.Bytes): [number, $.GoError] {\n\t\treturn this.Buffer.Write(p)\n\t}\n\n\tpublic WriteByte(c: number): $.GoError {\n\t\treturn this.Buffer.WriteByte(c)\n\t}\n\n\tpublic WriteRune(r: number): [number, $.GoError] {\n\t\treturn this.Buffer.WriteRune(r)\n\t}\n\n\tpublic WriteString(s: string): [number, $.GoError] {\n\t\treturn this.Buffer.WriteString(s)\n\t}\n\n\tpublic WriteTo(w: io.Writer): [number, $.GoError] {\n\t\treturn this.Buffer.WriteTo(w)\n\t}\n\n\tpublic empty(): boolean {\n\t\treturn this.Buffer.empty()\n\t}\n\n\tpublic grow(n: number): number {\n\t\treturn this.Buffer.grow(n)\n\t}\n\n\tpublic readSlice(delim: number): [$.Bytes, $.GoError] {\n\t\treturn this.Buffer.readSlice(delim)\n\t}\n\n\tpublic tryGrowByReslice(n: number): [number, boolean] {\n\t\treturn this.Buffer.tryGrowByReslice(n)\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyWriter',\n\t  new MyWriter(),\n\t  [],\n\t  MyWriter,\n\t  {\"Buffer\": \"Buffer\", \"count\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet w: $.VarRef<MyWriter> = $.varRef(new MyWriter())\n\n\t// Call promoted method WriteString from bytes.Buffer\n\tw!.value.WriteString(\"Hello \")\n\tw!.value.WriteString(\"World\")\n\n\t$.println(\"Content:\", w!.value.String())\n\t$.println(\"Length:\", w!.value.Len())\n\n\t$.println(\"test finished\")\n}\n\n",
    "expectedOutput": "Content: Hello World\nLength: 11\ntest finished\n"
  },
  {
    "name": "struct_field_access",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\nfunc main() {\n\t// === Struct Field Access ===\n\tms := MyStruct{MyInt: 42, MyString: \"foo\"}\n\tprintln(\"MyInt: Expected: 42, Actual:\", ms.MyInt)\n\tprintln(\"MyString: Expected: foo, Actual:\", ms.MyString)\n}\n",
    "tsCode": "// Generated file based on struct_field_access.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// === Struct Field Access ===\n\tlet ms = $.markAsStructValue(new MyStruct({MyInt: 42, MyString: \"foo\"}))\n\t$.println(\"MyInt: Expected: 42, Actual:\", ms.MyInt)\n\t$.println(\"MyString: Expected: foo, Actual:\", ms.MyString)\n}\n\n",
    "expectedOutput": "MyInt: Expected: 42, Actual: 42\nMyString: Expected: foo, Actual: foo"
  },
  {
    "name": "struct_literal_interface",
    "goCode": "package main\n\nimport \"reflect\"\n\nfunc main() {\n\t// Test creating reflect.SelectCase struct literals\n\tcases := []reflect.SelectCase{\n\t\t{Dir: reflect.SelectDefault},\n\t}\n\tprintln(\"Cases len:\", len(cases))\n\tprintln(\"First case dir:\", cases[0].Dir)\n}\n",
    "tsCode": "// Generated file based on struct_literal_interface.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Test creating reflect.SelectCase struct literals\n\tlet cases = $.arrayToSlice<reflect.SelectCase>([$.markAsStructValue(new reflect.SelectCase({Dir: reflect.SelectDefault}))])\n\t$.println(\"Cases len:\", $.len(cases))\n\t$.println(\"First case dir:\", cases![0].Dir)\n}\n\n",
    "expectedOutput": "Cases len: 1\nFirst case dir: 3\n"
  },
  {
    "name": "struct_new",
    "goCode": "package main\n\n// MyStruct is a simple struct.\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n\tmyBool   bool\n}\n\nfunc main() {\n\t// Test new(MyStruct)\n\tptr := new(MyStruct)\n\tprintln(\"ptr.MyInt (default):\", ptr.MyInt)       // Expected: 0\n\tprintln(\"ptr.MyString (default):\", ptr.MyString) // Expected: \"\"\n\tprintln(\"ptr.myBool (default):\", ptr.myBool)     // Expected: false\n\n\tptr.MyInt = 42\n\tptr.MyString = \"hello\"\n\tptr.myBool = true\n\n\tprintln(\"ptr.MyInt (assigned):\", ptr.MyInt)       // Expected: 42\n\tprintln(\"ptr.MyString (assigned):\", ptr.MyString) // Expected: \"hello\"\n\tprintln(\"ptr.myBool (assigned):\", ptr.myBool)     // Expected: true\n\n\t// Test assignment to a dereferenced new struct\n\tvar s MyStruct = *new(MyStruct)\n\tprintln(\"s.MyInt (default):\", s.MyInt)       // Expected: 0\n\tprintln(\"s.MyString (default):\", s.MyString) // Expected: \"\"\n\tprintln(\"s.myBool (default):\", s.myBool)     // Expected: false\n\n\ts.MyInt = 100\n\ts.MyString = \"world\"\n\ts.myBool = false // though private, it's in the same package\n\n\tprintln(\"s.MyInt (assigned):\", s.MyInt)       // Expected: 100\n\tprintln(\"s.MyString (assigned):\", s.MyString) // Expected: \"world\"\n\tprintln(\"s.myBool (assigned):\", s.myBool)     // Expected: false\n}\n",
    "tsCode": "// Generated file based on struct_new.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic get myBool(): boolean {\n\t\treturn this._fields.myBool.value\n\t}\n\tpublic set myBool(value: boolean) {\n\t\tthis._fields.myBool.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t\tmyBool: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string, myBool?: boolean}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\"),\n\t\t\tmyBool: $.varRef(init?.myBool ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value),\n\t\t\tmyBool: $.varRef(this._fields.myBool.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }, \"myBool\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Test new(MyStruct)\n\tlet ptr = new MyStruct()\n\t$.println(\"ptr.MyInt (default):\", ptr!.MyInt) // Expected: 0\n\t$.println(\"ptr.MyString (default):\", ptr!.MyString) // Expected: \"\"\n\t$.println(\"ptr.myBool (default):\", ptr!.myBool) // Expected: false\n\n\tptr!.MyInt = 42\n\tptr!.MyString = \"hello\"\n\tptr!.myBool = true\n\n\t$.println(\"ptr.MyInt (assigned):\", ptr!.MyInt) // Expected: 42\n\t$.println(\"ptr.MyString (assigned):\", ptr!.MyString) // Expected: \"hello\"\n\t$.println(\"ptr.myBool (assigned):\", ptr!.myBool) // Expected: true\n\n\t// Test assignment to a dereferenced new struct\n\tlet s: MyStruct = $.markAsStructValue(new MyStruct()!.clone())\n\t$.println(\"s.MyInt (default):\", s.MyInt) // Expected: 0\n\t$.println(\"s.MyString (default):\", s.MyString) // Expected: \"\"\n\t$.println(\"s.myBool (default):\", s.myBool) // Expected: false\n\n\ts.MyInt = 100\n\ts.MyString = \"world\"\n\ts.myBool = false // though private, it's in the same package\n\n\t$.println(\"s.MyInt (assigned):\", s.MyInt) // Expected: 100\n\t$.println(\"s.MyString (assigned):\", s.MyString) // Expected: \"world\"\n\t$.println(\"s.myBool (assigned):\", s.myBool) // Expected: false\n}\n\n",
    "expectedOutput": "ptr.MyInt (default): 0\nptr.MyString (default): \nptr.myBool (default): false\nptr.MyInt (assigned): 42\nptr.MyString (assigned): hello\nptr.myBool (assigned): true\ns.MyInt (default): 0\ns.MyString (default): \ns.myBool (default): false\ns.MyInt (assigned): 100\ns.MyString (assigned): world\ns.myBool (assigned): false\n"
  },
  {
    "name": "struct_pointer_interface_fields",
    "goCode": "package main\n\ntype MyInterface interface {\n\tMethod()\n}\n\ntype MyStruct struct {\n\tPointerField   *int\n\tinterfaceField MyInterface\n}\n\nfunc main() {\n\ts := MyStruct{}\n\tprintln(s.PointerField == nil)\n\tprintln(s.interfaceField == nil)\n\n\ti := 10\n\ts.PointerField = &i\n\tprintln(s.PointerField != nil)\n\tprintln(*s.PointerField)\n\ti = 15\n\tprintln(*s.PointerField)\n\n\tvar mi MyInterface\n\ts.interfaceField = mi\n\tprintln(s.interfaceField == nil)\n}\n",
    "tsCode": "// Generated file based on struct_pointer_interface_fields.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyInterface = null | {\n\tMethod(): void\n}\n\n$.registerInterfaceType(\n  'main.MyInterface',\n  null, // Zero value for interface is null\n  [{ name: \"Method\", args: [], returns: [] }]\n);\n\nexport class MyStruct {\n\tpublic get PointerField(): $.VarRef<number> | null {\n\t\treturn this._fields.PointerField.value\n\t}\n\tpublic set PointerField(value: $.VarRef<number> | null) {\n\t\tthis._fields.PointerField.value = value\n\t}\n\n\tpublic get interfaceField(): MyInterface {\n\t\treturn this._fields.interfaceField.value\n\t}\n\tpublic set interfaceField(value: MyInterface) {\n\t\tthis._fields.interfaceField.value = value\n\t}\n\n\tpublic _fields: {\n\t\tPointerField: $.VarRef<$.VarRef<number> | null>;\n\t\tinterfaceField: $.VarRef<MyInterface>;\n\t}\n\n\tconstructor(init?: Partial<{PointerField?: $.VarRef<number> | null, interfaceField?: MyInterface}>) {\n\t\tthis._fields = {\n\t\t\tPointerField: $.varRef(init?.PointerField ?? null),\n\t\t\tinterfaceField: $.varRef(init?.interfaceField ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tPointerField: $.varRef(this._fields.PointerField.value),\n\t\t\tinterfaceField: $.varRef(this._fields.interfaceField.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"PointerField\": { kind: $.TypeKind.Pointer, elemType: { kind: $.TypeKind.Basic, name: \"int\" } }, \"interfaceField\": \"MyInterface\"}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet s = $.markAsStructValue(new MyStruct({}))\n\t$.println(s.PointerField == null)\n\t$.println(s.interfaceField == null)\n\n\tlet i = $.varRef(10)\n\ts.PointerField = i\n\t$.println(s.PointerField != null)\n\t$.println(s.PointerField!.value)\n\ti!.value = 15\n\t$.println(s.PointerField!.value)\n\n\tlet mi: MyInterface = null\n\ts.interfaceField = mi\n\t$.println(s.interfaceField == null)\n}\n\n",
    "expectedOutput": "true\ntrue\ntrue\n10\n15\ntrue"
  },
  {
    "name": "struct_pointer_marking",
    "goCode": "package main\n\ntype MyStruct struct {\n\tValue int\n}\n\nfunc main() {\n\tprintln(\"=== Struct Pointer Marking Test ===\")\n\n\t// Scenario 1: Address-of Composite Literal vs Value Variable\n\tprintln(\"\\n--- Scenario 1: Composite Literal vs Value Variable ---\")\n\ts := MyStruct{Value: 10}  // struct value\n\tp := &MyStruct{Value: 20} // pointer to struct (should be marked)\n\n\t// Type assertions - struct value\n\tvar i interface{} = s\n\t_, ok1 := i.(MyStruct)                               // should succeed\n\t_, ok2 := i.(*MyStruct)                              // should fail\n\tprintln(\"struct value -> MyStruct assertion:\", ok1)  // Expected: true\n\tprintln(\"struct value -> *MyStruct assertion:\", ok2) // Expected: false\n\n\t// Type assertions - struct pointer\n\tvar j interface{} = p\n\t_, ok3 := j.(MyStruct)                                 // should fail\n\t_, ok4 := j.(*MyStruct)                                // should succeed\n\tprintln(\"struct pointer -> MyStruct assertion:\", ok3)  // Expected: false\n\tprintln(\"struct pointer -> *MyStruct assertion:\", ok4) // Expected: true\n\n\t// Scenario 2: Variable Aliasing\n\tprintln(\"\\n--- Scenario 2: Variable Aliasing ---\")\n\toriginal := MyStruct{Value: 30}\n\tpAlias := &original // pointer to existing variable\n\n\tvar iOriginal interface{} = original // struct value in interface\n\tvar jAlias interface{} = pAlias      // struct pointer in interface\n\n\t_, ok5 := iOriginal.(MyStruct)                         // should succeed\n\t_, ok6 := iOriginal.(*MyStruct)                        // should fail\n\tprintln(\"original value -> MyStruct assertion:\", ok5)  // Expected: true\n\tprintln(\"original value -> *MyStruct assertion:\", ok6) // Expected: false\n\n\t_, ok7 := jAlias.(MyStruct)                           // should fail\n\t_, ok8 := jAlias.(*MyStruct)                          // should succeed\n\tprintln(\"alias pointer -> MyStruct assertion:\", ok7)  // Expected: false\n\tprintln(\"alias pointer -> *MyStruct assertion:\", ok8) // Expected: true\n\n\t// Scenario 3: Multiple Pointers to Same Variable\n\tprintln(\"\\n--- Scenario 3: Multiple Pointers to Same Variable ---\")\n\tshared := MyStruct{Value: 40}\n\tp1 := &shared\n\tp2 := &shared\n\n\tvar i1 interface{} = p1\n\tvar i2 interface{} = p2\n\n\t_, ok9 := i1.(*MyStruct)                                // should succeed\n\t_, ok10 := i2.(*MyStruct)                               // should succeed\n\tprintln(\"first pointer -> *MyStruct assertion:\", ok9)   // Expected: true\n\tprintln(\"second pointer -> *MyStruct assertion:\", ok10) // Expected: true\n\n\t// Verify they point to the same data\n\tif structPtr1, ok := i1.(*MyStruct); ok {\n\t\tif structPtr2, ok := i2.(*MyStruct); ok {\n\t\t\tstructPtr1.Value = 99\n\t\t\tprintln(\"shared modification check:\", structPtr2.Value) // Expected: 99\n\t\t}\n\t}\n\n\t// Scenario 4: Mixed Assignment Patterns\n\tprintln(\"\\n--- Scenario 4: Mixed Assignment Patterns ---\")\n\tmixed := MyStruct{Value: 50}\n\tpVar := &mixed               // pointer to variable\n\tpLit := &MyStruct{Value: 60} // pointer to composite literal\n\n\tvar iVar interface{} = pVar // VarRef in interface\n\tvar iLit interface{} = pLit // marked struct in interface\n\n\t_, ok11 := iVar.(*MyStruct)                               // should succeed\n\t_, ok12 := iLit.(*MyStruct)                               // should succeed\n\tprintln(\"variable pointer -> *MyStruct assertion:\", ok11) // Expected: true\n\tprintln(\"literal pointer -> *MyStruct assertion:\", ok12)  // Expected: true\n\n\t// Scenario 5: Nested Type Assertions\n\tprintln(\"\\n--- Scenario 5: Nested Type Assertions ---\")\n\tnested1 := &MyStruct{Value: 70}\n\tnested2 := MyStruct{Value: 80}\n\n\t// Array of interfaces containing both pointers and values\n\tarr := []interface{}{nested1, nested2, &nested2}\n\n\tfor i, item := range arr {\n\t\tif val, ok := item.(MyStruct); ok {\n\t\t\tprintln(\"arr[\", i, \"] is MyStruct with value:\", val.Value)\n\t\t} else if ptr, ok := item.(*MyStruct); ok {\n\t\t\tprintln(\"arr[\", i, \"] is *MyStruct with value:\", ptr.Value)\n\t\t} else {\n\t\t\tprintln(\"arr[\", i, \"] is unknown type\")\n\t\t}\n\t}\n\n\t// Scenario 6: Type Switch with Mixed Types\n\tprintln(\"\\n--- Scenario 6: Type Switch ---\")\n\ttestItems := []interface{}{\n\t\tMyStruct{Value: 100},\n\t\t&MyStruct{Value: 200},\n\t\t300,\n\t\t\"string\",\n\t}\n\n\tfor i, item := range testItems {\n\t\tswitch v := item.(type) {\n\t\tcase MyStruct:\n\t\t\tprintln(\"testItems[\", i, \"] is MyStruct value:\", v.Value)\n\t\tcase *MyStruct:\n\t\t\tprintln(\"testItems[\", i, \"] is *MyStruct pointer:\", v.Value)\n\t\tcase int:\n\t\t\tprintln(\"testItems[\", i, \"] is int:\", v)\n\t\tcase string:\n\t\t\tprintln(\"testItems[\", i, \"] is string:\", v)\n\t\tdefault:\n\t\t\tprintln(\"testItems[\", i, \"] is unknown type\")\n\t\t}\n\t}\n\n\tprintln(\"\\n=== Test Complete ===\")\n}\n",
    "tsCode": "// Generated file based on struct_pointer_marking.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t$.println(\"=== Struct Pointer Marking Test ===\")\n\n\t// Scenario 1: Address-of Composite Literal vs Value Variable\n\t$.println(\"\\n--- Scenario 1: Composite Literal vs Value Variable ---\")\n\tlet s = $.markAsStructValue(new MyStruct({Value: 10})) // struct value\n\tlet p = new MyStruct({Value: 20}) // pointer to struct (should be marked)\n\n\t// Type assertions - struct value\n\tlet i: null | any = $.markAsStructValue(s.clone())\n\tlet { ok: ok1 } = $.typeAssert<MyStruct>(i, 'main.MyStruct')\n\tlet { ok: ok2 } = $.typeAssert<MyStruct | null>(i, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"struct value -> MyStruct assertion:\", ok1) // Expected: true\n\t$.println(\"struct value -> *MyStruct assertion:\", ok2) // Expected: false\n\n\t// Type assertions - struct pointer\n\tlet j: null | any = p\n\tlet { ok: ok3 } = $.typeAssert<MyStruct>(j, 'main.MyStruct')\n\tlet { ok: ok4 } = $.typeAssert<MyStruct | null>(j, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"struct pointer -> MyStruct assertion:\", ok3) // Expected: false\n\t$.println(\"struct pointer -> *MyStruct assertion:\", ok4) // Expected: true\n\n\t// Scenario 2: Variable Aliasing\n\t$.println(\"\\n--- Scenario 2: Variable Aliasing ---\")\n\tlet original = $.varRef($.markAsStructValue(new MyStruct({Value: 30})))\n\tlet pAlias = original // pointer to existing variable\n\n\t// struct value in interface\n\tlet iOriginal: null | any = $.markAsStructValue(original!.value.clone())\n\t// struct pointer in interface\n\tlet jAlias: null | any = pAlias\n\n\tlet { ok: ok5 } = $.typeAssert<MyStruct>(iOriginal, 'main.MyStruct')\n\tlet { ok: ok6 } = $.typeAssert<MyStruct | null>(iOriginal, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"original value -> MyStruct assertion:\", ok5) // Expected: true\n\t$.println(\"original value -> *MyStruct assertion:\", ok6) // Expected: false\n\n\tlet { ok: ok7 } = $.typeAssert<MyStruct>(jAlias, 'main.MyStruct')\n\tlet { ok: ok8 } = $.typeAssert<MyStruct | null>(jAlias, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"alias pointer -> MyStruct assertion:\", ok7) // Expected: false\n\t$.println(\"alias pointer -> *MyStruct assertion:\", ok8) // Expected: true\n\n\t// Scenario 3: Multiple Pointers to Same Variable\n\t$.println(\"\\n--- Scenario 3: Multiple Pointers to Same Variable ---\")\n\tlet shared = $.varRef($.markAsStructValue(new MyStruct({Value: 40})))\n\tlet p1 = shared\n\tlet p2 = shared\n\n\tlet i1: null | any = p1\n\tlet i2: null | any = p2\n\n\tlet { ok: ok9 } = $.typeAssert<MyStruct | null>(i1, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\tlet { ok: ok10 } = $.typeAssert<MyStruct | null>(i2, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"first pointer -> *MyStruct assertion:\", ok9) // Expected: true\n\t$.println(\"second pointer -> *MyStruct assertion:\", ok10) // Expected: true\n\n\t// Verify they point to the same data\n\n\t// Expected: 99\n\t{\n\t\tlet { value: structPtr1, ok: ok } = $.typeAssert<MyStruct | null>(i1, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t\tif (ok) {\n\n\t\t\t// Expected: 99\n\t\t\t{\n\t\t\t\tlet { value: structPtr2, ok: ok } = $.typeAssert<MyStruct | null>(i2, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t\t\t\tif (ok) {\n\t\t\t\t\tstructPtr1!.Value = 99\n\t\t\t\t\t$.println(\"shared modification check:\", structPtr2!.Value) // Expected: 99\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scenario 4: Mixed Assignment Patterns\n\t$.println(\"\\n--- Scenario 4: Mixed Assignment Patterns ---\")\n\tlet mixed = $.varRef($.markAsStructValue(new MyStruct({Value: 50})))\n\tlet pVar = mixed // pointer to variable\n\tlet pLit = new MyStruct({Value: 60}) // pointer to composite literal\n\n\t// VarRef in interface\n\tlet iVar: null | any = pVar\n\t// marked struct in interface\n\tlet iLit: null | any = pLit\n\n\tlet { ok: ok11 } = $.typeAssert<MyStruct | null>(iVar, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\tlet { ok: ok12 } = $.typeAssert<MyStruct | null>(iLit, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"variable pointer -> *MyStruct assertion:\", ok11) // Expected: true\n\t$.println(\"literal pointer -> *MyStruct assertion:\", ok12) // Expected: true\n\n\t// Scenario 5: Nested Type Assertions\n\t$.println(\"\\n--- Scenario 5: Nested Type Assertions ---\")\n\tlet nested1 = new MyStruct({Value: 70})\n\tlet nested2 = $.varRef($.markAsStructValue(new MyStruct({Value: 80})))\n\n\t// Array of interfaces containing both pointers and values\n\tlet arr = $.arrayToSlice<null | any>([nested1, nested2!.value, nested2])\n\n\tfor (let i = 0; i < $.len(arr); i++) {\n\t\tlet item = arr![i]\n\t\t{\n\t\t\t{\n\t\t\t\tlet { value: val, ok: ok } = $.typeAssert<MyStruct>(item, 'main.MyStruct')\n\t\t\t\tif (ok) {\n\t\t\t\t\t$.println(\"arr[\", i, \"] is MyStruct with value:\", val.Value)\n\t\t\t\t} else {\n\t\t\t\t\tlet { value: ptr, ok: ok } = $.typeAssert<MyStruct | null>(item, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t$.println(\"arr[\", i, \"] is *MyStruct with value:\", ptr!.Value)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$.println(\"arr[\", i, \"] is unknown type\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scenario 6: Type Switch with Mixed Types\n\t$.println(\"\\n--- Scenario 6: Type Switch ---\")\n\tlet testItems = $.arrayToSlice<null | any>([$.markAsStructValue(new MyStruct({Value: 100})), new MyStruct({Value: 200}), 300, \"string\"])\n\n\tfor (let i = 0; i < $.len(testItems); i++) {\n\t\tlet item = testItems![i]\n\t\t{\n\t\t\t$.typeSwitch(item, [{ types: ['main.MyStruct'], body: (v) => {\n\t\t\t\t$.println(\"testItems[\", i, \"] is MyStruct value:\", v.Value)\n\t\t\t}},\n\t\t\t{ types: [{kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'}], body: (v) => {\n\t\t\t\t$.println(\"testItems[\", i, \"] is *MyStruct pointer:\", v!.Value)\n\t\t\t}},\n\t\t\t{ types: [{kind: $.TypeKind.Basic, name: 'number'}], body: (v) => {\n\t\t\t\t$.println(\"testItems[\", i, \"] is int:\", v)\n\t\t\t}},\n\t\t\t{ types: [{kind: $.TypeKind.Basic, name: 'string'}], body: (v) => {\n\t\t\t\t$.println(\"testItems[\", i, \"] is string:\", v)\n\t\t\t}}], () => {\n\t\t\t\t$.println(\"testItems[\", i, \"] is unknown type\")\n\t\t\t})\n\t\t}\n\t}\n\n\t$.println(\"\\n=== Test Complete ===\")\n}\n\n",
    "expectedOutput": "=== Struct Pointer Marking Test ===\n\n--- Scenario 1: Composite Literal vs Value Variable ---\nstruct value -> MyStruct assertion: true\nstruct value -> *MyStruct assertion: false\nstruct pointer -> MyStruct assertion: false\nstruct pointer -> *MyStruct assertion: true\n\n--- Scenario 2: Variable Aliasing ---\noriginal value -> MyStruct assertion: true\noriginal value -> *MyStruct assertion: false\nalias pointer -> MyStruct assertion: false\nalias pointer -> *MyStruct assertion: true\n\n--- Scenario 3: Multiple Pointers to Same Variable ---\nfirst pointer -> *MyStruct assertion: true\nsecond pointer -> *MyStruct assertion: true\nshared modification check: 99\n\n--- Scenario 4: Mixed Assignment Patterns ---\nvariable pointer -> *MyStruct assertion: true\nliteral pointer -> *MyStruct assertion: true\n\n--- Scenario 5: Nested Type Assertions ---\narr[ 0 ] is *MyStruct with value: 70\narr[ 1 ] is MyStruct with value: 80\narr[ 2 ] is *MyStruct with value: 80\n\n--- Scenario 6: Type Switch ---\ntestItems[ 0 ] is MyStruct value: 100\ntestItems[ 1 ] is *MyStruct pointer: 200\ntestItems[ 2 ] is int: 300\ntestItems[ 3 ] is string: string\n\n=== Test Complete ===\n"
  },
  {
    "name": "struct_private_field",
    "goCode": "package main\n\ntype MyStruct struct {\n\tmyPrivate int\n}\n\nfunc main() {\n\tmyStruct := &MyStruct{myPrivate: 4}\n\tmyStruct.myPrivate = 10\n\tprintln(myStruct.myPrivate)\n}\n",
    "tsCode": "// Generated file based on struct_private_field.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get myPrivate(): number {\n\t\treturn this._fields.myPrivate.value\n\t}\n\tpublic set myPrivate(value: number) {\n\t\tthis._fields.myPrivate.value = value\n\t}\n\n\tpublic _fields: {\n\t\tmyPrivate: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{myPrivate?: number}>) {\n\t\tthis._fields = {\n\t\t\tmyPrivate: $.varRef(init?.myPrivate ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tmyPrivate: $.varRef(this._fields.myPrivate.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"myPrivate\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet myStruct = new MyStruct({myPrivate: 4})\n\tmyStruct!.myPrivate = 10\n\t$.println(myStruct!.myPrivate)\n}\n\n",
    "expectedOutput": "10"
  },
  {
    "name": "struct_private_field_ptr",
    "goCode": "package main\n\ntype MyStruct struct {\n\tmyPrivate *int\n}\n\nfunc main() {\n\tmyStruct := &MyStruct{myPrivate: nil}\n\tvar intVar int = 10\n\tmyStruct.myPrivate = &intVar\n\tintVar = 15\n\tprintln(*myStruct.myPrivate)\n}\n",
    "tsCode": "// Generated file based on struct_private_field_ptr.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get myPrivate(): $.VarRef<number> | null {\n\t\treturn this._fields.myPrivate.value\n\t}\n\tpublic set myPrivate(value: $.VarRef<number> | null) {\n\t\tthis._fields.myPrivate.value = value\n\t}\n\n\tpublic _fields: {\n\t\tmyPrivate: $.VarRef<$.VarRef<number> | null>;\n\t}\n\n\tconstructor(init?: Partial<{myPrivate?: $.VarRef<number> | null}>) {\n\t\tthis._fields = {\n\t\t\tmyPrivate: $.varRef(init?.myPrivate ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tmyPrivate: $.varRef(this._fields.myPrivate.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"myPrivate\": { kind: $.TypeKind.Pointer, elemType: { kind: $.TypeKind.Basic, name: \"int\" } }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet myStruct = new MyStruct({myPrivate: null})\n\tlet intVar: $.VarRef<number> = $.varRef(10)\n\tmyStruct!.myPrivate = intVar\n\tintVar!.value = 15\n\t$.println(myStruct!.myPrivate!.value)\n}\n\n",
    "expectedOutput": "15"
  },
  {
    "name": "struct_type_assertion",
    "goCode": "package main\n\nfunc main() {\n\tvar i any = struct {\n\t\tName   string\n\t\tNumber int\n\t}{\"Alice\", 8005553424}\n\n\ts, ok := i.(struct {\n\t\tName   string\n\t\tNumber int\n\t})\n\tif ok {\n\t\tprintln(\"Name:\", s.Name, \"Number:\", s.Number)\n\t} else {\n\t\tprintln(\"Type assertion failed\")\n\t}\n\n\tj, ok2 := i.(struct{ Age int })\n\tif ok2 {\n\t\tprintln(\"Age:\", j.Age)\n\t} else {\n\t\tprintln(\"Second type assertion failed as expected\")\n\t}\n}\n",
    "tsCode": "// Generated file based on struct_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet i: null | any = {Name: \"Alice\", Number: 8005553424}\n\n\tlet { value: s, ok: ok } = $.typeAssert<{ Name?: string; Number?: number }>(i, {kind: $.TypeKind.Struct, fields: {'Name': {kind: $.TypeKind.Basic, name: 'string'}, 'Number': {kind: $.TypeKind.Basic, name: 'number'}}, methods: []})\n\tif (ok) {\n\t\t$.println(\"Name:\", s.Name, \"Number:\", s.Number)\n\t} else {\n\t\t$.println(\"Type assertion failed\")\n\t}\n\n\tlet { value: j, ok: ok2 } = $.typeAssert<{ Age?: number }>(i, {kind: $.TypeKind.Struct, fields: {'Age': {kind: $.TypeKind.Basic, name: 'number'}}, methods: []})\n\tif (ok2) {\n\t\t$.println(\"Age:\", j.Age)\n\t} else {\n\t\t$.println(\"Second type assertion failed as expected\")\n\t}\n}\n\n",
    "expectedOutput": "Name: Alice Number: 8005553424\nSecond type assertion failed as expected"
  },
  {
    "name": "struct_value_init_clone",
    "goCode": "package main\n\ntype Point struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\t// Initialize directly\n\tp1 := Point{X: 1, Y: 2}\n\tprintln(\"p1:\", p1.X, p1.Y)\n\n\t// Assign to another variable (should trigger clone)\n\tp2 := p1\n\tp2.X = 10 // Modify the copy\n\n\t// Print both to show they are independent\n\tprintln(\"p1 after p2 mod:\", p1.X, p1.Y)\n\tprintln(\"p2:\", p2.X, p2.Y)\n\n\t// Initialize via variable assignment\n\tv := Point{X: 3, Y: 4}\n\tp3 := v   // Should trigger clone\n\tp3.Y = 40 // Modify the copy\n\n\tprintln(\"v after p3 mod:\", v.X, v.Y)\n\tprintln(\"p3:\", p3.X, p3.Y)\n}\n",
    "tsCode": "// Generated file based on struct_value_init_clone.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class Point {\n\tpublic get X(): number {\n\t\treturn this._fields.X.value\n\t}\n\tpublic set X(value: number) {\n\t\tthis._fields.X.value = value\n\t}\n\n\tpublic get Y(): number {\n\t\treturn this._fields.Y.value\n\t}\n\tpublic set Y(value: number) {\n\t\tthis._fields.Y.value = value\n\t}\n\n\tpublic _fields: {\n\t\tX: $.VarRef<number>;\n\t\tY: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{X?: number, Y?: number}>) {\n\t\tthis._fields = {\n\t\t\tX: $.varRef(init?.X ?? 0),\n\t\t\tY: $.varRef(init?.Y ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): Point {\n\t\tconst cloned = new Point()\n\t\tcloned._fields = {\n\t\t\tX: $.varRef(this._fields.X.value),\n\t\t\tY: $.varRef(this._fields.Y.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Point',\n\t  new Point(),\n\t  [],\n\t  Point,\n\t  {\"X\": { kind: $.TypeKind.Basic, name: \"int\" }, \"Y\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Initialize directly\n\tlet p1 = $.markAsStructValue(new Point({X: 1, Y: 2}))\n\t$.println(\"p1:\", p1.X, p1.Y)\n\n\t// Assign to another variable (should trigger clone)\n\tlet p2 = $.markAsStructValue(p1.clone())\n\tp2.X = 10 // Modify the copy\n\n\t// Print both to show they are independent\n\t$.println(\"p1 after p2 mod:\", p1.X, p1.Y)\n\t$.println(\"p2:\", p2.X, p2.Y)\n\n\t// Initialize via variable assignment\n\tlet v = $.markAsStructValue(new Point({X: 3, Y: 4}))\n\tlet p3 = $.markAsStructValue(v.clone()) // Should trigger clone\n\tp3.Y = 40 // Modify the copy\n\n\t$.println(\"v after p3 mod:\", v.X, v.Y)\n\t$.println(\"p3:\", p3.X, p3.Y)\n}\n\n",
    "expectedOutput": "p1: 1 2\np1 after p2 mod: 1 2\np2: 10 2\nv after p3 mod: 3 4\np3: 3 40"
  },
  {
    "name": "switch_case_scope",
    "goCode": "package main\n\nfunc main() {\n\tx := 1\n\n\tswitch x {\n\tcase 1:\n\t\ty, z := 10, 20\n\t\tprintln(y + z)\n\tcase 2:\n\t\ty, z := 30, 40\n\t\tprintln(y + z)\n\t}\n\n\tprintln(\"done\")\n}\n",
    "tsCode": "// Generated file based on switch_case_scope.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet x = 1\n\n\tswitch (x) {\n\t\tcase 1: {\n\t\t\tlet [y, z] = [10, 20]\n\t\t\t$.println(y + z)\n\t\t\tbreak\n\t\t}\n\t\tcase 2: {\n\t\t\tlet [y, z] = [30, 40]\n\t\t\t$.println(y + z)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t$.println(\"done\")\n}\n\n",
    "expectedOutput": "30\ndone\n"
  },
  {
    "name": "switch_multi_case",
    "goCode": "package main\n\nfunc main() {\n\tstdNumMonth := 1\n\tstdZeroMonth := 2\n\t// stdLongMonth := 3 // Not used in this specific example but good for context\n\n\tmonth := 0\n\tvalue := \"someValue\"\n\tvar err error\n\n\tgetnum := func(v string, flag bool) (int, string, error) {\n\t\tif flag {\n\t\t\treturn 12, v + \"_processed_flag_true\", nil\n\t\t}\n\t\treturn 1, v + \"_processed_flag_false\", nil\n\t}\n\n\tstd := 2\n\n\tswitch std {\n\tcase stdNumMonth, stdZeroMonth:\n\t\tmonth, value, err = getnum(value, std == stdZeroMonth)\n\t\tif err != nil {\n\t\t\tprintln(\"Error:\", err.Error())\n\t\t}\n\t\tprintln(\"Month:\", month, \"Value:\", value)\n\tcase 3:\n\t\tprintln(\"Std is 3\")\n\tdefault:\n\t\tprintln(\"Default case\")\n\t}\n\n\tstd = 1\n\tswitch std {\n\tcase stdNumMonth, stdZeroMonth:\n\t\tmonth, value, err = getnum(value, std == stdZeroMonth)\n\t\tif err != nil {\n\t\t\tprintln(\"Error:\", err.Error())\n\t\t}\n\t\tprintln(\"Month:\", month, \"Value:\", value)\n\tcase 3:\n\t\tprintln(\"Std is 3\")\n\tdefault:\n\t\tprintln(\"Default case\")\n\t}\n}\n",
    "tsCode": "// Generated file based on switch_multi_case.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet stdNumMonth = 1\n\n\t// stdLongMonth := 3 // Not used in this specific example but good for context\n\tlet stdZeroMonth = 2\n\n\tlet month = 0\n\tlet value = \"someValue\"\n\tlet err: $.GoError = null\n\n\tlet getnum = (v: string, flag: boolean): [number, string, $.GoError] => {\n\t\tif (flag) {\n\t\t\treturn [12, v + \"_processed_flag_true\", null]\n\t\t}\n\t\treturn [1, v + \"_processed_flag_false\", null]\n\t}\n\n\tlet std = 2\n\n\tswitch (std) {\n\t\tcase stdNumMonth:\n\t\tcase stdZeroMonth: {\n\t\t\t;[month, value, err] = getnum!(value, std == stdZeroMonth)\n\t\t\tif (err != null) {\n\t\t\t\t$.println(\"Error:\", err!.Error())\n\t\t\t}\n\t\t\t$.println(\"Month:\", month, \"Value:\", value)\n\t\t\tbreak\n\t\t}\n\t\tcase 3: {\n\t\t\t$.println(\"Std is 3\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"Default case\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\tstd = 1\n\tswitch (std) {\n\t\tcase stdNumMonth:\n\t\tcase stdZeroMonth: {\n\t\t\t;[month, value, err] = getnum!(value, std == stdZeroMonth)\n\t\t\tif (err != null) {\n\t\t\t\t$.println(\"Error:\", err!.Error())\n\t\t\t}\n\t\t\t$.println(\"Month:\", month, \"Value:\", value)\n\t\t\tbreak\n\t\t}\n\t\tcase 3: {\n\t\t\t$.println(\"Std is 3\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"Default case\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Month: 12 Value: someValue_processed_flag_true\nMonth: 1 Value: someValue_processed_flag_true_processed_flag_false\n"
  },
  {
    "name": "switch_statement",
    "goCode": "package main\n\nfunc main() {\n\ti := 2\n\tprintln(\"Integer switch:\")\n\tswitch i {\n\tcase 1:\n\t\tprintln(\"one\")\n\tcase 2:\n\t\tprintln(\"two\")\n\tcase 3:\n\t\tprintln(\"three\")\n\tdefault:\n\t\tprintln(\"other integer\")\n\t}\n\n\ts := \"hello\"\n\tprintln(\"\\nString switch:\")\n\tswitch s {\n\tcase \"world\":\n\t\tprintln(\"world\")\n\tcase \"hello\":\n\t\tprintln(\"hello\")\n\tdefault:\n\t\tprintln(\"other string\")\n\t}\n\tx := -5\n\tprintln(\"\\nSwitch without expression:\")\n\tswitch {\n\tcase x < 0:\n\t\tprintln(\"negative\")\n\tcase x == 0:\n\t\tprintln(\"zero\")\n\tdefault: // x > 0\n\t\tprintln(\"positive\")\n\t}\n\n\tx = 0\n\tprintln(\"\\nSwitch without expression (zero):\")\n\tswitch {\n\tcase x < 0:\n\t\tprintln(\"negative\")\n\tcase x == 0:\n\t\tprintln(\"zero\")\n\tdefault: // x > 0\n\t\tprintln(\"positive\")\n\t}\n\n\tx = 10\n\tprintln(\"\\nSwitch without expression (positive):\")\n\tswitch {\n\tcase x < 0:\n\t\tprintln(\"negative\")\n\tcase x == 0:\n\t\tprintln(\"zero\")\n\tdefault: // x > 0\n\t\tprintln(\"positive\")\n\t}\n}\n",
    "tsCode": "// Generated file based on switch_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet i = 2\n\t$.println(\"Integer switch:\")\n\tswitch (i) {\n\t\tcase 1: {\n\t\t\t$.println(\"one\")\n\t\t\tbreak\n\t\t}\n\t\tcase 2: {\n\t\t\t$.println(\"two\")\n\t\t\tbreak\n\t\t}\n\t\tcase 3: {\n\t\t\t$.println(\"three\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"other integer\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\tlet s = \"hello\"\n\t$.println(\"\\nString switch:\")\n\tswitch (s) {\n\t\tcase \"world\": {\n\t\t\t$.println(\"world\")\n\t\t\tbreak\n\t\t}\n\t\tcase \"hello\": {\n\t\t\t$.println(\"hello\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"other string\")\n\t\t\tbreak\n\t\t}\n\t}\n\tlet x = -5\n\t$.println(\"\\nSwitch without expression:\")\n\n\t// x > 0\n\tswitch (true) {\n\t\tcase x < 0: {\n\t\t\t$.println(\"negative\")\n\t\t\tbreak\n\t\t}\n\t\tcase x == 0: {\n\t\t\t$.println(\"zero\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"positive\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\tx = 0\n\t$.println(\"\\nSwitch without expression (zero):\")\n\n\t// x > 0\n\tswitch (true) {\n\t\tcase x < 0: {\n\t\t\t$.println(\"negative\")\n\t\t\tbreak\n\t\t}\n\t\tcase x == 0: {\n\t\t\t$.println(\"zero\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"positive\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\tx = 10\n\t$.println(\"\\nSwitch without expression (positive):\")\n\n\t// x > 0\n\tswitch (true) {\n\t\tcase x < 0: {\n\t\t\t$.println(\"negative\")\n\t\t\tbreak\n\t\t}\n\t\tcase x == 0: {\n\t\t\t$.println(\"zero\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"positive\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Integer switch:\ntwo\n\nString switch:\nhello\n\nSwitch without expression:\nnegative\n\nSwitch without expression (zero):\nzero\n\nSwitch without expression (positive):\npositive"
  },
  {
    "name": "time_format_ext",
    "goCode": "package main\n\nimport \"time\"\n\nfunc main() {\n\t// Fixed time with a specific offset and nanoseconds\n\tlocPDT := time.FixedZone(\"PDT\", -7*60*60) // -07:00\n\tt1 := time.Date(2025, time.May, 25, 17, 42, 56, 123456789, locPDT)\n\n\tprintln(\"--- Specific Time (2025-05-25 17:42:56.123456789 -0700 PDT) ---\")\n\t// Timezone patterns\n\tprintln(\"Layout Z07:00  -> \" + t1.Format(\"2006-01-02 15:04:05 Z07:00\"))\n\tprintln(\"Layout -07:00  -> \" + t1.Format(\"2006-01-02 15:04:05 -07:00\"))\n\tprintln(\"Layout -0700   -> \" + t1.Format(\"2006-01-02 15:04:05 -0700\"))\n\tprintln(\"Layout -07     -> \" + t1.Format(\"2006-01-02 15:04:05 -07\"))\n\tprintln(\"Layout Z       -> \" + t1.Format(\"2006-01-02 15:04:05 Z\"))\n\tprintln(\"Layout MST     -> \" + t1.Format(\"2006-01-02 15:04:05 MST\")) // Go: -0700 (since not MST zone), TS: MST (literal)\n\n\t// Nanosecond patterns (fixed)\n\tprintln(\"Layout .000000000 -> \" + t1.Format(\"15:04:05.000000000\"))\n\tprintln(\"Layout .000000   -> \" + t1.Format(\"15:04:05.000000\"))\n\tprintln(\"Layout .000      -> \" + t1.Format(\"15:04:05.000\"))\n\n\t// Nanosecond patterns (trimming)\n\tprintln(\"Layout .999999999 -> \" + t1.Format(\"15:04:05.999999999\"))\n\tprintln(\"Layout .999999   -> \" + t1.Format(\"15:04:05.999999\"))\n\tprintln(\"Layout .999      -> \" + t1.Format(\"15:04:05.999\"))\n\n\t// Combined layout\n\tprintln(\"Layout Combined  -> \" + t1.Format(\"Mon Jan _2 15:04:05.999999999 Z07:00 2006\"))\n\n\t// Fixed time with zero nanoseconds for trimming tests\n\tlocPST := time.FixedZone(\"PST\", -8*60*60) // -08:00\n\tt2 := time.Date(2025, time.May, 25, 17, 42, 56, 0, locPST)\n\tprintln(\"--- Specific Time (2025-05-25 17:42:56.000 -0800 PST) ---\")\n\tprintln(\"Layout .999 (zero ns) -> \" + t2.Format(\"15:04:05.999\"))\n\tprintln(\"Layout .000 (zero ns) -> \" + t2.Format(\"15:04:05.000\"))\n\n\t// Fixed UTC time for Z and Z07:00 patterns\n\tt3 := time.Date(2025, time.May, 25, 17, 42, 56, 123456789, time.UTC)\n\tprintln(\"--- UTC Time (2025-05-25 17:42:56.123456789 Z) ---\")\n\tprintln(\"Layout Z07:00 (UTC) -> \" + t3.Format(\"2006-01-02 15:04:05 Z07:00\"))\n\tprintln(\"Layout Z (UTC)      -> \" + t3.Format(\"2006-01-02 15:04:05 Z\"))\n\tprintln(\"Layout -07:00 (UTC) -> \" + t3.Format(\"2006-01-02 15:04:05 -07:00\"))\n\tprintln(\"Layout MST (UTC)    -> \" + t3.Format(\"2006-01-02 15:04:05 MST\")) // Go: +0000, TS: MST\n}\n",
    "tsCode": "// Generated file based on time_format_ext.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as time from \"@goscript/time/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Fixed time with a specific offset and nanoseconds\n\tlet locPDT = time.FixedZone(\"PDT\", -7 * 60 * 60) // -07:00\n\tlet t1 = $.markAsStructValue(time.Date(2025, time.May, 25, 17, 42, 56, 123456789, locPDT).clone())\n\n\t$.println(\"--- Specific Time (2025-05-25 17:42:56.123456789 -0700 PDT) ---\")\n\t// Timezone patterns\n\t$.println(\"Layout Z07:00  -> \" + t1.Format(\"2006-01-02 15:04:05 Z07:00\"))\n\t$.println(\"Layout -07:00  -> \" + t1.Format(\"2006-01-02 15:04:05 -07:00\"))\n\t$.println(\"Layout -0700   -> \" + t1.Format(\"2006-01-02 15:04:05 -0700\"))\n\t$.println(\"Layout -07     -> \" + t1.Format(\"2006-01-02 15:04:05 -07\"))\n\t$.println(\"Layout Z       -> \" + t1.Format(\"2006-01-02 15:04:05 Z\"))\n\t$.println(\"Layout MST     -> \" + t1.Format(\"2006-01-02 15:04:05 MST\")) // Go: -0700 (since not MST zone), TS: MST (literal)\n\n\t// Nanosecond patterns (fixed)\n\t$.println(\"Layout .000000000 -> \" + t1.Format(\"15:04:05.000000000\"))\n\t$.println(\"Layout .000000   -> \" + t1.Format(\"15:04:05.000000\"))\n\t$.println(\"Layout .000      -> \" + t1.Format(\"15:04:05.000\"))\n\n\t// Nanosecond patterns (trimming)\n\t$.println(\"Layout .999999999 -> \" + t1.Format(\"15:04:05.999999999\"))\n\t$.println(\"Layout .999999   -> \" + t1.Format(\"15:04:05.999999\"))\n\t$.println(\"Layout .999      -> \" + t1.Format(\"15:04:05.999\"))\n\n\t// Combined layout\n\t$.println(\"Layout Combined  -> \" + t1.Format(\"Mon Jan _2 15:04:05.999999999 Z07:00 2006\"))\n\n\t// Fixed time with zero nanoseconds for trimming tests\n\tlet locPST = time.FixedZone(\"PST\", -8 * 60 * 60) // -08:00\n\tlet t2 = $.markAsStructValue(time.Date(2025, time.May, 25, 17, 42, 56, 0, locPST).clone())\n\t$.println(\"--- Specific Time (2025-05-25 17:42:56.000 -0800 PST) ---\")\n\t$.println(\"Layout .999 (zero ns) -> \" + t2.Format(\"15:04:05.999\"))\n\t$.println(\"Layout .000 (zero ns) -> \" + t2.Format(\"15:04:05.000\"))\n\n\t// Fixed UTC time for Z and Z07:00 patterns\n\tlet t3 = $.markAsStructValue(time.Date(2025, time.May, 25, 17, 42, 56, 123456789, time.UTC).clone())\n\t$.println(\"--- UTC Time (2025-05-25 17:42:56.123456789 Z) ---\")\n\t$.println(\"Layout Z07:00 (UTC) -> \" + t3.Format(\"2006-01-02 15:04:05 Z07:00\"))\n\t$.println(\"Layout Z (UTC)      -> \" + t3.Format(\"2006-01-02 15:04:05 Z\"))\n\t$.println(\"Layout -07:00 (UTC) -> \" + t3.Format(\"2006-01-02 15:04:05 -07:00\"))\n\t$.println(\"Layout MST (UTC)    -> \" + t3.Format(\"2006-01-02 15:04:05 MST\")) // Go: +0000, TS: MST\n}\n\n",
    "expectedOutput": "--- Specific Time (2025-05-25 17:42:56.123456789 -0700 PDT) ---\nLayout Z07:00  -> 2025-05-25 17:42:56 -07:00\nLayout -07:00  -> 2025-05-25 17:42:56 -07:00\nLayout -0700   -> 2025-05-25 17:42:56 -0700\nLayout -07     -> 2025-05-25 17:42:56 -07\nLayout Z       -> 2025-05-25 17:42:56 Z\nLayout MST     -> 2025-05-25 17:42:56 PDT\nLayout .000000000 -> 17:42:56.123456789\nLayout .000000   -> 17:42:56.123456\nLayout .000      -> 17:42:56.123\nLayout .999999999 -> 17:42:56.123456789\nLayout .999999   -> 17:42:56.123456\nLayout .999      -> 17:42:56.123\nLayout Combined  -> Sun May 25 17:42:56.123456789 -07:00 2025\n--- Specific Time (2025-05-25 17:42:56.000 -0800 PST) ---\nLayout .999 (zero ns) -> 17:42:56\nLayout .000 (zero ns) -> 17:42:56.000\n--- UTC Time (2025-05-25 17:42:56.123456789 Z) ---\nLayout Z07:00 (UTC) -> 2025-05-25 17:42:56 Z\nLayout Z (UTC)      -> 2025-05-25 17:42:56 Z\nLayout -07:00 (UTC) -> 2025-05-25 17:42:56 +00:00\nLayout MST (UTC)    -> 2025-05-25 17:42:56 UTC\n"
  },
  {
    "name": "type_assertion_duplicate_vars",
    "goCode": "package main\n\ntype Interface interface {\n\tMethod() string\n}\n\ntype ConcreteA struct{}\n\nfunc (c ConcreteA) Method() string { return \"A\" }\n\ntype ConcreteB struct{}\n\nfunc (c ConcreteB) Method() string { return \"B\" }\n\ntype Container struct {\n\thasA bool\n\thasB bool\n}\n\nfunc main() {\n\tvar iface Interface = ConcreteA{}\n\n\tc := &Container{}\n\n\t// Multiple type assertions that should generate unique variable names\n\t_, c.hasA = iface.(ConcreteA)\n\t_, c.hasB = iface.(ConcreteB)\n\n\tprintln(\"hasA:\", c.hasA)\n\tprintln(\"hasB:\", c.hasB)\n}\n",
    "tsCode": "// Generated file based on type_assertion_duplicate_vars.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class ConcreteA {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): ConcreteA {\n\t\tconst cloned = new ConcreteA()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Method(): string {\n\t\treturn \"A\"\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.ConcreteA',\n\t  new ConcreteA(),\n\t  [{ name: \"Method\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  ConcreteA,\n\t  {}\n\t);\n}\n\nexport class ConcreteB {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): ConcreteB {\n\t\tconst cloned = new ConcreteB()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Method(): string {\n\t\treturn \"B\"\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.ConcreteB',\n\t  new ConcreteB(),\n\t  [{ name: \"Method\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  ConcreteB,\n\t  {}\n\t);\n}\n\nexport class Container {\n\tpublic get hasA(): boolean {\n\t\treturn this._fields.hasA.value\n\t}\n\tpublic set hasA(value: boolean) {\n\t\tthis._fields.hasA.value = value\n\t}\n\n\tpublic get hasB(): boolean {\n\t\treturn this._fields.hasB.value\n\t}\n\tpublic set hasB(value: boolean) {\n\t\tthis._fields.hasB.value = value\n\t}\n\n\tpublic _fields: {\n\t\thasA: $.VarRef<boolean>;\n\t\thasB: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{hasA?: boolean, hasB?: boolean}>) {\n\t\tthis._fields = {\n\t\t\thasA: $.varRef(init?.hasA ?? false),\n\t\t\thasB: $.varRef(init?.hasB ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): Container {\n\t\tconst cloned = new Container()\n\t\tcloned._fields = {\n\t\t\thasA: $.varRef(this._fields.hasA.value),\n\t\t\thasB: $.varRef(this._fields.hasB.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Container',\n\t  new Container(),\n\t  [],\n\t  Container,\n\t  {\"hasA\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"hasB\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\nexport type Interface = null | {\n\tMethod(): string\n}\n\n$.registerInterfaceType(\n  'main.Interface',\n  null, // Zero value for interface is null\n  [{ name: \"Method\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport async function main(): Promise<void> {\n\tlet iface: Interface = $.markAsStructValue(new ConcreteA({}))\n\n\tlet c = new Container({})\n\n\t// Multiple type assertions that should generate unique variable names\n\tlet _gs_ta_val_66a6: ConcreteA\n\tlet _gs_ta_ok_66a6: boolean\n\t({ value: _gs_ta_val_66a6, ok: _gs_ta_ok_66a6 } = $.typeAssert<ConcreteA>(iface, 'main.ConcreteA'))\n\tc!.hasA = _gs_ta_ok_66a6\n\tlet _gs_ta_val_a813: ConcreteB\n\tlet _gs_ta_ok_a813: boolean\n\t({ value: _gs_ta_val_a813, ok: _gs_ta_ok_a813 } = $.typeAssert<ConcreteB>(iface, 'main.ConcreteB'))\n\tc!.hasB = _gs_ta_ok_a813\n\n\t$.println(\"hasA:\", c!.hasA)\n\t$.println(\"hasB:\", c!.hasB)\n}\n\n",
    "expectedOutput": "hasA: true\nhasB: false\n"
  },
  {
    "name": "type_conversion_interface_ptr_nil",
    "goCode": "package main\n\nimport \"reflect\"\n\ntype Stringer interface {\n\tString() string\n}\n\nfunc main() {\n\t// Create a typed nil pointer to interface\n\tvar nilPtr *Stringer = (*Stringer)(nil)\n\n\t// Get the type\n\tt := reflect.TypeOf(nilPtr)\n\tprintln(\"Type:\", t.String())\n\tprintln(\"Kind:\", t.Kind())\n\n\t// Get the element type (the interface type itself)\n\telem := t.Elem()\n\tprintln(\"Elem Type:\", elem.String())\n\tprintln(\"Elem Kind:\", elem.Kind())\n}\n",
    "tsCode": "// Generated file based on type_conversion_interface_ptr_nil.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as reflect from \"@goscript/reflect/index.js\"\n\nexport type Stringer = null | {\n\tString(): string\n}\n\n$.registerInterfaceType(\n  'main.Stringer',\n  null, // Zero value for interface is null\n  [{ name: \"String\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport async function main(): Promise<void> {\n\t// Create a typed nil pointer to interface\n\tlet nilPtr: Stringer | null = $.typedNil(\"*main.Stringer\")\n\n\t// Get the type\n\tlet t = reflect.TypeOf(nilPtr)\n\t$.println(\"Type:\", t!.String())\n\t$.println(\"Kind:\", t!.Kind())\n\n\t// Get the element type (the interface type itself)\n\tlet elem = t!.Elem()\n\t$.println(\"Elem Type:\", elem!.String())\n\t$.println(\"Elem Kind:\", elem!.Kind())\n}\n\n",
    "expectedOutput": "Type: *main.Stringer\nKind: 22\nElem Type: main.Stringer\nElem Kind: 20\n"
  },
  {
    "name": "type_declaration_receiver",
    "goCode": "package main\n\ntype FileMode int\n\n// String returns a string representation of the FileMode\nfunc (fm FileMode) String() string {\n\tif fm == 0 {\n\t\treturn \"none\"\n\t}\n\treturn \"some\"\n}\n\n// IsZero checks if the FileMode is zero\nfunc (fm FileMode) IsZero() bool {\n\treturn fm == 0\n}\n\n// Add adds a value to the FileMode\nfunc (fm FileMode) Add(val int) FileMode {\n\treturn FileMode(int(fm) + val)\n}\n\ntype CustomString string\n\n// Length returns the length of the custom string\nfunc (cs CustomString) Length() int {\n\treturn len(string(cs))\n}\n\n// Upper converts to uppercase\nfunc (cs CustomString) Upper() string {\n\ts := string(cs)\n\tresult := \"\"\n\tfor _, r := range s {\n\t\tif r >= 'a' && r <= 'z' {\n\t\t\tresult += string(r - 32)\n\t\t} else {\n\t\t\tresult += string(r)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\t// Test FileMode type with receiver methods\n\tvar fm FileMode = 0\n\tprintln(\"FileMode(0).String():\", fm.String())\n\tprintln(\"FileMode(0).IsZero():\", fm.IsZero())\n\n\t// Test method calls on type conversion\n\tprintln(\"FileMode(5).String():\", FileMode(5).String())\n\tprintln(\"FileMode(5).IsZero():\", FileMode(5).IsZero())\n\n\t// Test method chaining\n\tresult := FileMode(3).Add(2)\n\tprintln(\"FileMode(3).Add(2):\", int(result))\n\tprintln(\"FileMode(3).Add(2).String():\", result.String())\n\n\t// Test CustomString type\n\tvar cs CustomString = \"hello\"\n\tprintln(\"CustomString(\\\"hello\\\").Length():\", cs.Length())\n\tprintln(\"CustomString(\\\"hello\\\").Upper():\", cs.Upper())\n\n\t// Test method calls on type conversion\n\tprintln(\"CustomString(\\\"world\\\").Length():\", CustomString(\"world\").Length())\n\tprintln(\"CustomString(\\\"world\\\").Upper():\", CustomString(\"world\").Upper())\n}\n",
    "tsCode": "// Generated file based on type_declaration_receiver.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type CustomString = string;\n\nexport function CustomString_Length(cs: CustomString): number {\n\treturn $.len(cs)\n}\n\nexport function CustomString_Upper(cs: CustomString): string {\n\tlet s = cs\n\tlet result = \"\"\n\t{\n\t\tconst _runes = $.stringToRunes(s)\n\t\tfor (let i = 0; i < _runes.length; i++) {\n\t\t\tlet r = _runes[i]\n\t\t\t{\n\t\t\t\tif (r >= 97 && r <= 122) {\n\t\t\t\t\tresult += $.runeOrStringToString(r - 32)\n\t\t\t\t} else {\n\t\t\t\t\tresult += $.runeOrStringToString(r)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n\nexport type FileMode = number;\n\nexport function FileMode_String(fm: FileMode): string {\n\tif (fm == 0) {\n\t\treturn \"none\"\n\t}\n\treturn \"some\"\n}\n\nexport function FileMode_IsZero(fm: FileMode): boolean {\n\treturn fm == 0\n}\n\nexport function FileMode_Add(fm: FileMode, val: number): FileMode {\n\treturn (fm + val as FileMode)\n}\n\n\nexport async function main(): Promise<void> {\n\t// Test FileMode type with receiver methods\n\tlet fm: FileMode = 0\n\t$.println(\"FileMode(0).String():\", FileMode_String(fm))\n\t$.println(\"FileMode(0).IsZero():\", FileMode_IsZero(fm))\n\n\t// Test method calls on type conversion\n\t$.println(\"FileMode(5).String():\", FileMode_String((5 as FileMode)))\n\t$.println(\"FileMode(5).IsZero():\", FileMode_IsZero((5 as FileMode)))\n\n\t// Test method chaining\n\tlet result = FileMode_Add((3 as FileMode), 2)\n\t$.println(\"FileMode(3).Add(2):\", result)\n\t$.println(\"FileMode(3).Add(2).String():\", FileMode_String(result))\n\n\t// Test CustomString type\n\tlet cs: CustomString = \"hello\"\n\t$.println(\"CustomString(\\\"hello\\\").Length():\", CustomString_Length(cs))\n\t$.println(\"CustomString(\\\"hello\\\").Upper():\", CustomString_Upper(cs))\n\n\t// Test method calls on type conversion\n\t$.println(\"CustomString(\\\"world\\\").Length():\", CustomString_Length((\"world\" as CustomString)))\n\t$.println(\"CustomString(\\\"world\\\").Upper():\", CustomString_Upper((\"world\" as CustomString)))\n}\n\n",
    "expectedOutput": "FileMode(0).String(): none\nFileMode(0).IsZero(): true\nFileMode(5).String(): some\nFileMode(5).IsZero(): false\nFileMode(3).Add(2): 5\nFileMode(3).Add(2).String(): some\nCustomString(\"hello\").Length(): 5\nCustomString(\"hello\").Upper(): HELLO\nCustomString(\"world\").Length(): 5\nCustomString(\"world\").Upper(): WORLD\n"
  },
  {
    "name": "type_method_primitive",
    "goCode": "package main\n\n// Test that primitive type aliases with methods work correctly\ntype MyInt int\n\nfunc (m MyInt) Double() int {\n\treturn int(m) * 2\n}\n\nfunc main() {\n\t// Test direct method call on type conversion\n\tresult := MyInt(5).Double()\n\tprintln(\"Direct call:\", result)\n\n\t// Test storing method reference (this is the failing case)\n\tfn := MyInt(10).Double\n\tprintln(\"Method ref call:\", fn())\n}\n",
    "tsCode": "// Generated file based on type_method_primitive.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyInt = number;\n\nexport function MyInt_Double(m: MyInt): number {\n\treturn m * 2\n}\n\n\nexport async function main(): Promise<void> {\n\t// Test direct method call on type conversion\n\tlet result = MyInt_Double((5 as MyInt))\n\t$.println(\"Direct call:\", result)\n\n\t// Test storing method reference (this is the failing case)\n\tlet fn = (() => MyInt_Double((10 as MyInt)))\n\t$.println(\"Method ref call:\", fn!())\n}\n\n",
    "expectedOutput": "Direct call: 10\nMethod ref call: 20\n"
  },
  {
    "name": "type_missing_imports",
    "goCode": "package main\n\n// memory.go file content (simulated in same file for test)\ntype file struct {\n\tname string\n\tdata []byte\n}\n\n// storage.go file content\ntype storage struct {\n\tfiles    map[string]*file\n\tchildren map[string]map[string]*file\n}\n\nfunc main() {\n\ts := storage{\n\t\tfiles:    make(map[string]*file),\n\t\tchildren: make(map[string]map[string]*file),\n\t}\n\n\tf := &file{\n\t\tname: \"test.txt\",\n\t\tdata: []byte(\"hello world\"),\n\t}\n\n\ts.files[\"test\"] = f\n\n\tprintln(\"Created storage with file:\", s.files[\"test\"].name)\n}\n",
    "tsCode": "// Generated file based on type_missing_imports.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class file {\n\tpublic get name(): string {\n\t\treturn this._fields.name.value\n\t}\n\tpublic set name(value: string) {\n\t\tthis._fields.name.value = value\n\t}\n\n\tpublic get data(): $.Bytes {\n\t\treturn this._fields.data.value\n\t}\n\tpublic set data(value: $.Bytes) {\n\t\tthis._fields.data.value = value\n\t}\n\n\tpublic _fields: {\n\t\tname: $.VarRef<string>;\n\t\tdata: $.VarRef<$.Bytes>;\n\t}\n\n\tconstructor(init?: Partial<{data?: $.Bytes, name?: string}>) {\n\t\tthis._fields = {\n\t\t\tname: $.varRef(init?.name ?? \"\"),\n\t\t\tdata: $.varRef(init?.data ?? new Uint8Array(0))\n\t\t}\n\t}\n\n\tpublic clone(): file {\n\t\tconst cloned = new file()\n\t\tcloned._fields = {\n\t\t\tname: $.varRef(this._fields.name.value),\n\t\t\tdata: $.varRef(this._fields.data.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.file',\n\t  new file(),\n\t  [],\n\t  file,\n\t  {\"name\": { kind: $.TypeKind.Basic, name: \"string\" }, \"data\": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } }}\n\t);\n}\n\nexport class storage {\n\tpublic get files(): Map<string, file | null> | null {\n\t\treturn this._fields.files.value\n\t}\n\tpublic set files(value: Map<string, file | null> | null) {\n\t\tthis._fields.files.value = value\n\t}\n\n\tpublic get children(): Map<string, Map<string, file | null> | null> | null {\n\t\treturn this._fields.children.value\n\t}\n\tpublic set children(value: Map<string, Map<string, file | null> | null> | null) {\n\t\tthis._fields.children.value = value\n\t}\n\n\tpublic _fields: {\n\t\tfiles: $.VarRef<Map<string, file | null> | null>;\n\t\tchildren: $.VarRef<Map<string, Map<string, file | null> | null> | null>;\n\t}\n\n\tconstructor(init?: Partial<{children?: Map<string, Map<string, file | null> | null> | null, files?: Map<string, file | null> | null}>) {\n\t\tthis._fields = {\n\t\t\tfiles: $.varRef(init?.files ?? null),\n\t\t\tchildren: $.varRef(init?.children ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): storage {\n\t\tconst cloned = new storage()\n\t\tcloned._fields = {\n\t\t\tfiles: $.varRef(this._fields.files.value),\n\t\t\tchildren: $.varRef(this._fields.children.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.storage',\n\t  new storage(),\n\t  [],\n\t  storage,\n\t  {\"files\": { kind: $.TypeKind.Map, keyType: { kind: $.TypeKind.Basic, name: \"string\" }, elemType: { kind: $.TypeKind.Pointer, elemType: \"file\" } }, \"children\": { kind: $.TypeKind.Map, keyType: { kind: $.TypeKind.Basic, name: \"string\" }, elemType: { kind: $.TypeKind.Map, keyType: { kind: $.TypeKind.Basic, name: \"string\" }, elemType: { kind: $.TypeKind.Pointer, elemType: \"file\" } } }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet s = $.markAsStructValue(new storage({children: $.makeMap<string, Map<string, file | null> | null>(), files: $.makeMap<string, file | null>()}))\n\n\tlet f = new file({data: $.stringToBytes(\"hello world\"), name: \"test.txt\"})\n\n\t$.mapSet(s.files, \"test\", f)\n\n\t$.println(\"Created storage with file:\", $.mapGet(s.files, \"test\", null)[0]!.name)\n}\n\n",
    "expectedOutput": "Created storage with file: test.txt\n"
  },
  {
    "name": "type_separate_files",
    "goCode": "package main\n\nfunc main() {\n\ts := storage{\n\t\tfiles:    make(map[string]*file),\n\t\tchildren: make(map[string]map[string]*file),\n\t}\n\n\tf := &file{\n\t\tname: \"test.txt\",\n\t\tdata: []byte(\"hello world\"),\n\t}\n\n\ts.files[\"test\"] = f\n\n\tprintln(\"Created storage with file:\", s.files[\"test\"].name)\n}\n",
    "tsCode": "// Generated file based on type_separate_files.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\nimport { file } from \"./memory.gs.js\";\nimport { storage } from \"./storage.gs.js\";\n\nexport async function main(): Promise<void> {\n\tlet s = $.markAsStructValue(new storage({children: $.makeMap<string, Map<string, file | null> | null>(), files: $.makeMap<string, file | null>()}))\n\n\tlet f = new file({data: $.stringToBytes(\"hello world\"), name: \"test.txt\"})\n\n\t$.mapSet(s.files, \"test\", f)\n\n\t$.println(\"Created storage with file:\", $.mapGet(s.files, \"test\", null)[0]!.name)\n}\n\n",
    "expectedOutput": "Created storage with file: test.txt\n"
  },
  {
    "name": "type_switch_statement",
    "goCode": "package main\n\nfunc main() {\n\t// Basic type switch with variable and default case\n\tvar i interface{} = \"hello\"\n\tswitch v := i.(type) {\n\tcase int:\n\t\tprintln(\"int\", v)\n\tcase string:\n\t\tprintln(\"string\", v)\n\tdefault:\n\t\tprintln(\"unknown\")\n\t}\n\n\t// Type switch without variable\n\tvar x interface{} = 123\n\tswitch x.(type) {\n\tcase bool:\n\t\tprintln(\"bool\")\n\tcase int:\n\t\tprintln(\"int\")\n\t}\n\n\t// Type switch with multiple types in a case\n\tvar y interface{} = true\n\tswitch v := y.(type) {\n\tcase int, float64:\n\t\tprintln(\"number\", v)\n\tcase string, bool:\n\t\tprintln(\"string or bool\", v)\n\t}\n\n\t// Type switch with initialization statement\n\tswitch z := getInterface(); v := z.(type) {\n\tcase int:\n\t\tprintln(\"z is int\", v)\n\t}\n\n\t// Default-only type switch\n\tvar w interface{} = \"test\"\n\tswitch w.(type) {\n\tdefault:\n\t\tprintln(\"default only\")\n\t}\n\tswitch w.(type) {\n\tdefault:\n\t\tprintln(\"default only, value is\", w.(string))\n\t}\n}\n\nfunc getInterface() interface{} {\n\treturn 42\n}\n",
    "tsCode": "// Generated file based on type_switch_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Basic type switch with variable and default case\n\tlet i: null | any = \"hello\"\n\t$.typeSwitch(i, [{ types: [{kind: $.TypeKind.Basic, name: 'number'}], body: (v) => {\n\t\t$.println(\"int\", v)\n\t}},\n\t{ types: [{kind: $.TypeKind.Basic, name: 'string'}], body: (v) => {\n\t\t$.println(\"string\", v)\n\t}}], () => {\n\t\t$.println(\"unknown\")\n\t})\n\n\t// Type switch without variable\n\tlet x: null | any = 123\n\t$.typeSwitch(x, [{ types: [{kind: $.TypeKind.Basic, name: 'boolean'}], body: () => {\n\t\t$.println(\"bool\")\n\t}},\n\t{ types: [{kind: $.TypeKind.Basic, name: 'number'}], body: () => {\n\t\t$.println(\"int\")\n\t}}])\n\n\t// Type switch with multiple types in a case\n\tlet y: null | any = true\n\t$.typeSwitch(y, [{ types: [{kind: $.TypeKind.Basic, name: 'number'}, {kind: $.TypeKind.Basic, name: 'number'}], body: (v) => {\n\t\t$.println(\"number\", v)\n\t}},\n\t{ types: [{kind: $.TypeKind.Basic, name: 'string'}, {kind: $.TypeKind.Basic, name: 'boolean'}], body: (v) => {\n\t\t$.println(\"string or bool\", v)\n\t}}])\n\n\t// Type switch with initialization statement\n\t{\n\t\tlet z = getInterface()\n\t\t$.typeSwitch(z, [{ types: [{kind: $.TypeKind.Basic, name: 'number'}], body: (v) => {\n\t\t\t$.println(\"z is int\", v)\n\t\t}}])\n\t}\n\n\t// Default-only type switch\n\tlet w: null | any = \"test\"\n\t$.typeSwitch(w, [], () => {\n\t\t$.println(\"default only\")\n\t})\n\t$.typeSwitch(w, [], () => {\n\t\t$.println(\"default only, value is\", $.mustTypeAssert<string>(w, {kind: $.TypeKind.Basic, name: 'string'}))\n\t})\n}\n\nexport function getInterface(): null | any {\n\treturn 42\n}\n\n",
    "expectedOutput": "string hello\nint\nstring or bool true\nz is int 42\ndefault only\ndefault only, value is test"
  },
  {
    "name": "undefined_type_error",
    "goCode": "package main\n\n// Test case that replicates the undefined type error\n// The issue: fmt: $.VarRef<fmt>; where fmt type is undefined\n\n// This should generate a proper type reference, not an undefined fmt type\ntype formatter struct {\n\twid         int  //nolint:unused\n\tprec        int  //nolint:unused\n\twidPresent  bool //nolint:unused\n\tprecPresent bool //nolint:unused\n\tminus       bool\n\tplus        bool\n\tsharp       bool //nolint:unused\n\tspace       bool //nolint:unused\n\tzero        bool //nolint:unused\n\tplusV       bool //nolint:unused\n\tsharpV      bool //nolint:unused\n}\n\ntype printer struct {\n\tbuf []byte      //nolint:unused\n\targ interface{} //nolint:unused\n\t// This line causes the issue: fmt: $.VarRef<fmt>; where fmt is undefined\n\t// Should generate proper type reference\n\tfmt formatter\n}\n\nfunc (p *printer) init() {\n\tp.fmt = formatter{}\n}\n\nfunc (p *printer) format(verb rune) {\n\t// Use the formatter\n\tif p.fmt.minus {\n\t\tprintln(\"minus flag set\")\n\t}\n\tif p.fmt.plus {\n\t\tprintln(\"plus flag set\")\n\t}\n}\n\nfunc main() {\n\tp := &printer{}\n\tp.init()\n\tp.format('d')\n\tprintln(\"Formatter test completed\")\n}\n",
    "tsCode": "// Generated file based on undefined_type_error.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class formatter {\n\t//nolint:unused\n\tpublic get wid(): number {\n\t\treturn this._fields.wid.value\n\t}\n\tpublic set wid(value: number) {\n\t\tthis._fields.wid.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get prec(): number {\n\t\treturn this._fields.prec.value\n\t}\n\tpublic set prec(value: number) {\n\t\tthis._fields.prec.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get widPresent(): boolean {\n\t\treturn this._fields.widPresent.value\n\t}\n\tpublic set widPresent(value: boolean) {\n\t\tthis._fields.widPresent.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get precPresent(): boolean {\n\t\treturn this._fields.precPresent.value\n\t}\n\tpublic set precPresent(value: boolean) {\n\t\tthis._fields.precPresent.value = value\n\t}\n\n\tpublic get minus(): boolean {\n\t\treturn this._fields.minus.value\n\t}\n\tpublic set minus(value: boolean) {\n\t\tthis._fields.minus.value = value\n\t}\n\n\tpublic get plus(): boolean {\n\t\treturn this._fields.plus.value\n\t}\n\tpublic set plus(value: boolean) {\n\t\tthis._fields.plus.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get sharp(): boolean {\n\t\treturn this._fields.sharp.value\n\t}\n\tpublic set sharp(value: boolean) {\n\t\tthis._fields.sharp.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get space(): boolean {\n\t\treturn this._fields.space.value\n\t}\n\tpublic set space(value: boolean) {\n\t\tthis._fields.space.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get zero(): boolean {\n\t\treturn this._fields.zero.value\n\t}\n\tpublic set zero(value: boolean) {\n\t\tthis._fields.zero.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get plusV(): boolean {\n\t\treturn this._fields.plusV.value\n\t}\n\tpublic set plusV(value: boolean) {\n\t\tthis._fields.plusV.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get sharpV(): boolean {\n\t\treturn this._fields.sharpV.value\n\t}\n\tpublic set sharpV(value: boolean) {\n\t\tthis._fields.sharpV.value = value\n\t}\n\n\tpublic _fields: {\n\t\twid: $.VarRef<number>;\n\t\tprec: $.VarRef<number>;\n\t\twidPresent: $.VarRef<boolean>;\n\t\tprecPresent: $.VarRef<boolean>;\n\t\tminus: $.VarRef<boolean>;\n\t\tplus: $.VarRef<boolean>;\n\t\tsharp: $.VarRef<boolean>;\n\t\tspace: $.VarRef<boolean>;\n\t\tzero: $.VarRef<boolean>;\n\t\tplusV: $.VarRef<boolean>;\n\t\tsharpV: $.VarRef<boolean>;\n\t}\n\n\tconstructor(init?: Partial<{minus?: boolean, plus?: boolean, plusV?: boolean, prec?: number, precPresent?: boolean, sharp?: boolean, sharpV?: boolean, space?: boolean, wid?: number, widPresent?: boolean, zero?: boolean}>) {\n\t\tthis._fields = {\n\t\t\twid: $.varRef(init?.wid ?? 0),\n\t\t\tprec: $.varRef(init?.prec ?? 0),\n\t\t\twidPresent: $.varRef(init?.widPresent ?? false),\n\t\t\tprecPresent: $.varRef(init?.precPresent ?? false),\n\t\t\tminus: $.varRef(init?.minus ?? false),\n\t\t\tplus: $.varRef(init?.plus ?? false),\n\t\t\tsharp: $.varRef(init?.sharp ?? false),\n\t\t\tspace: $.varRef(init?.space ?? false),\n\t\t\tzero: $.varRef(init?.zero ?? false),\n\t\t\tplusV: $.varRef(init?.plusV ?? false),\n\t\t\tsharpV: $.varRef(init?.sharpV ?? false)\n\t\t}\n\t}\n\n\tpublic clone(): formatter {\n\t\tconst cloned = new formatter()\n\t\tcloned._fields = {\n\t\t\twid: $.varRef(this._fields.wid.value),\n\t\t\tprec: $.varRef(this._fields.prec.value),\n\t\t\twidPresent: $.varRef(this._fields.widPresent.value),\n\t\t\tprecPresent: $.varRef(this._fields.precPresent.value),\n\t\t\tminus: $.varRef(this._fields.minus.value),\n\t\t\tplus: $.varRef(this._fields.plus.value),\n\t\t\tsharp: $.varRef(this._fields.sharp.value),\n\t\t\tspace: $.varRef(this._fields.space.value),\n\t\t\tzero: $.varRef(this._fields.zero.value),\n\t\t\tplusV: $.varRef(this._fields.plusV.value),\n\t\t\tsharpV: $.varRef(this._fields.sharpV.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.formatter',\n\t  new formatter(),\n\t  [],\n\t  formatter,\n\t  {\"wid\": { kind: $.TypeKind.Basic, name: \"int\" }, \"prec\": { kind: $.TypeKind.Basic, name: \"int\" }, \"widPresent\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"precPresent\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"minus\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"plus\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"sharp\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"space\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"zero\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"plusV\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"sharpV\": { kind: $.TypeKind.Basic, name: \"bool\" }}\n\t);\n}\n\nexport class printer {\n\t//nolint:unused\n\tpublic get buf(): $.Bytes {\n\t\treturn this._fields.buf.value\n\t}\n\tpublic set buf(value: $.Bytes) {\n\t\tthis._fields.buf.value = value\n\t}\n\n\t//nolint:unused\n\tpublic get arg(): null | any {\n\t\treturn this._fields.arg.value\n\t}\n\tpublic set arg(value: null | any) {\n\t\tthis._fields.arg.value = value\n\t}\n\n\t// This line causes the issue: fmt: $.VarRef<fmt>; where fmt is undefined\n\t// Should generate proper type reference\n\tpublic get fmt(): formatter {\n\t\treturn this._fields.fmt.value\n\t}\n\tpublic set fmt(value: formatter) {\n\t\tthis._fields.fmt.value = value\n\t}\n\n\tpublic _fields: {\n\t\tbuf: $.VarRef<$.Bytes>;\n\t\targ: $.VarRef<null | any>;\n\t\tfmt: $.VarRef<formatter>;\n\t}\n\n\tconstructor(init?: Partial<{arg?: null | any, buf?: $.Bytes, fmt?: formatter}>) {\n\t\tthis._fields = {\n\t\t\tbuf: $.varRef(init?.buf ?? new Uint8Array(0)),\n\t\t\targ: $.varRef(init?.arg ?? null),\n\t\t\tfmt: $.varRef(init?.fmt ? $.markAsStructValue(init.fmt.clone()) : new formatter())\n\t\t}\n\t}\n\n\tpublic clone(): printer {\n\t\tconst cloned = new printer()\n\t\tcloned._fields = {\n\t\t\tbuf: $.varRef(this._fields.buf.value),\n\t\t\targ: $.varRef(this._fields.arg.value),\n\t\t\tfmt: $.varRef($.markAsStructValue(this._fields.fmt.value.clone()))\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic init(): void {\n\t\tconst p = this\n\t\tp.fmt = $.markAsStructValue(new formatter({}))\n\t}\n\n\tpublic format(verb: number): void {\n\t\tconst p = this\n\t\tif (p.fmt.minus) {\n\t\t\t$.println(\"minus flag set\")\n\t\t}\n\t\tif (p.fmt.plus) {\n\t\t\t$.println(\"plus flag set\")\n\t\t}\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.printer',\n\t  new printer(),\n\t  [{ name: \"init\", args: [], returns: [] }, { name: \"format\", args: [{ name: \"verb\", type: { kind: $.TypeKind.Basic, name: \"rune\" } }], returns: [] }],\n\t  printer,\n\t  {\"buf\": { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"byte\" } }, \"arg\": { kind: $.TypeKind.Interface, methods: [] }, \"fmt\": \"formatter\"}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p = new printer({})\n\tp!.init()\n\tp!.format(100)\n\t$.println(\"Formatter test completed\")\n}\n\n",
    "expectedOutput": "Formatter test completed\n"
  },
  {
    "name": "util_promise",
    "goCode": "package main\n\nimport \"context\"\n\n// Promise is an asynchronous result to an operation\ntype Promise[T any] struct {\n\tresult     T\n\terr        error\n\tisResolved bool\n\tch         chan struct{}\n}\n\n// NewPromise constructs a new empty Promise\nfunc NewPromise[T any]() *Promise[T] {\n\treturn &Promise[T]{\n\t\tch: make(chan struct{}),\n\t}\n}\n\n// NewPromiseWithResult constructs a promise pre-resolved with a result\nfunc NewPromiseWithResult[T any](val T, err error) *Promise[T] {\n\tp := &Promise[T]{\n\t\tresult:     val,\n\t\terr:        err,\n\t\tisResolved: true,\n\t\tch:         make(chan struct{}),\n\t}\n\tif p.ch != nil {\n\t\tclose(p.ch)\n\t}\n\treturn p\n}\n\n// SetResult sets the result of the promise\nfunc (p *Promise[T]) SetResult(val T, err error) bool {\n\tif p.isResolved {\n\t\treturn false\n\t}\n\tp.result = val\n\tp.err = err\n\tp.isResolved = true\n\tif p.ch != nil {\n\t\tclose(p.ch)\n\t}\n\treturn true\n}\n\n// Await waits for the result to be set or for ctx to be canceled\nfunc (p *Promise[T]) Await(ctx context.Context) (val T, err error) {\n\tif p.isResolved {\n\t\treturn p.result, p.err\n\t}\n\n\tselect {\n\tcase <-p.ch:\n\t\treturn p.result, p.err\n\tcase <-ctx.Done():\n\t\tvar zero T\n\t\treturn zero, ctx.Err()\n\t}\n}\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Test 1: Basic Promise with string\n\tprintln(\"Test 1: Basic Promise with string\")\n\tp1 := NewPromise[string]()\n\n\t// Set result in goroutine\n\tgo func() {\n\t\tp1.SetResult(\"hello world\", nil)\n\t}()\n\n\tresult1, err1 := p1.Await(ctx)\n\tif err1 != nil {\n\t\tprintln(\"Error:\", err1.Error())\n\t} else {\n\t\tprintln(\"Result:\", result1)\n\t}\n\n\t// Test 2: Pre-resolved Promise with int\n\tprintln(\"Test 2: Pre-resolved Promise with int\")\n\tp2 := NewPromiseWithResult[int](42, nil)\n\tresult2, err2 := p2.Await(ctx)\n\tif err2 != nil {\n\t\tprintln(\"Error:\", err2.Error())\n\t} else {\n\t\tprintln(\"Result:\", result2)\n\t}\n\n\t// Test 3: Promise with error\n\tprintln(\"Test 3: Promise with error\")\n\tp3 := NewPromiseWithResult[bool](false, context.DeadlineExceeded)\n\tresult3, err3 := p3.Await(ctx)\n\tif err3 != nil {\n\t\tprintln(\"Error:\", err3.Error())\n\t} else {\n\t\tprintln(\"Result:\", result3)\n\t}\n\n\t// Test 4: Cannot set result twice\n\tprintln(\"Test 4: Cannot set result twice\")\n\tp4 := NewPromise[int]()\n\tsuccess1 := p4.SetResult(100, nil)\n\tsuccess2 := p4.SetResult(200, nil)\n\tprintln(\"First set success:\", success1)\n\tprintln(\"Second set success:\", success2)\n\n\tresult4, err4 := p4.Await(ctx)\n\tif err4 != nil {\n\t\tprintln(\"Error:\", err4.Error())\n\t} else {\n\t\tprintln(\"Final result:\", result4)\n\t}\n\n\tprintln(\"All tests completed\")\n}\n",
    "tsCode": "// Generated file based on util_promise.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as context from \"@goscript/context/index.js\"\n\nexport class PromiseType<T extends any> {\n\tpublic get result(): T {\n\t\treturn this._fields.result.value\n\t}\n\tpublic set result(value: T) {\n\t\tthis._fields.result.value = value\n\t}\n\n\tpublic get err(): $.GoError {\n\t\treturn this._fields.err.value\n\t}\n\tpublic set err(value: $.GoError) {\n\t\tthis._fields.err.value = value\n\t}\n\n\tpublic get isResolved(): boolean {\n\t\treturn this._fields.isResolved.value\n\t}\n\tpublic set isResolved(value: boolean) {\n\t\tthis._fields.isResolved.value = value\n\t}\n\n\tpublic get ch(): $.Channel<{  }> | null {\n\t\treturn this._fields.ch.value\n\t}\n\tpublic set ch(value: $.Channel<{  }> | null) {\n\t\tthis._fields.ch.value = value\n\t}\n\n\tpublic _fields: {\n\t\tresult: $.VarRef<T>;\n\t\terr: $.VarRef<$.GoError>;\n\t\tisResolved: $.VarRef<boolean>;\n\t\tch: $.VarRef<$.Channel<{  }> | null>;\n\t}\n\n\tconstructor(init?: Partial<{ch?: $.Channel<{  }> | null, err?: $.GoError, isResolved?: boolean, result?: T}>) {\n\t\tthis._fields = {\n\t\t\tresult: $.varRef(init?.result ?? null as any),\n\t\t\terr: $.varRef(init?.err ?? null),\n\t\t\tisResolved: $.varRef(init?.isResolved ?? false),\n\t\t\tch: $.varRef(init?.ch ?? null)\n\t\t}\n\t}\n\n\tpublic clone(): PromiseType<T> {\n\t\tconst cloned = new PromiseType<T>()\n\t\tcloned._fields = {\n\t\t\tresult: $.varRef(this._fields.result.value),\n\t\t\terr: $.varRef(this._fields.err.value),\n\t\t\tisResolved: $.varRef(this._fields.isResolved.value),\n\t\t\tch: $.varRef(this._fields.ch.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// SetResult sets the result of the promise\n\tpublic SetResult(val: T, err: $.GoError): boolean {\n\t\tconst p = this\n\t\tif (p.isResolved) {\n\t\t\treturn false\n\t\t}\n\t\tp.result = val\n\t\tp.err = err\n\t\tp.isResolved = true\n\t\tif (p.ch != null) {\n\t\t\tp.ch.close()\n\t\t}\n\t\treturn true\n\t}\n\n\t// Await waits for the result to be set or for ctx to be canceled\n\tpublic async Await(ctx: null | context.Context): Promise<[T, $.GoError]> {\n\t\tconst p = this\n\t\tlet val: T = null as any\n\t\tlet err: $.GoError = null\n\t\tif (p.isResolved) {\n\t\t\treturn [p.result, p.err]\n\t\t}\n\t\tconst [_select_has_return_0254, _select_value_0254] = await $.selectStatement([\n\t\t\t{\n\t\t\t\tid: 0,\n\t\t\t\tisSend: false,\n\t\t\t\tchannel: p.ch,\n\t\t\t\tonSelected: async (result) => {\n\t\t\t\t\treturn [p.result, p.err]\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 1,\n\t\t\t\tisSend: false,\n\t\t\t\tchannel: ctx!.Done(),\n\t\t\t\tonSelected: async (result) => {\n\t\t\t\t\tlet zero: T = null as any\n\t\t\t\t\treturn [zero, ctx!.Err()]\n\t\t\t\t}\n\t\t\t},\n\t\t], false)\n\t\tif (_select_has_return_0254) {\n\t\t\treturn _select_value_0254!\n\t\t}\n\t\t// All cases should return, this fallback should never execute\n\t\tthrow new Error('Unexpected: select statement did not return when all cases should return')\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.PromiseType',\n\t  new PromiseType(),\n\t  [{ name: \"SetResult\", args: [{ name: \"val\", type: { kind: $.TypeKind.Interface, methods: [] } }, { name: \"err\", type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"bool\" } }] }, { name: \"Await\", args: [{ name: \"ctx\", type: \"Context\" }], returns: [{ type: { kind: $.TypeKind.Interface, methods: [] } }, { type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  PromiseType,\n\t  {\"result\": { kind: $.TypeKind.Interface, methods: [] }, \"err\": { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] }, \"isResolved\": { kind: $.TypeKind.Basic, name: \"bool\" }, \"ch\": { kind: $.TypeKind.Channel, direction: \"both\", elemType: { kind: $.TypeKind.Struct, fields: {}, methods: [] } }}\n\t);\n}\n\n// NewPromise constructs a new empty Promise\nexport function NewPromise<T extends any>(): PromiseType<T> | null {\n\treturn new PromiseType<T>({ch: $.makeChannel<{  }>(0, {}, 'both')})\n}\n\n// NewPromiseWithResult constructs a promise pre-resolved with a result\nexport function NewPromiseWithResult<T extends any>(val: T, err: $.GoError): PromiseType<T> | null {\n\tlet p = new PromiseType<T>({ch: $.makeChannel<{  }>(0, {}, 'both'), err: err, isResolved: true, result: val})\n\tif (p!.ch != null) {\n\t\tp!.ch.close()\n\t}\n\treturn p\n}\n\nexport async function main(): Promise<void> {\n\tlet ctx = context.Background()\n\n\t// Test 1: Basic Promise with string\n\t$.println(\"Test 1: Basic Promise with string\")\n\tlet p1 = NewPromise<string>()\n\n\t// Set result in goroutine\n\tqueueMicrotask(() => {\n\t\tp1!.SetResult(\"hello world\", null)\n\t})\n\n\tlet [result1, err1] = await p1!.Await(ctx)\n\tif (err1 != null) {\n\t\t$.println(\"Error:\", err1!.Error())\n\t} else {\n\t\t$.println(\"Result:\", result1)\n\t}\n\n\t// Test 2: Pre-resolved Promise with int\n\t$.println(\"Test 2: Pre-resolved Promise with int\")\n\tlet p2 = NewPromiseWithResult<number>(42, null)\n\tlet [result2, err2] = await p2!.Await(ctx)\n\tif (err2 != null) {\n\t\t$.println(\"Error:\", err2!.Error())\n\t} else {\n\t\t$.println(\"Result:\", result2)\n\t}\n\n\t// Test 3: Promise with error\n\t$.println(\"Test 3: Promise with error\")\n\tlet p3 = NewPromiseWithResult<boolean>(false, context.DeadlineExceeded)\n\tlet [result3, err3] = await p3!.Await(ctx)\n\tif (err3 != null) {\n\t\t$.println(\"Error:\", err3!.Error())\n\t} else {\n\t\t$.println(\"Result:\", result3)\n\t}\n\n\t// Test 4: Cannot set result twice\n\t$.println(\"Test 4: Cannot set result twice\")\n\tlet p4 = NewPromise<number>()\n\tlet success1 = p4!.SetResult(100, null)\n\tlet success2 = p4!.SetResult(200, null)\n\t$.println(\"First set success:\", success1)\n\t$.println(\"Second set success:\", success2)\n\n\tlet [result4, err4] = await p4!.Await(ctx)\n\tif (err4 != null) {\n\t\t$.println(\"Error:\", err4!.Error())\n\t} else {\n\t\t$.println(\"Final result:\", result4)\n\t}\n\n\t$.println(\"All tests completed\")\n}\n\n",
    "expectedOutput": "Test 1: Basic Promise with string\nResult: hello world\nTest 2: Pre-resolved Promise with int\nResult: 42\nTest 3: Promise with error\nError: context deadline exceeded\nTest 4: Cannot set result twice\nFirst set success: true\nSecond set success: false\nFinal result: 100\nAll tests completed\n"
  },
  {
    "name": "value_type_copy_behavior",
    "goCode": "package main\n\n// MyStruct is a simple struct used for demonstrating copy behavior.\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\n// NestedStruct demonstrates nesting behavior with value types.\ntype NestedStruct struct {\n\tValue       int\n\tInnerStruct MyStruct\n}\n\nfunc main() {\n\t// Horizontal line for output clarity\n\tprintln(\"----------------------------------------------------------\")\n\tprintln(\"VALUE TYPE COPY BEHAVIOR TEST\")\n\tprintln(\"----------------------------------------------------------\")\n\n\t// original is the starting struct instance.\n\t// We take its address later for pointerCopy, so it might be allocated on the heap (varrefed).\n\toriginal := MyStruct{MyInt: 42, MyString: \"original\"}\n\n\t// === Value-Type Copy Behavior ===\n\t// Assigning a struct (value type) creates independent copies.\n\t// valueCopy1 and valueCopy2 get their own copies of 'original's data.\n\tvalueCopy1 := original\n\tvalueCopy2 := original\n\t// pointerCopy holds the memory address of 'original'.\n\tpointerCopy := &original\n\n\t// Modifications to value copies do not affect the original or other copies.\n\tvalueCopy1.MyString = \"value copy 1\"\n\t// Modify the original struct *after* the value copies were made.\n\toriginal.MyString = \"original modified\"\n\tvalueCopy2.MyString = \"value copy 2\"\n\n\tprintln(\"Value Copy Test:\")\n\t// valueCopy1 was modified independently.\n\tprintln(\"  valueCopy1.MyString: \" + valueCopy1.MyString) // Expected: \"value copy 1\"\n\t// original was modified after copies, showing its current state.\n\tprintln(\"  original.MyString: \" + original.MyString) // Expected: \"original modified\"\n\t// valueCopy2 was modified independently.\n\tprintln(\"  valueCopy2.MyString: \" + valueCopy2.MyString) // Expected: \"value copy 2\"\n\n\t// === Pointer Behavior ===\n\t// Demonstrate how modifications via a pointer affect the original struct.\n\tprintln(\"\\nPointer Behavior Test:\")\n\t// Show the state of 'original' before modification via the pointer.\n\tprintln(\"  Before pointer modification - original.MyString: \" + original.MyString)\n\n\t// Modify the struct 'original' *through* the pointerCopy.\n\tpointerCopy.MyString = \"modified through pointer\"\n\tpointerCopy.MyInt = 100\n\n\t// Show the state of 'original' *after* modification via the pointer.\n\t// Both fields reflect the changes made through pointerCopy.\n\tprintln(\"  After pointer modification - original.MyString:\", original.MyString)\n\tprintln(\"  After pointer modification - original.MyInt:\", original.MyInt)\n\n\t// === Nested Struct Behavior ===\n\t// Demonstrate copy behavior with structs containing other structs.\n\tprintln(\"\\nNested Struct Test:\")\n\tnestedOriginal := NestedStruct{\n\t\tValue:       10,\n\t\tInnerStruct: MyStruct{MyInt: 20, MyString: \"inner original\"},\n\t}\n\n\t// Create a value copy of the nested struct. This copies both the outer\n\t// struct's fields (Value) and the inner struct (InnerStruct) by value.\n\tnestedCopy := nestedOriginal\n\n\t// Modify the copy's fields, including fields within the nested InnerStruct.\n\tnestedCopy.InnerStruct.MyString = \"inner modified\"\n\tnestedCopy.Value = 30\n\n\t// Show that modifications to nestedCopy did not affect nestedOriginal.\n\tprintln(\"  nestedCopy.Value: \", nestedCopy.Value)                                        // Expected: 30\n\tprintln(\"  nestedOriginal.Value: \", nestedOriginal.Value)                                // Expected: 10\n\tprintln(\"  nestedCopy.InnerStruct.MyString: \" + nestedCopy.InnerStruct.MyString)         // Expected: \"inner modified\"\n\tprintln(\"  nestedOriginal.InnerStruct.MyString: \" + nestedOriginal.InnerStruct.MyString) // Expected: \"inner original\"\n\n\tprintln(\"----------------------------------------------------------\")\n}\n",
    "tsCode": "// Generated file based on value_type_copy_behavior.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport class NestedStruct {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic get InnerStruct(): MyStruct {\n\t\treturn this._fields.InnerStruct.value\n\t}\n\tpublic set InnerStruct(value: MyStruct) {\n\t\tthis._fields.InnerStruct.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t\tInnerStruct: $.VarRef<MyStruct>;\n\t}\n\n\tconstructor(init?: Partial<{InnerStruct?: MyStruct, Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0),\n\t\t\tInnerStruct: $.varRef(init?.InnerStruct ? $.markAsStructValue(init.InnerStruct.clone()) : new MyStruct())\n\t\t}\n\t}\n\n\tpublic clone(): NestedStruct {\n\t\tconst cloned = new NestedStruct()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value),\n\t\t\tInnerStruct: $.varRef($.markAsStructValue(this._fields.InnerStruct.value.clone()))\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.NestedStruct',\n\t  new NestedStruct(),\n\t  [],\n\t  NestedStruct,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }, \"InnerStruct\": \"MyStruct\"}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Horizontal line for output clarity\n\t$.println(\"----------------------------------------------------------\")\n\t$.println(\"VALUE TYPE COPY BEHAVIOR TEST\")\n\t$.println(\"----------------------------------------------------------\")\n\n\t// original is the starting struct instance.\n\t// We take its address later for pointerCopy, so it might be allocated on the heap (varrefed).\n\tlet original = $.varRef($.markAsStructValue(new MyStruct({MyInt: 42, MyString: \"original\"})))\n\n\t// === Value-Type Copy Behavior ===\n\t// Assigning a struct (value type) creates independent copies.\n\t// valueCopy1 and valueCopy2 get their own copies of 'original's data.\n\tlet valueCopy1 = $.markAsStructValue(original!.value.clone())\n\tlet valueCopy2 = $.markAsStructValue(original!.value.clone())\n\t// pointerCopy holds the memory address of 'original'.\n\tlet pointerCopy = original\n\n\t// Modifications to value copies do not affect the original or other copies.\n\tvalueCopy1.MyString = \"value copy 1\"\n\t// Modify the original struct *after* the value copies were made.\n\toriginal!.value.MyString = \"original modified\"\n\tvalueCopy2.MyString = \"value copy 2\"\n\n\t$.println(\"Value Copy Test:\")\n\t// valueCopy1 was modified independently.\n\t$.println(\"  valueCopy1.MyString: \" + valueCopy1.MyString) // Expected: \"value copy 1\"\n\t// original was modified after copies, showing its current state.\n\t$.println(\"  original.MyString: \" + original!.value.MyString) // Expected: \"original modified\"\n\t// valueCopy2 was modified independently.\n\t$.println(\"  valueCopy2.MyString: \" + valueCopy2.MyString) // Expected: \"value copy 2\"\n\n\t// === Pointer Behavior ===\n\t// Demonstrate how modifications via a pointer affect the original struct.\n\t$.println(\"\\nPointer Behavior Test:\")\n\t// Show the state of 'original' before modification via the pointer.\n\t$.println(\"  Before pointer modification - original.MyString: \" + original!.value.MyString)\n\n\t// Modify the struct 'original' *through* the pointerCopy.\n\tpointerCopy!.value!.MyString = \"modified through pointer\"\n\tpointerCopy!.value!.MyInt = 100\n\n\t// Show the state of 'original' *after* modification via the pointer.\n\t// Both fields reflect the changes made through pointerCopy.\n\t$.println(\"  After pointer modification - original.MyString:\", original!.value.MyString)\n\t$.println(\"  After pointer modification - original.MyInt:\", original!.value.MyInt)\n\n\t// === Nested Struct Behavior ===\n\t// Demonstrate copy behavior with structs containing other structs.\n\t$.println(\"\\nNested Struct Test:\")\n\tlet nestedOriginal = $.markAsStructValue(new NestedStruct({InnerStruct: $.markAsStructValue(new MyStruct({MyInt: 20, MyString: \"inner original\"})), Value: 10}))\n\n\t// Create a value copy of the nested struct. This copies both the outer\n\t// struct's fields (Value) and the inner struct (InnerStruct) by value.\n\tlet nestedCopy = $.markAsStructValue(nestedOriginal.clone())\n\n\t// Modify the copy's fields, including fields within the nested InnerStruct.\n\tnestedCopy.InnerStruct.MyString = \"inner modified\"\n\tnestedCopy.Value = 30\n\n\t// Show that modifications to nestedCopy did not affect nestedOriginal.\n\t$.println(\"  nestedCopy.Value: \", nestedCopy.Value) // Expected: 30\n\t$.println(\"  nestedOriginal.Value: \", nestedOriginal.Value) // Expected: 10\n\t$.println(\"  nestedCopy.InnerStruct.MyString: \" + nestedCopy.InnerStruct.MyString) // Expected: \"inner modified\"\n\t$.println(\"  nestedOriginal.InnerStruct.MyString: \" + nestedOriginal.InnerStruct.MyString) // Expected: \"inner original\"\n\n\t$.println(\"----------------------------------------------------------\")\n}\n\n",
    "expectedOutput": "----------------------------------------------------------\nVALUE TYPE COPY BEHAVIOR TEST\n----------------------------------------------------------\nValue Copy Test:\n  valueCopy1.MyString: value copy 1\n  original.MyString: original modified\n  valueCopy2.MyString: value copy 2\n\nPointer Behavior Test:\n  Before pointer modification - original.MyString: original modified\n  After pointer modification - original.MyString: modified through pointer\n  After pointer modification - original.MyInt: 100\n\nNested Struct Test:\n  nestedCopy.Value:  30\n  nestedOriginal.Value:  10\n  nestedCopy.InnerStruct.MyString: inner modified\n  nestedOriginal.InnerStruct.MyString: inner original\n----------------------------------------------------------"
  },
  {
    "name": "var_init_method_call",
    "goCode": "package main\n\ntype T struct {\n\tval int\n}\n\nfunc NewT(v int) *T {\n\treturn &T{val: v}\n}\n\nfunc (t *T) WithDelta(delta int) *T {\n\treturn &T{val: t.val + delta}\n}\n\nvar (\n\tBase    = NewT(10)\n\tDerived = Base.WithDelta(5)\n)\n\nfunc main() {\n\tprintln(\"Base:\", Base.val)\n\tprintln(\"Derived:\", Derived.val)\n}\n",
    "tsCode": "// Generated file based on var_init_method_call.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class T {\n\tpublic get val(): number {\n\t\treturn this._fields.val.value\n\t}\n\tpublic set val(value: number) {\n\t\tthis._fields.val.value = value\n\t}\n\n\tpublic _fields: {\n\t\tval: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{val?: number}>) {\n\t\tthis._fields = {\n\t\t\tval: $.varRef(init?.val ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): T {\n\t\tconst cloned = new T()\n\t\tcloned._fields = {\n\t\t\tval: $.varRef(this._fields.val.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic WithDelta(delta: number): T | null {\n\t\tconst t = this\n\t\treturn new T({val: t.val + delta})\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.T',\n\t  new T(),\n\t  [{ name: \"WithDelta\", args: [{ name: \"delta\", type: { kind: $.TypeKind.Basic, name: \"int\" } }], returns: [{ type: { kind: $.TypeKind.Pointer, elemType: \"T\" } }] }],\n\t  T,\n\t  {\"val\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport let Base: T | null = NewT(10)\n\nexport let Derived: T | null = Base!.WithDelta(5)\n\nexport function NewT(v: number): T | null {\n\treturn new T({val: v})\n}\n\nexport async function main(): Promise<void> {\n\t$.println(\"Base:\", Base!.val)\n\t$.println(\"Derived:\", Derived!.val)\n}\n\n",
    "expectedOutput": "Base: 10\nDerived: 15\n"
  },
  {
    "name": "var_init_order",
    "goCode": "package main\n\nvar (\n\ta = 10\n\tb = a + 5\n\tc = b * 2\n)\n\nfunc main() {\n\tprintln(\"a:\", a)\n\tprintln(\"b:\", b)\n\tprintln(\"c:\", c)\n}\n",
    "tsCode": "// Generated file based on var_init_order.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport let a: number = 10\n\nexport let b: number = a + 5\n\nexport let c: number = b * 2\n\nexport async function main(): Promise<void> {\n\t$.println(\"a:\", a)\n\t$.println(\"b:\", b)\n\t$.println(\"c:\", c)\n}\n\n",
    "expectedOutput": "a: 10\nb: 15\nc: 30\n"
  },
  {
    "name": "variable_shadowing_scope",
    "goCode": "package main\n\nfunc firstFunc() (string, int) {\n\treturn \"\", 42\n}\n\nfunc secondFunc(x int) int {\n\tif x != 0 {\n\t\tprintln(\"Got value:\", x)\n\t\treturn 0\n\t}\n\treturn 99\n}\n\nfunc main() {\n\t_, x := firstFunc()\n\t// This is the problematic pattern: x is shadowed but also used in the call\n\tif x := secondFunc(x); x != 0 {\n\t\tprintln(\"Function returned value\")\n\t\treturn\n\t}\n\tprintln(\"Completed successfully\")\n}\n",
    "tsCode": "// Generated file based on variable_shadowing_scope.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function firstFunc(): [string, number] {\n\treturn [\"\", 42]\n}\n\nexport function secondFunc(x: number): number {\n\tif (x != 0) {\n\t\t$.println(\"Got value:\", x)\n\t\treturn 0\n\t}\n\treturn 99\n}\n\nexport async function main(): Promise<void> {\n\tlet [, x] = firstFunc()\n\t// This is the problematic pattern: x is shadowed but also used in the call\n\tconst _temp_x = x\n\t{\n\t\tlet x = secondFunc(_temp_x)\n\t\tif (x != 0) {\n\t\t\t$.println(\"Function returned value\")\n\t\t\treturn \n\t\t}\n\t}\n\t$.println(\"Completed successfully\")\n}\n\n",
    "expectedOutput": "Got value: 42\nCompleted successfully\n"
  },
  {
    "name": "variadic_function_call",
    "goCode": "package main\n\nimport \"errors\"\n\n// TestFS simulates the function signature from the user's example\nfunc TestFS(fsys string, expected ...string) error {\n\treturn testFS(fsys, expected...)\n}\n\n// testFS is the variadic function being called\nfunc testFS(fsys string, expected ...string) error {\n\tif len(expected) == 0 {\n\t\treturn errors.New(\"no expected values\")\n\t}\n\n\tfor i, exp := range expected {\n\t\tprintln(\"Expected[\" + string(rune(i+'0')) + \"]: \" + exp)\n\t}\n\n\tprintln(\"File system: \" + fsys)\n\treturn nil\n}\n\nfunc main() {\n\texpected := []string{\"file1.txt\", \"file2.txt\", \"file3.txt\"}\n\n\t// This is the problematic line - should generate spread syntax in TypeScript\n\terr := TestFS(\"myfs\", expected...)\n\n\tif err != nil {\n\t\tprintln(\"Error: \" + err.Error())\n\t} else {\n\t\tprintln(\"Success!\")\n\t}\n}\n",
    "tsCode": "// Generated file based on variadic_function_call.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as errors from \"@goscript/errors/index.js\"\n\n// TestFS simulates the function signature from the user's example\nexport function TestFS(fsys: string, ...expected: string[]): $.GoError {\n\treturn testFS(fsys, ...(expected ?? []))\n}\n\n// testFS is the variadic function being called\nexport function testFS(fsys: string, ...expected: string[]): $.GoError {\n\tif ($.len(expected) == 0) {\n\t\treturn errors.New(\"no expected values\")\n\t}\n\n\tfor (let i = 0; i < $.len(expected); i++) {\n\t\tlet exp = expected![i]\n\t\t{\n\t\t\t$.println(\"Expected[\" + $.runeOrStringToString(i + 48) + \"]: \" + exp)\n\t\t}\n\t}\n\n\t$.println(\"File system: \" + fsys)\n\treturn null\n}\n\nexport async function main(): Promise<void> {\n\tlet expected = $.arrayToSlice<string>([\"file1.txt\", \"file2.txt\", \"file3.txt\"])\n\n\t// This is the problematic line - should generate spread syntax in TypeScript\n\tlet err = TestFS(\"myfs\", ...(expected ?? []))\n\n\tif (err != null) {\n\t\t$.println(\"Error: \" + err!.Error())\n\t} else {\n\t\t$.println(\"Success!\")\n\t}\n}\n\n",
    "expectedOutput": "Expected[0]: file1.txt\nExpected[1]: file2.txt\nExpected[2]: file3.txt\nFile system: myfs\nSuccess! "
  },
  {
    "name": "variadic_interface_method",
    "goCode": "package main\n\ntype Basic interface {\n\tJoin(elem ...string) string\n}\n\ntype PathJoiner struct{}\n\nfunc (p PathJoiner) Join(elem ...string) string {\n\tresult := \"\"\n\tfor i, e := range elem {\n\t\tif i > 0 {\n\t\t\tresult += \"/\"\n\t\t}\n\t\tresult += e\n\t}\n\treturn result\n}\n\nfunc main() {\n\tvar b Basic = PathJoiner{}\n\n\t// Test with multiple arguments\n\tresult1 := b.Join(\"path\", \"to\", \"file\")\n\tprintln(\"Result1:\", result1)\n\n\t// Test with single argument\n\tresult2 := b.Join(\"single\")\n\tprintln(\"Result2:\", result2)\n\n\t// Test with no arguments\n\tresult3 := b.Join()\n\tprintln(\"Result3:\", result3)\n\n\t// Test with slice expansion\n\tparts := []string{\"another\", \"path\", \"here\"}\n\tresult4 := b.Join(parts...)\n\tprintln(\"Result4:\", result4)\n}\n",
    "tsCode": "// Generated file based on variadic_interface_method.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type Basic = null | {\n\tJoin(...elem: string[]): string\n}\n\n$.registerInterfaceType(\n  'main.Basic',\n  null, // Zero value for interface is null\n  [{ name: \"Join\", args: [{ name: \"elem\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"string\" } } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }]\n);\n\nexport class PathJoiner {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): PathJoiner {\n\t\tconst cloned = new PathJoiner()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Join(...elem: string[]): string {\n\t\tlet result = \"\"\n\t\tfor (let i = 0; i < $.len(elem); i++) {\n\t\t\tlet e = elem![i]\n\t\t\t{\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tresult += \"/\"\n\t\t\t\t}\n\t\t\t\tresult += e\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.PathJoiner',\n\t  new PathJoiner(),\n\t  [{ name: \"Join\", args: [{ name: \"elem\", type: { kind: $.TypeKind.Slice, elemType: { kind: $.TypeKind.Basic, name: \"string\" } } }], returns: [{ type: { kind: $.TypeKind.Basic, name: \"string\" } }] }],\n\t  PathJoiner,\n\t  {}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet b: Basic = $.markAsStructValue(new PathJoiner({}))\n\n\t// Test with multiple arguments\n\tlet result1 = b!.Join(\"path\", \"to\", \"file\")\n\t$.println(\"Result1:\", result1)\n\n\t// Test with single argument\n\tlet result2 = b!.Join(\"single\")\n\t$.println(\"Result2:\", result2)\n\n\t// Test with no arguments\n\tlet result3 = b!.Join()\n\t$.println(\"Result3:\", result3)\n\n\t// Test with slice expansion\n\tlet parts = $.arrayToSlice<string>([\"another\", \"path\", \"here\"])\n\tlet result4 = b!.Join(...(parts ?? []))\n\t$.println(\"Result4:\", result4)\n}\n\n",
    "expectedOutput": "Result1: path/to/file\nResult2: single\nResult3: \nResult4: another/path/here\n"
  },
  {
    "name": "variadic_interface_param",
    "goCode": "package main\n\n// testVariadicInterface tests the TypeScript generation for functions\n// with variadic ...interface{} parameters\nfunc testVariadicInterface(name string, values ...interface{}) {\n\tprintln(\"Name:\", name)\n\tprintln(\"Values count:\", len(values))\n\tfor i, v := range values {\n\t\t// We can't do much with interface{} values in the compiled output\n\t\t// but we can at least check they're passed correctly\n\t\tif v != nil {\n\t\t\tprintln(\"Value\", i, \"is not nil\")\n\t\t} else {\n\t\t\tprintln(\"Value\", i, \"is nil\")\n\t\t}\n\t}\n}\n\nfunc main() {\n\t// Test with various argument types\n\ttestVariadicInterface(\"test1\", \"hello\", 42, true)\n\ttestVariadicInterface(\"test2\", nil, \"world\")\n\ttestVariadicInterface(\"test3\")\n\n\t// Test with slice expansion\n\tvalues := []interface{}{\"a\", \"b\", \"c\"}\n\ttestVariadicInterface(\"test4\", values...)\n}\n",
    "tsCode": "// Generated file based on variadic_interface_param.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\n// testVariadicInterface tests the TypeScript generation for functions\n// with variadic ...interface{} parameters\nexport function testVariadicInterface(name: string, ...values: any[]): void {\n\t$.println(\"Name:\", name)\n\t$.println(\"Values count:\", $.len(values))\n\n\t// We can't do much with interface{} values in the compiled output\n\t// but we can at least check they're passed correctly\n\tfor (let i = 0; i < $.len(values); i++) {\n\t\tlet v = values![i]\n\t\t{\n\t\t\t// We can't do much with interface{} values in the compiled output\n\t\t\t// but we can at least check they're passed correctly\n\t\t\tif (v != null) {\n\t\t\t\t$.println(\"Value\", i, \"is not nil\")\n\t\t\t} else {\n\t\t\t\t$.println(\"Value\", i, \"is nil\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport async function main(): Promise<void> {\n\t// Test with various argument types\n\ttestVariadicInterface(\"test1\", \"hello\", 42, true)\n\ttestVariadicInterface(\"test2\", null, \"world\")\n\ttestVariadicInterface(\"test3\")\n\n\t// Test with slice expansion\n\tlet values = $.arrayToSlice<null | any>([\"a\", \"b\", \"c\"])\n\ttestVariadicInterface(\"test4\", ...(values ?? []))\n}\n\n",
    "expectedOutput": "Name: test1\nValues count: 3\nValue 0 is not nil\nValue 1 is not nil\nValue 2 is not nil\nName: test2\nValues count: 2\nValue 0 is nil\nValue 1 is not nil\nName: test3\nValues count: 0\nName: test4\nValues count: 3\nValue 0 is not nil\nValue 1 is not nil\nValue 2 is not nil "
  },
  {
    "name": "varref",
    "goCode": "package main\n\n// Based on design/VAR_REFS.md\n\nfunc main() {\n\tprintln(\"setting x to 10\")\n\tvar x int = 10 // x is varrefed as p1 takes the address\n\n\tvar p1 *int = &x    // p1 is varrefed as p2 takes the address\n\tvar p2 **int = &p1  // p2 is varrefed as p3 takes the address\n\tvar p3 ***int = &p2 // p3 is not varrefed as nothing takes its address\n\n\tprintln(\"***p3 ==\", ***p3)\n\tprintln()\n\n\tprintln(\"setting ***p3 to 12\")\n\t***p3 = 12\n\tprintln(\"***p3 ==\", ***p3)\n\tprintln()\n\n\tprintln(\"setting y to 15, p1 to &y\")\n\t// should be: let y: $.VarRef<number> = $.varRef(15)\n\tvar y int = 15 // y is varrefed as p1 takes the address\n\t// should be: p1.value = y\n\tp1 = &y\n\n\tprintln(\"***p3 ==\", ***p3)\n\tprintln()\n}\n",
    "tsCode": "// Generated file based on varref.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t$.println(\"setting x to 10\")\n\t// x is varrefed as p1 takes the address\n\tlet x: $.VarRef<number> = $.varRef(10)\n\n\t// p1 is varrefed as p2 takes the address\n\tlet p1: $.VarRef<$.VarRef<number> | null> = $.varRef(x)\n\t// p2 is varrefed as p3 takes the address\n\tlet p2: $.VarRef<$.VarRef<$.VarRef<number> | null> | null> = $.varRef(p1)\n\t// p3 is not varrefed as nothing takes its address\n\tlet p3: $.VarRef<$.VarRef<$.VarRef<number> | null> | null> | null = p2\n\n\t$.println(\"***p3 ==\", p3!.value!.value!.value)\n\t$.println()\n\n\t$.println(\"setting ***p3 to 12\")\n\tp3!.value!.value!.value = 12\n\t$.println(\"***p3 ==\", p3!.value!.value!.value)\n\t$.println()\n\n\t$.println(\"setting y to 15, p1 to &y\")\n\t// should be: let y: $.VarRef<number> = $.varRef(15)\n\t// y is varrefed as p1 takes the address\n\tlet y: $.VarRef<number> = $.varRef(15)\n\t// should be: p1.value = y\n\tp1!.value = y\n\n\t$.println(\"***p3 ==\", p3!.value!.value!.value)\n\t$.println()\n}\n\n",
    "expectedOutput": "setting x to 10\n***p3 == 10\n\nsetting ***p3 to 12\n***p3 == 12\n\nsetting y to 15, p1 to &y\n***p3 == 15"
  },
  {
    "name": "varref_assign",
    "goCode": "package main\n\nfunc main() {\n\tvar x int = 10 // x is varrefed as p1 takes the address\n\n\tvar p1 *int = &x    // p1 is varrefed as p2 takes the address\n\tvar p2 **int = &p1  // p2 is varrefed as p3 takes the address\n\tvar p3 ***int = &p2 // p3 is not varrefed as nothing takes its address\n\t_ = p3\n\n\t// should be: let y: $.VarRef<number> = $.varRef(15)\n\tvar y int = 15 // y is varrefed as p1 takes the address\n\t// should be: p1.value = y\n\tp1 = &y\n\n\tprintln(\"***p3 ==\", ***p3)\n}\n",
    "tsCode": "// Generated file based on varref_assign.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// x is varrefed as p1 takes the address\n\tlet x: $.VarRef<number> = $.varRef(10)\n\n\t// p1 is varrefed as p2 takes the address\n\tlet p1: $.VarRef<$.VarRef<number> | null> = $.varRef(x)\n\t// p2 is varrefed as p3 takes the address\n\tlet p2: $.VarRef<$.VarRef<$.VarRef<number> | null> | null> = $.varRef(p1)\n\t// p3 is not varrefed as nothing takes its address\n\tlet p3: $.VarRef<$.VarRef<$.VarRef<number> | null> | null> | null = p2\n\t/* _ = */ p3!.value\n\n\t// should be: let y: $.VarRef<number> = $.varRef(15)\n\t// y is varrefed as p1 takes the address\n\tlet y: $.VarRef<number> = $.varRef(15)\n\t// should be: p1.value = y\n\tp1!.value = y\n\n\t$.println(\"***p3 ==\", p3!.value!.value!.value)\n}\n\n",
    "expectedOutput": "***p3 == 15"
  },
  {
    "name": "varref_composite_lit",
    "goCode": "package main\n\ntype MockInode struct {\n\tValue int\n}\n\nfunc (m *MockInode) getValue() int {\n\treturn m.Value\n}\n\nfunc main() {\n\t// This should generate: let childInode: MockInode | null = new MockInode({Value: 42})\n\t// Not: let childInode: MockInode | null = $.varRef(new MockInode({Value: 42}))\n\t// Because we're taking the address of a composite literal, not a variable\n\tvar childInode *MockInode = &MockInode{Value: 42}\n\n\t// Use the pointer\n\tprintln(\"childInode.Value:\", childInode.Value)\n\tprintln(\"childInode.getValue():\", childInode.getValue())\n}\n",
    "tsCode": "// Generated file based on varref_composite_lit.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MockInode {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MockInode {\n\t\tconst cloned = new MockInode()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic getValue(): number {\n\t\tconst m = this\n\t\treturn m.Value\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MockInode',\n\t  new MockInode(),\n\t  [{ name: \"getValue\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  MockInode,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// This should generate: let childInode: MockInode | null = new MockInode({Value: 42})\n\t// Not: let childInode: MockInode | null = $.varRef(new MockInode({Value: 42}))\n\t// Because we're taking the address of a composite literal, not a variable\n\tlet childInode: MockInode | null = new MockInode({Value: 42})\n\n\t// Use the pointer\n\t$.println(\"childInode.Value:\", childInode!.Value)\n\t$.println(\"childInode.getValue():\", childInode!.getValue())\n}\n\n",
    "expectedOutput": "childInode.Value: 42\nchildInode.getValue(): 42 "
  },
  {
    "name": "varref_deref_set",
    "goCode": "package main\n\nfunc main() {\n\t// y is varrefed because p1 takes its address\n\tvar y int = 15\n\n\t// p1 is varrefed because p1_varRefer takes its address\n\tvar p1 *int = nil\n\tvar p1_varRefer **int = &p1 // Ensure p1 is varrefed\n\t_ = p1_varRefer\n\n\t// Expected TS: p1.value = y\n\tp1 = &y\n\n\t// Dereferencing p1 (varrefed variable) to access y (varrefed variable)\n\t// Go: println(*p1)\n\t// Expected TS for same behavior: console.log(p1.value.value)\n\t// We access p1 which should be p1.value. Then we dereference that, which should be p1.value.value.\n\tprintln(*p1)\n\n\t// Set the value\n\t*p1 = 20\n}\n",
    "tsCode": "// Generated file based on varref_deref_set.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// y is varrefed because p1 takes its address\n\tlet y: $.VarRef<number> = $.varRef(15)\n\n\t// p1 is varrefed because p1_varRefer takes its address\n\tlet p1: $.VarRef<$.VarRef<number> | null> = $.varRef(null)\n\t// Ensure p1 is varrefed\n\tlet p1_varRefer: $.VarRef<$.VarRef<number> | null> | null = p1\n\t/* _ = */ p1_varRefer!.value\n\n\t// Expected TS: p1.value = y\n\tp1!.value = y\n\n\t// Dereferencing p1 (varrefed variable) to access y (varrefed variable)\n\t// Go: println(*p1)\n\t// Expected TS for same behavior: console.log(p1.value.value)\n\t// We access p1 which should be p1.value. Then we dereference that, which should be p1.value.value.\n\t$.println(p1!.value!.value)\n\n\t// Set the value\n\tp1!.value!.value = 20\n}\n\n",
    "expectedOutput": "15"
  },
  {
    "name": "varref_deref_struct",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt int\n}\n\nfunc main() {\n\t// We need to make sure we don't add .value for this\n\tmyStruct := &MyStruct{}\n\t(*myStruct).MyInt = 5\n\tprintln((*myStruct).MyInt)\n\n\tmyOtherStruct := &MyStruct{MyInt: 1}\n\tif myOtherStruct != myStruct {\n\t\tprintln(\"expected not equal\")\n\t}\n}\n",
    "tsCode": "// Generated file based on varref_deref_struct.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// We need to make sure we don't add .value for this\n\tlet myStruct = new MyStruct({})\n\t;myStruct!.MyInt = 5\n\t$.println(myStruct!.MyInt)\n\n\tlet myOtherStruct = new MyStruct({MyInt: 1})\n\tif ((myOtherStruct !== myStruct)) {\n\t\t$.println(\"expected not equal\")\n\t}\n}\n\n",
    "expectedOutput": "5\nexpected not equal"
  },
  {
    "name": "varref_pointers",
    "goCode": "package main\n\nfunc main() {\n\tvar x int = 10      // x is varrefed as p1 takes the address\n\tvar p1 *int = &x    // p1 is varrefed as p2 takes the address\n\tvar p2 **int = &p1  // p2 is varrefed as p3 takes the address\n\tvar p3 ***int = &p2 // p3 is not varrefed as nothing takes its address\n\n\tprintln(\"***p3 before ==\", ***p3)\n\n\t// Dereference multiple times, this should be:\n\t// Goal: p3!.value!.value!.value = 12\n\t// Current: p3!.value = 12\n\t// Issue: only the bottom-most level of the WriteStarExpr checks p3 for varRefing generating .value\n\t// How do we know that *p3 needs .value?\n\t***p3 = 12\n\tprintln(\"***p3 after ==\", ***p3)\n}\n",
    "tsCode": "// Generated file based on varref_pointers.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// x is varrefed as p1 takes the address\n\tlet x: $.VarRef<number> = $.varRef(10)\n\t// p1 is varrefed as p2 takes the address\n\tlet p1: $.VarRef<$.VarRef<number> | null> = $.varRef(x)\n\t// p2 is varrefed as p3 takes the address\n\tlet p2: $.VarRef<$.VarRef<$.VarRef<number> | null> | null> = $.varRef(p1)\n\t// p3 is not varrefed as nothing takes its address\n\tlet p3: $.VarRef<$.VarRef<$.VarRef<number> | null> | null> | null = p2\n\n\t$.println(\"***p3 before ==\", p3!.value!.value!.value)\n\n\t// Dereference multiple times, this should be:\n\t// Goal: p3!.value!.value!.value = 12\n\t// Current: p3!.value = 12\n\t// Issue: only the bottom-most level of the WriteStarExpr checks p3 for varRefing generating .value\n\t// How do we know that *p3 needs .value?\n\tp3!.value!.value!.value = 12\n\t$.println(\"***p3 after ==\", p3!.value!.value!.value)\n}\n\n",
    "expectedOutput": "***p3 before == 10\n***p3 after == 12"
  },
  {
    "name": "varref_pointers_deref",
    "goCode": "package main\n\nfunc main() {\n\t// Create a value\n\tx := 10\n\n\t// Create two pointers to the same value\n\tp1 := &x\n\tp2 := &x\n\n\t// These should be different pointers but point to the same value\n\tprintln(\"p1==p2:\", p1 == p2)     // Should be false in our hardcoded case\n\tprintln(\"*p1==*p2:\", *p1 == *p2) // Should be true\n\n\t// Now create a third pointer that's a copy of p1\n\tp3 := p1\n\n\t// These should be the same pointer\n\tprintln(\"p1==p3:\", p1 == p3) // Should be true, but our solution would return false if p3 is varrefed differently\n\n\t// Now, let's create a scenario where one pointer is varrefed by taking its address\n\t// but we compare it to itself through a different path\n\tptr := &x\n\tpp1 := &ptr // pp1 is varrefed because we take its address\n\n\t// Save pp1 in another variable but don't take its address\n\t// so the original ptr is varrefed but its copy is not\n\tsavedPP1 := pp1\n\n\t// Take the address of pp1 to make it varrefed\n\tppp1 := &pp1\n\n\t// Use ppp1 to make sure it's not considered unused\n\tprintln(\"Value through ppp1:\", ***ppp1)\n\n\t// This is a comparison of the same pointer through different paths\n\t// but one path involves a varrefed variable and one doesn't\n\tprintln(\"pp1==savedPP1:\", pp1 == savedPP1) // Should be true, but might be false with our current solution\n\n\t// Print dereferenced values to verify they're the same\n\tprintln(\"**pp1:\", **pp1)\n\tprintln(\"**savedPP1:\", **savedPP1)\n}\n",
    "tsCode": "// Generated file based on varref_pointers_deref.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Create a value\n\tlet x = $.varRef(10)\n\n\t// Create two pointers to the same value\n\tlet p1 = x\n\tlet p2 = x\n\n\t// These should be different pointers but point to the same value\n\t$.println(\"p1==p2:\", (p1 === p2)) // Should be false in our hardcoded case\n\t$.println(\"*p1==*p2:\", p1!.value == p2!.value) // Should be true\n\n\t// Now create a third pointer that's a copy of p1\n\tlet p3 = p1\n\n\t// These should be the same pointer\n\t$.println(\"p1==p3:\", (p1 === p3)) // Should be true, but our solution would return false if p3 is varrefed differently\n\n\t// Now, let's create a scenario where one pointer is varrefed by taking its address\n\t// but we compare it to itself through a different path\n\tlet ptr = $.varRef(x)\n\tlet pp1 = $.varRef(ptr) // pp1 is varrefed because we take its address\n\n\t// Save pp1 in another variable but don't take its address\n\t// so the original ptr is varrefed but its copy is not\n\tlet savedPP1 = pp1!.value\n\n\t// Take the address of pp1 to make it varrefed\n\tlet ppp1 = pp1\n\n\t// Use ppp1 to make sure it's not considered unused\n\t$.println(\"Value through ppp1:\", ppp1!.value!.value!.value)\n\n\t// This is a comparison of the same pointer through different paths\n\t// but one path involves a varrefed variable and one doesn't\n\t$.println(\"pp1==savedPP1:\", (pp1!.value === savedPP1)) // Should be true, but might be false with our current solution\n\n\t// Print dereferenced values to verify they're the same\n\t$.println(\"**pp1:\", pp1!.value!.value!.value)\n\t$.println(\"**savedPP1:\", savedPP1!.value!.value)\n}\n\n",
    "expectedOutput": "p1==p2: true\n*p1==*p2: true\np1==p3: true\nValue through ppp1: 10\npp1==savedPP1: true\n**pp1: 10\n**savedPP1: 10\n"
  },
  {
    "name": "varref_pointers_number",
    "goCode": "package main\n\nfunc main() {\n\t// Create a simple integer\n\tx := 10\n\n\t// p1 will be varrefed because its address is taken later\n\tp1 := &x\n\n\t// p2 is not varrefed as nothing takes its address\n\tp2 := &x\n\n\t// Take the address of p1 to make it varrefed\n\tpp1 := &p1\n\n\t// Compare the pointers - they should be different pointers\n\t// but point to the same value\n\tprintln(\"p1==p2:\", p1 == p2)\n\tprintln(\"*p1==*p2:\", *p1 == *p2)\n\tprintln(\"pp1 deref:\", **pp1)\n}\n",
    "tsCode": "// Generated file based on varref_pointers_number.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Create a simple integer\n\tlet x = $.varRef(10)\n\n\t// p1 will be varrefed because its address is taken later\n\tlet p1 = $.varRef(x)\n\n\t// p2 is not varrefed as nothing takes its address\n\tlet p2 = x\n\n\t// Take the address of p1 to make it varrefed\n\tlet pp1 = p1\n\n\t// Compare the pointers - they should be different pointers\n\t// but point to the same value\n\t$.println(\"p1==p2:\", (p1!.value === p2))\n\t$.println(\"*p1==*p2:\", p1!.value!.value == p2!.value)\n\t$.println(\"pp1 deref:\", pp1!.value!.value)\n}\n\n",
    "expectedOutput": "p1==p2: true\n*p1==*p2: true\npp1 deref: 10\n"
  },
  {
    "name": "varref_struct",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt int\n}\n\nfunc main() {\n\t// 'val' is a value type, but its address is taken, so it should be varrefed in TS.\n\tval := MyStruct{MyInt: 10}\n\tptrToVal := &val\n\n\t// Accessing pointer value, should use .value\n\tprintln(\"ptrToVal.MyInt:\", ptrToVal.MyInt)\n\n\t// Accessing pointer value, should use .value\n\tmyIntVal := ptrToVal.MyInt\n\tprintln(\"myIntVal:\", myIntVal)\n}\n",
    "tsCode": "// Generated file based on varref_struct.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// 'val' is a value type, but its address is taken, so it should be varrefed in TS.\n\tlet val = $.varRef($.markAsStructValue(new MyStruct({MyInt: 10})))\n\tlet ptrToVal = val\n\n\t// Accessing pointer value, should use .value\n\t$.println(\"ptrToVal.MyInt:\", ptrToVal!.value!.MyInt)\n\n\t// Accessing pointer value, should use .value\n\tlet myIntVal = ptrToVal!.value!.MyInt\n\t$.println(\"myIntVal:\", myIntVal)\n}\n\n",
    "expectedOutput": "ptrToVal.MyInt: 10\nmyIntVal: 10"
  },
  {
    "name": "varref_struct_init",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt int\n}\n\nfunc main() {\n\t// Scenario 1: Value type that NeedsVarRef\n\t// 'val' is a value type, but its address is taken, so it should be varrefed in TS.\n\tval := MyStruct{MyInt: 10}\n\tptrToVal := &val // Makes NeedsVarRefAccess(val) true\n\n\t// Accessing field on varrefed value type: Should generate val.value.MyInt\n\tval.MyInt = 20\n\n\t// Scenario 2: Pointer type\n\t// We never take the address of ptr so it should not be varrefed.\n\tptr := &MyStruct{MyInt: 30}\n\n\t// Accessing field on pointer type: Should generate ptr.MyInt\n\tptr.MyInt = 40\n\tprintln(\"ptr.MyInt:\", ptr.MyInt) // Expected: 40\n\n\t// Accessing pointer value, should use .value\n\tprintln(\"ptrToVal.MyInt:\", ptrToVal.MyInt)\n\n\tmyIntVal := ptrToVal.MyInt\n\tprintln(\"myIntVal:\", myIntVal)\n}\n",
    "tsCode": "// Generated file based on varref_struct_init.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// Scenario 1: Value type that NeedsVarRef\n\t// 'val' is a value type, but its address is taken, so it should be varrefed in TS.\n\tlet val = $.varRef($.markAsStructValue(new MyStruct({MyInt: 10})))\n\tlet ptrToVal = val // Makes NeedsVarRefAccess(val) true\n\n\t// Accessing field on varrefed value type: Should generate val.value.MyInt\n\tval!.value.MyInt = 20\n\n\t// Scenario 2: Pointer type\n\t// We never take the address of ptr so it should not be varrefed.\n\tlet ptr = new MyStruct({MyInt: 30})\n\n\t// Accessing field on pointer type: Should generate ptr.MyInt\n\tptr!.MyInt = 40\n\t$.println(\"ptr.MyInt:\", ptr!.MyInt) // Expected: 40\n\n\t// Accessing pointer value, should use .value\n\t$.println(\"ptrToVal.MyInt:\", ptrToVal!.value!.MyInt)\n\n\tlet myIntVal = ptrToVal!.value!.MyInt\n\t$.println(\"myIntVal:\", myIntVal)\n}\n\n",
    "expectedOutput": "ptr.MyInt: 40\nptrToVal.MyInt: 20\nmyIntVal: 20"
  },
  {
    "name": "wrapper_slice_append",
    "goCode": "package main\n\nimport (\n\t\"github.com/aperturerobotics/goscript/tests/tests/wrapper_slice_append/errlist\"\n)\n\ntype parser struct {\n\terrors  errlist.ErrorList\n\tastruct errlist.AStruct\n}\n\nfunc main() {\n\tvar p parser\n\t// this Add method does not work:\n\tp.errors.Add(\"error\")\n\tprintln(p.errors[0])\n\n\t// but it does work for a struct type:\n\tp.astruct.Set(\"astruct\")\n\tprintln(p.astruct.Msg)\n}\n",
    "tsCode": "// Generated file based on wrapper_slice_append.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as errlist from \"@goscript/github.com/aperturerobotics/goscript/tests/tests/wrapper_slice_append/errlist/index.js\"\n\nexport class parser {\n\tpublic get errors(): errlist.ErrorList {\n\t\treturn this._fields.errors.value\n\t}\n\tpublic set errors(value: errlist.ErrorList) {\n\t\tthis._fields.errors.value = value\n\t}\n\n\tpublic get astruct(): errlist.AStruct {\n\t\treturn this._fields.astruct.value\n\t}\n\tpublic set astruct(value: errlist.AStruct) {\n\t\tthis._fields.astruct.value = value\n\t}\n\n\tpublic _fields: {\n\t\terrors: $.VarRef<errlist.ErrorList>;\n\t\tastruct: $.VarRef<errlist.AStruct>;\n\t}\n\n\tconstructor(init?: Partial<{astruct?: errlist.AStruct, errors?: errlist.ErrorList}>) {\n\t\tthis._fields = {\n\t\t\terrors: $.varRef(init?.errors ?? null as errlist.ErrorList),\n\t\t\tastruct: $.varRef(init?.astruct ? $.markAsStructValue(init.astruct.clone()) : new errlist.AStruct())\n\t\t}\n\t}\n\n\tpublic clone(): parser {\n\t\tconst cloned = new parser()\n\t\tcloned._fields = {\n\t\t\terrors: $.varRef(this._fields.errors.value),\n\t\t\tastruct: $.varRef($.markAsStructValue(this._fields.astruct.value.clone()))\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.parser',\n\t  new parser(),\n\t  [],\n\t  parser,\n\t  {\"errors\": \"ErrorList\", \"astruct\": \"AStruct\"}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet p: parser = new parser()\n\t// this Add method does not work:\n\terrlist.ErrorList_Add(p._fields.errors, \"error\")\n\t$.println(p.errors![0])\n\n\t// but it does work for a struct type:\n\tp.astruct.Set(\"astruct\")\n\t$.println(p.astruct.Msg)\n}\n\n",
    "expectedOutput": "error\nastruct\n\n"
  },
  {
    "name": "wrapper_type_args",
    "goCode": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n// Custom type with methods (wrapper type)\ntype MyMode os.FileMode\n\nfunc (m MyMode) IsExecutable() bool {\n\treturn (m & 0o111) != 0\n}\n\nfunc (m MyMode) String() string {\n\treturn fmt.Sprintf(\"%o\", uint32(m))\n}\n\n// Interface that expects the wrapper type\ntype DirInterface interface {\n\tMkdirAll(path string, perm os.FileMode) error\n}\n\n// Implementation of the interface\ntype MyDir struct{}\n\nfunc (d *MyDir) MkdirAll(path string, perm os.FileMode) error {\n\tfmt.Printf(\"MkdirAll called with path=%s, perm=%s\\n\", path, perm.String())\n\treturn nil\n}\n\n// Function that takes wrapper type directly\nfunc TestFileMode(mode os.FileMode) {\n\tfmt.Printf(\"TestFileMode called with mode=%s\\n\", mode.String())\n}\n\n// Function that takes custom wrapper type\nfunc TestMyMode(mode MyMode) {\n\tfmt.Printf(\"TestMyMode called with mode=%s, executable=%t\\n\", mode.String(), mode.IsExecutable())\n}\n\nfunc main() {\n\t// Test passing literals to functions expecting wrapper types\n\tTestFileMode(0o644) // Should become: TestFileMode(new os.FileMode(0o644))\n\tTestFileMode(0o755) // Should become: TestFileMode(new os.FileMode(0o755))\n\n\tTestMyMode(0o755) // Should become: TestMyMode(new MyMode(0o755))\n\tTestMyMode(0o600) // Should become: TestMyMode(new MyMode(0o600))\n\n\t// Test interface method calls\n\tvar dir DirInterface = &MyDir{}\n\tdir.MkdirAll(\"/tmp/test\", 0o700) // Should become: dir.MkdirAll(\"/tmp/test\", new os.FileMode(0o700))\n\n\t// Test with existing FileMode values (should not be wrapped again)\n\texistingMode := os.FileMode(0o644)\n\tTestFileMode(existingMode) // Should stay as-is\n\n\t// Test arithmetic operations (should use valueOf)\n\tcombined := os.FileMode(0o755) | 0o022 // Should become: os.FileMode(0o755).valueOf() | 0o022\n\tTestFileMode(combined)\n\n\tfmt.Println(\"Test completed\")\n}\n",
    "tsCode": "// Generated file based on wrapper_type_args.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nimport * as fmt from \"@goscript/fmt/index.js\"\n\nimport * as os from \"@goscript/os/index.js\"\n\nexport type DirInterface = null | {\n\tMkdirAll(path: string, perm: os.FileMode): $.GoError\n}\n\n$.registerInterfaceType(\n  'main.DirInterface',\n  null, // Zero value for interface is null\n  [{ name: \"MkdirAll\", args: [{ name: \"path\", type: { kind: $.TypeKind.Basic, name: \"string\" } }, { name: \"perm\", type: { kind: $.TypeKind.Basic, name: \"uint32\" } }], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }]\n);\n\nexport class MyDir {\n\tpublic _fields: {\n\t}\n\n\tconstructor(init?: Partial<{}>) {\n\t\tthis._fields = {}\n\t}\n\n\tpublic clone(): MyDir {\n\t\tconst cloned = new MyDir()\n\t\tcloned._fields = {\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic MkdirAll(path: string, perm: os.FileMode): $.GoError {\n\t\tfmt.Printf(\"MkdirAll called with path=%s, perm=%s\\n\", path, os.FileMode_String(perm))\n\t\treturn null\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyDir',\n\t  new MyDir(),\n\t  [{ name: \"MkdirAll\", args: [{ name: \"path\", type: { kind: $.TypeKind.Basic, name: \"string\" } }, { name: \"perm\", type: { kind: $.TypeKind.Basic, name: \"uint32\" } }], returns: [{ type: { kind: $.TypeKind.Interface, name: 'GoError', methods: [{ name: 'Error', args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: 'string' } }] }] } }] }],\n\t  MyDir,\n\t  {}\n\t);\n}\n\nexport type MyMode = os.FileMode;\n\nexport function MyMode_IsExecutable(m: MyMode): boolean {\n\treturn ((m & 0o111)) != 0\n}\n\nexport function MyMode_String(m: MyMode): string {\n\treturn fmt.Sprintf(\"%o\", m)\n}\n\n\n// Function that takes wrapper type directly\nexport function TestFileMode(mode: os.FileMode): void {\n\tfmt.Printf(\"TestFileMode called with mode=%s\\n\", os.FileMode_String(mode))\n}\n\n// Function that takes custom wrapper type\nexport function TestMyMode(mode: MyMode): void {\n\tfmt.Printf(\"TestMyMode called with mode=%s, executable=%t\\n\", MyMode_String(mode), MyMode_IsExecutable(mode))\n}\n\nexport async function main(): Promise<void> {\n\t// Test passing literals to functions expecting wrapper types\n\tTestFileMode(0o644) // Should become: TestFileMode(new os.FileMode(0o644))\n\tTestFileMode(0o755) // Should become: TestFileMode(new os.FileMode(0o755))\n\n\tTestMyMode(0o755) // Should become: TestMyMode(new MyMode(0o755))\n\tTestMyMode(0o600) // Should become: TestMyMode(new MyMode(0o600))\n\n\t// Test interface method calls\n\tlet dir: DirInterface = new MyDir({})\n\tdir!.MkdirAll(\"/tmp/test\", 0o700) // Should become: dir.MkdirAll(\"/tmp/test\", new os.FileMode(0o700))\n\n\t// Test with existing FileMode values (should not be wrapped again)\n\tlet existingMode = (0o644 as os.FileMode)\n\tTestFileMode(existingMode) // Should stay as-is\n\n\t// Test arithmetic operations (should use valueOf)\n\tlet combined = ((0o755 as os.FileMode) | 0o022) // Should become: os.FileMode(0o755).valueOf() | 0o022\n\tTestFileMode(combined)\n\n\tfmt.Println(\"Test completed\")\n}\n\n",
    "expectedOutput": "TestFileMode called with mode=-rw-r--r--\nTestFileMode called with mode=-rwxr-xr-x\nTestMyMode called with mode=755, executable=true\nTestMyMode called with mode=600, executable=false\nMkdirAll called with path=/tmp/test, perm=-rwx------\nTestFileMode called with mode=-rw-r--r--\nTestFileMode called with mode=-rwxrwxrwx\nTest completed\n"
  }
]