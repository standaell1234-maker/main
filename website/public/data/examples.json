[
  {
    "name": "basic_arithmetic",
    "title": "Arithmetic",
    "description": "Basic arithmetic operations",
    "goCode": "package main\n\nfunc main() {\n\t// === Basic Arithmetic ===\n\tadd := 2 + 3\n\tsub := 10 - 4\n\tmul := 6 * 7\n\tdiv := 20 / 5\n\tmod := 17 % 3\n\tprintln(\"Addition: Expected: 5, Actual:\", add)\n\tprintln(\"Subtraction: Expected: 6, Actual:\", sub)\n\tprintln(\"Multiplication: Expected: 42, Actual:\", mul)\n\tprintln(\"Division: Expected: 4, Actual:\", div)\n\tprintln(\"Modulus: Expected: 2, Actual:\", mod)\n}\n",
    "tsCode": "// Generated file based on basic_arithmetic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// === Basic Arithmetic ===\n\tlet add = 2 + 3\n\tlet sub = 10 - 4\n\tlet mul = 6 * 7\n\tlet div = Math.trunc(20 / 5)\n\tlet mod = 17 % 3\n\t$.println(\"Addition: Expected: 5, Actual:\", add)\n\t$.println(\"Subtraction: Expected: 6, Actual:\", sub)\n\t$.println(\"Multiplication: Expected: 42, Actual:\", mul)\n\t$.println(\"Division: Expected: 4, Actual:\", div)\n\t$.println(\"Modulus: Expected: 2, Actual:\", mod)\n}\n\n",
    "expectedOutput": "Addition: Expected: 5, Actual: 5\nSubtraction: Expected: 6, Actual: 6\nMultiplication: Expected: 42, Actual: 42\nDivision: Expected: 4, Actual: 4\nModulus: Expected: 2, Actual: 2"
  },
  {
    "name": "boolean_logic",
    "title": "Boolean Logic",
    "description": "Boolean operators and comparisons",
    "goCode": "package main\n\nfunc main() {\n\t// === Boolean Logic ===\n\ta := true\n\tb := false\n\tand := a && b\n\tor := a || b\n\tnotA := !a\n\tprintln(\"AND: Expected: false, Actual:\", and)\n\tprintln(\"OR: Expected: true, Actual:\", or)\n\tprintln(\"NOT: Expected: false, Actual:\", notA)\n}\n",
    "tsCode": "// Generated file based on boolean_logic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// === Boolean Logic ===\n\tlet a = true\n\tlet b = false\n\tlet and = a && b\n\tlet or = a || b\n\tlet notA = !a\n\t$.println(\"AND: Expected: false, Actual:\", and)\n\t$.println(\"OR: Expected: true, Actual:\", or)\n\t$.println(\"NOT: Expected: false, Actual:\", notA)\n}\n\n",
    "expectedOutput": "AND: Expected: false, Actual: false\nOR: Expected: true, Actual: true\nNOT: Expected: false, Actual: false"
  },
  {
    "name": "if_statement",
    "title": "If Statement",
    "description": "Conditional statements",
    "goCode": "package main\n\nfunc main() {\n\t// === If Statement ===\n\tn := 7\n\tif n%2 == 0 {\n\t\tprintln(\"Even: Expected: (no output)\")\n\t} else {\n\t\tprintln(\"Odd: Expected: Odd, Actual: Odd\")\n\t}\n}\n",
    "tsCode": "// Generated file based on if_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// === If Statement ===\n\tlet n = 7\n\tif (n % 2 == 0) {\n\t\t$.println(\"Even: Expected: (no output)\")\n\t} else {\n\t\t$.println(\"Odd: Expected: Odd, Actual: Odd\")\n\t}\n}\n\n",
    "expectedOutput": "Odd: Expected: Odd, Actual: Odd"
  },
  {
    "name": "for_loop_basic",
    "title": "For Loop",
    "description": "Loop constructs",
    "goCode": "package main\n\nfunc main() {\n\tprintln(\"Starting loop\")\n\tfor i := 0; i < 3; i++ {\n\t\tprintln(\"Iteration:\", i)\n\t}\n\tprintln(\"Loop finished\")\n\n\tprintln(\"Starting loop\")\n\tx := 0\n\tfor range 5 {\n\t\tprintln(\"Iteration:\", x)\n\t\tx++\n\t}\n\tprintln(\"Loop finished\")\n}\n",
    "tsCode": "// Generated file based on for_loop_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t$.println(\"Starting loop\")\n\tfor (let i = 0; i < 3; i++) {\n\t\t$.println(\"Iteration:\", i)\n\t}\n\t$.println(\"Loop finished\")\n\n\t$.println(\"Starting loop\")\n\tlet x = 0\n\tfor (let _i = 0; _i < 5; _i++) {{\n\t\t$.println(\"Iteration:\", x)\n\t\tx++\n\t}\n}\n$.println(\"Loop finished\")\n}\n\n",
    "expectedOutput": "Starting loop\nIteration: 0\nIteration: 1\nIteration: 2\nLoop finished\nStarting loop\nIteration: 0\nIteration: 1\nIteration: 2\nIteration: 3\nIteration: 4\nLoop finished"
  },
  {
    "name": "for_range",
    "title": "Range Loop",
    "description": "Iterating with range",
    "goCode": "package main\n\nfunc main() {\n\tnums := []int{2, 3, 4}\n\tsum := 0\n\tfor _, num := range nums {\n\t\tsum += num\n\t}\n\tprintln(\"sum:\", sum)\n\n\tfor i, num := range nums {\n\t\tprintln(\"index:\", i, \"value:\", num)\n\t}\n\n\t// Test ranging over an array\n\tarr := [3]string{\"a\", \"b\", \"c\"}\n\tfor i, s := range arr {\n\t\tprintln(\"index:\", i, \"value:\", s)\n\t}\n\n\t// Test ranging over a string\n\tstr := \"go\"\n\tfor i, c := range str {\n\t\tprintln(\"index:\", i, \"value:\", c) // Note: c will be a rune (int32)\n\t}\n\n\t// Test ranging over a slice without key or value\n\tprintln(\"Ranging over slice (no key/value):\")\n\tfor range nums {\n\t\tprintln(\"Iterating slice\")\n\t}\n\n\t// Test ranging over an array without key or value\n\tprintln(\"Ranging over array (no key/value):\")\n\tfor range arr {\n\t\tprintln(\"Iterating array\")\n\t}\n\n\t// Test ranging over a string without key or value\n\tprintln(\"Ranging over string (no key/value):\")\n\tfor range str {\n\t\tprintln(\"Iterating string\")\n\t}\n}\n",
    "tsCode": "// Generated file based on for_range.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet nums = $.arrayToSlice<number>([2, 3, 4])\n\tlet sum = 0\n\tfor (let _i = 0; _i < $.len(nums); _i++) {\n\t\tlet num = nums![_i]\n\t\t{\n\t\t\tsum += num\n\t\t}\n\t}\n\t$.println(\"sum:\", sum)\n\n\tfor (let i = 0; i < $.len(nums); i++) {\n\t\tlet num = nums![i]\n\t\t{\n\t\t\t$.println(\"index:\", i, \"value:\", num)\n\t\t}\n\t}\n\n\t// Test ranging over an array\n\tlet arr = $.arrayToSlice<string>([\"a\", \"b\", \"c\"])\n\tfor (let i = 0; i < $.len(arr); i++) {\n\t\tlet s = arr![i]\n\t\t{\n\t\t\t$.println(\"index:\", i, \"value:\", s)\n\t\t}\n\t}\n\n\t// Test ranging over a string\n\tlet str = \"go\"\n\n\t// Note: c will be a rune (int32)\n\t{\n\t\tconst _runes = $.stringToRunes(str)\n\t\tfor (let i = 0; i < _runes.length; i++) {\n\t\t\tlet c = _runes[i]\n\t\t\t{\n\t\t\t\t$.println(\"index:\", i, \"value:\", c) // Note: c will be a rune (int32)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test ranging over a slice without key or value\n\t$.println(\"Ranging over slice (no key/value):\")\n\tfor (let _i = 0; _i < $.len(nums); _i++) {\n\t\t{\n\t\t\t$.println(\"Iterating slice\")\n\t\t}\n\t}\n\n\t// Test ranging over an array without key or value\n\t$.println(\"Ranging over array (no key/value):\")\n\tfor (let _i = 0; _i < $.len(arr); _i++) {\n\t\t{\n\t\t\t$.println(\"Iterating array\")\n\t\t}\n\t}\n\n\t// Test ranging over a string without key or value\n\t$.println(\"Ranging over string (no key/value):\")\n\t{\n\t\tconst _runes = $.stringToRunes(str)\n\t\tfor (let i = 0; i < _runes.length; i++) {\n\t\t\t{\n\t\t\t\t$.println(\"Iterating string\")\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "sum: 9\nindex: 0 value: 2\nindex: 1 value: 3\nindex: 2 value: 4\nindex: 0 value: a\nindex: 1 value: b\nindex: 2 value: c\nindex: 0 value: 103\nindex: 1 value: 111\nRanging over slice (no key/value):\nIterating slice\nIterating slice\nIterating slice\nRanging over array (no key/value):\nIterating array\nIterating array\nIterating array\nRanging over string (no key/value):\nIterating string\nIterating string"
  },
  {
    "name": "switch_statement",
    "title": "Switch",
    "description": "Switch statement patterns",
    "goCode": "package main\n\nfunc main() {\n\ti := 2\n\tprintln(\"Integer switch:\")\n\tswitch i {\n\tcase 1:\n\t\tprintln(\"one\")\n\tcase 2:\n\t\tprintln(\"two\")\n\tcase 3:\n\t\tprintln(\"three\")\n\tdefault:\n\t\tprintln(\"other integer\")\n\t}\n\n\ts := \"hello\"\n\tprintln(\"\\nString switch:\")\n\tswitch s {\n\tcase \"world\":\n\t\tprintln(\"world\")\n\tcase \"hello\":\n\t\tprintln(\"hello\")\n\tdefault:\n\t\tprintln(\"other string\")\n\t}\n\tx := -5\n\tprintln(\"\\nSwitch without expression:\")\n\tswitch {\n\tcase x < 0:\n\t\tprintln(\"negative\")\n\tcase x == 0:\n\t\tprintln(\"zero\")\n\tdefault: // x > 0\n\t\tprintln(\"positive\")\n\t}\n\n\tx = 0\n\tprintln(\"\\nSwitch without expression (zero):\")\n\tswitch {\n\tcase x < 0:\n\t\tprintln(\"negative\")\n\tcase x == 0:\n\t\tprintln(\"zero\")\n\tdefault: // x > 0\n\t\tprintln(\"positive\")\n\t}\n\n\tx = 10\n\tprintln(\"\\nSwitch without expression (positive):\")\n\tswitch {\n\tcase x < 0:\n\t\tprintln(\"negative\")\n\tcase x == 0:\n\t\tprintln(\"zero\")\n\tdefault: // x > 0\n\t\tprintln(\"positive\")\n\t}\n}\n",
    "tsCode": "// Generated file based on switch_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet i = 2\n\t$.println(\"Integer switch:\")\n\tswitch (i) {\n\t\tcase 1: {\n\t\t\t$.println(\"one\")\n\t\t\tbreak\n\t\t}\n\t\tcase 2: {\n\t\t\t$.println(\"two\")\n\t\t\tbreak\n\t\t}\n\t\tcase 3: {\n\t\t\t$.println(\"three\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"other integer\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\tlet s = \"hello\"\n\t$.println(\"\\nString switch:\")\n\tswitch (s) {\n\t\tcase \"world\": {\n\t\t\t$.println(\"world\")\n\t\t\tbreak\n\t\t}\n\t\tcase \"hello\": {\n\t\t\t$.println(\"hello\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"other string\")\n\t\t\tbreak\n\t\t}\n\t}\n\tlet x = -5\n\t$.println(\"\\nSwitch without expression:\")\n\n\t// x > 0\n\tswitch (true) {\n\t\tcase x < 0: {\n\t\t\t$.println(\"negative\")\n\t\t\tbreak\n\t\t}\n\t\tcase x == 0: {\n\t\t\t$.println(\"zero\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"positive\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\tx = 0\n\t$.println(\"\\nSwitch without expression (zero):\")\n\n\t// x > 0\n\tswitch (true) {\n\t\tcase x < 0: {\n\t\t\t$.println(\"negative\")\n\t\t\tbreak\n\t\t}\n\t\tcase x == 0: {\n\t\t\t$.println(\"zero\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"positive\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\tx = 10\n\t$.println(\"\\nSwitch without expression (positive):\")\n\n\t// x > 0\n\tswitch (true) {\n\t\tcase x < 0: {\n\t\t\t$.println(\"negative\")\n\t\t\tbreak\n\t\t}\n\t\tcase x == 0: {\n\t\t\t$.println(\"zero\")\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\t$.println(\"positive\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Integer switch:\ntwo\n\nString switch:\nhello\n\nSwitch without expression:\nnegative\n\nSwitch without expression (zero):\nzero\n\nSwitch without expression (positive):\npositive"
  },
  {
    "name": "comments_struct",
    "title": "Structs",
    "description": "Struct definitions and usage",
    "goCode": "package main\n\n// TestStruct is a struct with commented fields.\ntype TestStruct struct {\n\t// IntField is a commented integer field.\n\tIntField int\n\t// StringField is a commented string field.\n\tStringField string\n}\n\nfunc main() {\n\ts := TestStruct{\n\t\tIntField:    42,\n\t\tStringField: \"hello\",\n\t}\n\tprintln(\"IntField:\", s.IntField)\n\tprintln(\"StringField:\", s.StringField)\n}\n",
    "tsCode": "// Generated file based on comments_struct.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class TestStruct {\n\t// IntField is a commented integer field.\n\tpublic get IntField(): number {\n\t\treturn this._fields.IntField.value\n\t}\n\tpublic set IntField(value: number) {\n\t\tthis._fields.IntField.value = value\n\t}\n\n\t// StringField is a commented string field.\n\tpublic get StringField(): string {\n\t\treturn this._fields.StringField.value\n\t}\n\tpublic set StringField(value: string) {\n\t\tthis._fields.StringField.value = value\n\t}\n\n\tpublic _fields: {\n\t\tIntField: $.VarRef<number>;\n\t\tStringField: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{IntField?: number, StringField?: string}>) {\n\t\tthis._fields = {\n\t\t\tIntField: $.varRef(init?.IntField ?? 0),\n\t\t\tStringField: $.varRef(init?.StringField ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): TestStruct {\n\t\tconst cloned = new TestStruct()\n\t\tcloned._fields = {\n\t\t\tIntField: $.varRef(this._fields.IntField.value),\n\t\t\tStringField: $.varRef(this._fields.StringField.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.TestStruct',\n\t  new TestStruct(),\n\t  [],\n\t  TestStruct,\n\t  {\"IntField\": { kind: $.TypeKind.Basic, name: \"int\" }, \"StringField\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet s = $.markAsStructValue(new TestStruct({IntField: 42, StringField: \"hello\"}))\n\t$.println(\"IntField:\", s.IntField)\n\t$.println(\"StringField:\", s.StringField)\n}\n\n",
    "expectedOutput": "IntField: 42\nStringField: hello"
  },
  {
    "name": "struct_field_access",
    "title": "Struct Fields",
    "description": "Accessing struct fields",
    "goCode": "package main\n\ntype MyStruct struct {\n\tMyInt    int\n\tMyString string\n}\n\nfunc main() {\n\t// === Struct Field Access ===\n\tms := MyStruct{MyInt: 42, MyString: \"foo\"}\n\tprintln(\"MyInt: Expected: 42, Actual:\", ms.MyInt)\n\tprintln(\"MyString: Expected: foo, Actual:\", ms.MyString)\n}\n",
    "tsCode": "// Generated file based on struct_field_access.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get MyInt(): number {\n\t\treturn this._fields.MyInt.value\n\t}\n\tpublic set MyInt(value: number) {\n\t\tthis._fields.MyInt.value = value\n\t}\n\n\tpublic get MyString(): string {\n\t\treturn this._fields.MyString.value\n\t}\n\tpublic set MyString(value: string) {\n\t\tthis._fields.MyString.value = value\n\t}\n\n\tpublic _fields: {\n\t\tMyInt: $.VarRef<number>;\n\t\tMyString: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{MyInt?: number, MyString?: string}>) {\n\t\tthis._fields = {\n\t\t\tMyInt: $.varRef(init?.MyInt ?? 0),\n\t\t\tMyString: $.varRef(init?.MyString ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tMyInt: $.varRef(this._fields.MyInt.value),\n\t\t\tMyString: $.varRef(this._fields.MyString.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"MyInt\": { kind: $.TypeKind.Basic, name: \"int\" }, \"MyString\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\t// === Struct Field Access ===\n\tlet ms = $.markAsStructValue(new MyStruct({MyInt: 42, MyString: \"foo\"}))\n\t$.println(\"MyInt: Expected: 42, Actual:\", ms.MyInt)\n\t$.println(\"MyString: Expected: foo, Actual:\", ms.MyString)\n}\n\n",
    "expectedOutput": "MyInt: Expected: 42, Actual: 42\nMyString: Expected: foo, Actual: foo"
  },
  {
    "name": "simple_interface",
    "title": "Interfaces",
    "description": "Interface type assertions",
    "goCode": "package main\n\ntype MyStruct struct {\n\tValue int\n}\n\nfunc main() {\n\toriginal := MyStruct{Value: 30}\n\tpAlias := &original\n\n\tvar jAlias interface{} = pAlias\n\n\t_, ok := jAlias.(*MyStruct)\n\tprintln(\"pointer assertion result:\", ok)\n}\n",
    "tsCode": "// Generated file based on simple_interface.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet original = $.varRef($.markAsStructValue(new MyStruct({Value: 30})))\n\tlet pAlias = original\n\n\tlet jAlias: null | any = pAlias\n\n\tlet { ok: ok } = $.typeAssert<MyStruct | null>(jAlias, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'})\n\t$.println(\"pointer assertion result:\", ok)\n}\n\n",
    "expectedOutput": "pointer assertion result: true\n"
  },
  {
    "name": "slice",
    "title": "Slices",
    "description": "Slice creation and manipulation",
    "goCode": "package main\n\nfunc main() {\n\t// --- Original Tests ---\n\tprintln(\"--- Original Tests ---\")\n\t// Create a slice of integers with length 5 and capacity 10\n\ts := make([]int, 5, 10)\n\tprintln(len(s)) // 5\n\tprintln(cap(s)) // 10\n\n\t// Create a slice of strings with length 3\n\ts2 := make([]string, 3)\n\tprintln(len(s2)) // 3\n\tprintln(cap(s2)) // 3\n\n\t// Assign values\n\ts[0] = 10\n\ts[4] = 20\n\ts2[1] = \"hello\"\n\n\tprintln(s[0])  // 10\n\tprintln(s[4])  // 20\n\tprintln(s2[1]) // hello\n\n\t// --- New Tests ---\n\tprintln(\"--- New Tests ---\")\n\n\t// Create slice from array literal\n\tarrLit := [5]int{1, 2, 3, 4, 5}\n\tsliceFromLit := arrLit[:]\n\tprintln(len(sliceFromLit)) // 5\n\tprintln(cap(sliceFromLit)) // 5\n\tprintln(sliceFromLit[0])   // 1\n\tprintln(sliceFromLit[4])   // 5\n\n\t// Create slice from array variable\n\tarrVar := [4]string{\"a\", \"b\", \"c\", \"d\"}\n\tsliceFromVar := arrVar[:]\n\tprintln(len(sliceFromVar)) // 4\n\tprintln(cap(sliceFromVar)) // 4\n\tprintln(sliceFromVar[0])   // a\n\tprintln(sliceFromVar[3])   // d\n\n\t// Create slice with specific indices\n\tsliceIndices := arrVar[1:3] // [\"b\", \"c\"]\n\tprintln(len(sliceIndices))  // 2\n\tprintln(cap(sliceIndices))  // 3 (cap is from start index to end of original array)\n\tprintln(sliceIndices[0])    // b\n\tprintln(sliceIndices[1])    // c\n\n\t// Create slice with 0 len/cap and append\n\tprintln(\"--- Zero len/cap append ---\")\n\tzeroSlice := make([]int, 0, 0)\n\tprintln(len(zeroSlice)) // 0\n\tprintln(cap(zeroSlice)) // 0\n\tzeroSlice = append(zeroSlice, 100)\n\tprintln(len(zeroSlice)) // 1\n\tprintln(cap(zeroSlice)) // 1 (or more, implementation dependent)\n\tprintln(zeroSlice[0])   // 100\n\tzeroSlice = append(zeroSlice, 200)\n\tprintln(len(zeroSlice)) // 2\n\tprintln(cap(zeroSlice)) // 2 (or more)\n\tprintln(zeroSlice[1])   // 200\n\n\t// Modify slice, check original array\n\tprintln(\"--- Modify slice, check array ---\")\n\tmodArr := [3]int{10, 20, 30}\n\tmodSlice := modArr[:]\n\tmodSlice[1] = 25     // Modify slice\n\tprintln(modArr[1])   // 25 (original array should be modified)\n\tprintln(modSlice[1]) // 25\n\n\t// Modify array, check slice\n\tprintln(\"--- Modify array, check slice ---\")\n\tmodArr[0] = 15       // Modify array\n\tprintln(modArr[0])   // 15\n\tprintln(modSlice[0]) // 15 (slice should reflect change)\n\n\t// Append to sub-slice within capacity\n\tprintln(\"--- Append sub-slice w/in capacity ---\")\n\tappendArr := [5]int{1, 2, 3, 4, 5}\n\tappendSlice1 := appendArr[0:2]           // len 2, cap 5; [1, 2]\n\tprintln(len(appendSlice1))               // 2\n\tprintln(cap(appendSlice1))               // 5\n\tappendSlice2 := append(appendSlice1, 99) // Appends within original capacity\n\tprintln(len(appendSlice2))               // 3\n\tprintln(cap(appendSlice2))               // 5\n\tprintln(appendSlice2[2])                 // 99\n\tprintln(appendArr[2])                    // 99 (original array modified)\n\n\t// Append to sub-slice exceeding capacity\n\tprintln(\"--- Append sub-slice exceed capacity ---\")\n\tappendSlice3 := appendArr[3:5]            // len 2, cap 2; [4, 5]\n\tprintln(len(appendSlice3))                // 2\n\tprintln(cap(appendSlice3))                // 2\n\tappendSlice4 := append(appendSlice3, 101) // Appends beyond original capacity\n\tprintln(len(appendSlice4))                // 3\n\tprintln(cap(appendSlice4))                // 4 (or more, new underlying array)\n\tprintln(appendSlice4[0])                  // 4\n\tprintln(appendSlice4[1])                  // 5\n\tprintln(appendSlice4[2])                  // 101\n\t// Original array should NOT be modified beyond its bounds by this append\n\tprintln(appendArr[0]) // 1\n\tprintln(appendArr[1]) // 2\n\tprintln(appendArr[2]) // 99 (from previous append)\n\tprintln(appendArr[3]) // 4\n\tprintln(appendArr[4]) // 5\n\n\t// Slicing a slice\n\tprintln(\"--- Slicing a slice ---\")\n\tbaseSlice := []int{0, 10, 20, 30, 40, 50}\n\tsubSlice1 := baseSlice[1:4] // [10, 20, 30], len 3, cap 5\n\tprintln(len(subSlice1))     // 3\n\tprintln(cap(subSlice1))     // 5\n\tprintln(subSlice1[0])       // 10\n\tsubSlice2 := subSlice1[1:3] // [20, 30], len 2, cap 4 (cap from subSlice1's start)\n\tprintln(len(subSlice2))     // 2\n\tprintln(cap(subSlice2))     // 4\n\tprintln(subSlice2[0])       // 20\n\tprintln(subSlice2[1])       // 30\n\tsubSlice2[0] = 22           // Modify sub-sub-slice\n\tprintln(subSlice1[1])       // 22 (subSlice1 modified)\n\tprintln(baseSlice[2])       // 22 (baseSlice modified)\n\n\t// Three-index slicing (if supported) - Check capacity\n\tprintln(\"--- Three-index slicing ---\")\n\tthreeIndexArr := [6]int{0, 1, 2, 3, 4, 5}\n\tthreeIndexSlice := threeIndexArr[1:3:4] // [1, 2], len 2, cap 3 (4-1)\n\tprintln(len(threeIndexSlice))           // 2\n\tprintln(cap(threeIndexSlice))           // 3\n\tprintln(threeIndexSlice[0])             // 1\n\tprintln(threeIndexSlice[1])             // 2\n\t// Appending should modify original array up to new capacity limit\n\tthreeIndexSlice = append(threeIndexSlice, 99)\n\tprintln(len(threeIndexSlice)) // 3\n\tprintln(cap(threeIndexSlice)) // 3\n\tprintln(threeIndexSlice[2])   // 99\n\tprintln(threeIndexArr[3])     // 99 (original modified)\n\t// Appending again should reallocate\n\tthreeIndexSlice = append(threeIndexSlice, 101)\n\tprintln(len(threeIndexSlice)) // 4\n\tprintln(cap(threeIndexSlice)) // 6 (or more)\n\tprintln(threeIndexSlice[3])   // 101\n\tprintln(threeIndexArr[4])     // 4 (original NOT modified by reallocating append)\n\n\t// --- Additional Tests for Full Coverage ---\n\tprintln(\"--- Additional Tests ---\")\n\n\t// Slice literal\n\tsliceLiteral := []int{10, 20, 30}\n\tprintln(\"Slice literal len:\", len(sliceLiteral)) // 3\n\tprintln(\"Slice literal cap:\", cap(sliceLiteral)) // 3\n\tprintln(\"Slice literal[1]:\", sliceLiteral[1])    // 20\n\n\t// Nil slice\n\tvar nilSlice []int\n\tprintln(\"Nil slice len:\", len(nilSlice)) // 0\n\tprintln(\"Nil slice cap:\", cap(nilSlice)) // 0\n\tnilSlice = append(nilSlice, 5)\n\tprintln(\"Append to nil slice len:\", len(nilSlice)) // 1\n\tprintln(\"Append to nil slice cap:\", cap(nilSlice)) // 1 (or more)\n\tprintln(\"Append to nil slice[0]:\", nilSlice[0])    // 5\n\n\t// Out-of-bounds indexing (should panic)\n\t// Note: Testing panics in compliance tests requires specific handling in the test runner.\n\t// For now, we'll add the code but expect it to fail if panics are not caught.\n\t// The runner should ideally catch these panics and verify the error type/message.\n\n\t// println(\"--- Testing out-of-bounds panic ---\")\n\t// smallSlice := []int{1}\n\t// println(smallSlice[1]) // Index out of bounds (len 1, cap 1) - should panic\n\t// smallSlice[1] = 10     // Index out of bounds - should panic\n\t// println(smallSlice[-1]) // Negative index - should panic\n\n\t// --- Slices of Slices Tests ---\n\tprintln(\"--- Slices of Slices Tests ---\")\n\n\t// Create a slice of slices of integers\n\tsliceOfSlices := [][]int{\n\t\t{1, 2, 3},\n\t\t{4, 5},\n\t\t{6, 7, 8, 9},\n\t}\n\n\tprintln(\"Length of sliceOfSlices:\", len(sliceOfSlices))   // 3\n\tprintln(\"Capacity of sliceOfSlices:\", cap(sliceOfSlices)) // 3\n\n\t// Access elements\n\tprintln(\"sliceOfSlices[0][1]:\", sliceOfSlices[0][1]) // 2\n\tprintln(\"sliceOfSlices[1][0]:\", sliceOfSlices[1][0]) // 4\n\tprintln(\"sliceOfSlices[2][3]:\", sliceOfSlices[2][3]) // 9\n\n\t// Append to inner slice (should modify the inner slice)\n\tprintln(\"--- Append to inner slice ---\")\n\tinnerSlice := sliceOfSlices[1]                      // {4, 5}, len 2, cap 2\n\tprintln(\"Length of innerSlice:\", len(innerSlice))   // 2\n\tprintln(\"Capacity of innerSlice:\", cap(innerSlice)) // 2\n\n\tinnerSlice = append(innerSlice, 50)                              // {4, 5, 50}\n\tprintln(\"Length of innerSlice after append:\", len(innerSlice))   // 3\n\tprintln(\"Capacity of innerSlice after append:\", cap(innerSlice)) // 4 (or more)\n\tprintln(\"innerSlice[2]:\", innerSlice[2])                         // 50\n\n\t// Check if the original slice of slices reflects the change (it should, as innerSlice is a view)\n\t// Note: Appending to innerSlice might reallocate its underlying array if capacity is exceeded.\n\t// If reallocated, the original sliceOfSlices will *not* see the change at that index.\n\t// This test case specifically checks the scenario where the append happens within the original capacity\n\t// or if the reallocation behavior is correctly handled by GoScript.\n\t// For this simple case, appending 50 to {4, 5} will likely cause reallocation.\n\t// Let's test appending within capacity first.\n\n\t// Create a slice of slices where inner slice has capacity for append\n\tsliceOfSlicesWithCap := [][]int{\n\t\t{1, 2, 3},\n\t\tmake([]int, 2, 5), // {0, 0}, len 2, cap 5\n\t\t{6, 7, 8, 9},\n\t}\n\tsliceOfSlicesWithCap[1][0] = 40\n\tsliceOfSlicesWithCap[1][1] = 50\n\n\tprintln(\"--- Append to inner slice with capacity ---\")\n\tinnerSliceWithCap := sliceOfSlicesWithCap[1]                      // {40, 50}, len 2, cap 5\n\tprintln(\"Length of innerSliceWithCap:\", len(innerSliceWithCap))   // 2\n\tprintln(\"Capacity of innerSliceWithCap:\", cap(innerSliceWithCap)) // 5\n\n\tinnerSliceWithCap = append(innerSliceWithCap, 60)                              // {40, 50, 60}\n\tprintln(\"Length of innerSliceWithCap after append:\", len(innerSliceWithCap))   // 3\n\tprintln(\"Capacity of innerSliceWithCap after append:\", cap(innerSliceWithCap)) // 5\n\tprintln(\"innerSliceWithCap[2]:\", innerSliceWithCap[2])                         // 60\n\n\t// Check if the original slice of slices reflects the change (it should, as append was within capacity)\n\tprintln(\"sliceOfSlicesWithCap[1][2]:\", sliceOfSlicesWithCap[1][:3][2]) // 60\n\n\t// Append to inner slice exceeding capacity\n\tprintln(\"--- Append to inner slice exceeding capacity ---\")\n\tinnerSliceExceedCap := sliceOfSlices[0]                               // {1, 2, 3}, len 3, cap 3\n\tprintln(\"Length of innerSliceExceedCap:\", len(innerSliceExceedCap))   // 3\n\tprintln(\"Capacity of innerSliceExceedCap:\", cap(innerSliceExceedCap)) // 3\n\n\tinnerSliceExceedCap = append(innerSliceExceedCap, 10, 20)                          // {1, 2, 3, 10, 20} - will reallocate\n\tprintln(\"Length of innerSliceExceedCap after append:\", len(innerSliceExceedCap))   // 5\n\tprintln(\"Capacity of innerSliceExceedCap after append:\", cap(innerSliceExceedCap)) // 6 (or more)\n\tprintln(\"innerSliceExceedCap[3]:\", innerSliceExceedCap[3])                         // 10\n\tprintln(\"innerSliceExceedCap[4]:\", innerSliceExceedCap[4])                         // 20\n\n\t// Check if the original slice of slices reflects the change (it should NOT, due to reallocation)\n\t// The original sliceOfSlices[0] should still be {1, 2, 3}\n\tprintln(\"Original sliceOfSlices[0] after inner append:\", sliceOfSlices[0][0], sliceOfSlices[0][1], sliceOfSlices[0][2]) // 1 2 3\n\n\t// Slicing a slice of slices\n\tprintln(\"--- Slicing a slice of slices ---\")\n\tsubSliceOfSlices := sliceOfSlices[1:3]                          // {{4, 5}, {6, 7, 8, 9}}, len 2, cap 2\n\tprintln(\"Length of subSliceOfSlices:\", len(subSliceOfSlices))   // 2\n\tprintln(\"Capacity of subSliceOfSlices:\", cap(subSliceOfSlices)) // 2\n\tprintln(\"subSliceOfSlices[0][0]:\", subSliceOfSlices[0][0])      // 4\n\tprintln(\"subSliceOfSlices[1][2]:\", subSliceOfSlices[1][2])      // 8\n\n\t// Modify element in sub-slice of slices (should affect original)\n\tprintln(\"--- Modify element in sub-slice of slices ---\")\n\tsubSliceOfSlices[0][1] = 55\n\tprintln(\"sliceOfSlices[1][1] after sub-slice modification:\", sliceOfSlices[1][1]) // 55\n\n\t// Append a new slice to the slice of slices\n\tprintln(\"--- Append a new slice to slice of slices ---\")\n\tsliceOfSlices = append(sliceOfSlices, []int{100, 110})\n\tprintln(\"Length of sliceOfSlices after append:\", len(sliceOfSlices))   // 4\n\tprintln(\"Capacity of sliceOfSlices after append:\", cap(sliceOfSlices)) // 6 (or more)\n\tprintln(\"sliceOfSlices[3][0]:\", sliceOfSlices[3][0])                   // 100\n\n\t// Append an existing slice to the slice of slices\n\tprintln(\"--- Append an existing slice to slice of slices ---\")\n\texistingSlice := []int{200, 210}\n\tsliceOfSlices = append(sliceOfSlices, existingSlice)\n\tprintln(\"Length of sliceOfSlices after appending existing:\", len(sliceOfSlices))   // 5\n\tprintln(\"Capacity of sliceOfSlices after appending existing:\", cap(sliceOfSlices)) // 6 (or more)\n\tprintln(\"sliceOfSlices[4][1]:\", sliceOfSlices[4][1])                               // 210\n\n\t// Modify the appended existing slice (should NOT affect the slice in sliceOfSlices if it was copied)\n\t// Go's append copies the slice header, but the underlying array is shared unless reallocation occurs.\n\t// Modifying existingSlice *after* appending it should not affect the copy in sliceOfSlices\n\t// unless they still share the underlying array and the modification is within the shared capacity.\n\t// Let's test this carefully.\n\tprintln(\"--- Modify appended existing slice ---\")\n\texistingSlice[0] = 205\n\tprintln(\"sliceOfSlices[4][0] after modifying existingSlice:\", sliceOfSlices[4][0]) // Should still be 200 if copied or shared but not modified at index 0\n\n\t// If we modify an element in the slice within sliceOfSlices, it *should* affect the original existingSlice\n\t// if they share the underlying array.\n\tprintln(\"--- Modify slice within sliceOfSlices ---\")\n\tsliceOfSlices[4][1] = 215\n\tprintln(\"existingSlice[1] after modifying slice within sliceOfSlices:\", existingSlice[1]) // Should be 215\n\n\t// Create a slice of slices using make\n\tprintln(\"--- Make slice of slices ---\")\n\tmakeSliceOfSlices := make([][]int, 2, 4)                          // len 2, cap 4\n\tprintln(\"Length of makeSliceOfSlices:\", len(makeSliceOfSlices))   // 2\n\tprintln(\"Capacity of makeSliceOfSlices:\", cap(makeSliceOfSlices)) // 4\n\n\t// Initialize inner slices\n\tmakeSliceOfSlices[0] = []int{1000, 2000}\n\tmakeSliceOfSlices[1] = make([]int, 1, 3)\n\tmakeSliceOfSlices[1][0] = 3000\n\n\tprintln(\"makeSliceOfSlices[0][1]:\", makeSliceOfSlices[0][1]) // 2000\n\tprintln(\"makeSliceOfSlices[1][0]:\", makeSliceOfSlices[1][0]) // 3000\n\n\t// Append a new inner slice\n\tmakeSliceOfSlices = append(makeSliceOfSlices, []int{4000, 5000})\n\tprintln(\"Length of makeSliceOfSlices after append:\", len(makeSliceOfSlices))   // 3\n\tprintln(\"Capacity of makeSliceOfSlices after append:\", cap(makeSliceOfSlices)) // 4\n\tprintln(\"makeSliceOfSlices[2][1]:\", makeSliceOfSlices[2][1])                   // 5000\n\n\t// Append another new inner slice (should exceed capacity and reallocate outer slice)\n\tmakeSliceOfSlices = append(makeSliceOfSlices, []int{6000})\n\tprintln(\"Length of makeSliceOfSlices after second append:\", len(makeSliceOfSlices))   // 4\n\tprintln(\"Capacity of makeSliceOfSlices after second append:\", cap(makeSliceOfSlices)) // 8 (or more)\n\tprintln(\"makeSliceOfSlices[3][0]:\", makeSliceOfSlices[3][0])                          // 6000\n\n\t// Nil slice of slices\n\tprintln(\"--- Nil slice of slices ---\")\n\tvar nilSliceOfSlices [][]int\n\tprintln(\"Nil slice of slices len:\", len(nilSliceOfSlices)) // 0\n\tprintln(\"Nil slice of slices cap:\", cap(nilSliceOfSlices)) // 0\n\n\t// Append to nil slice of slices\n\tnilSliceOfSlices = append(nilSliceOfSlices, []int{10000})\n\tprintln(\"Length of nilSliceOfSlices after append:\", len(nilSliceOfSlices))   // 1\n\tprintln(\"Capacity of nilSliceOfSlices after append:\", cap(nilSliceOfSlices)) // 1 (or more)\n\tprintln(\"nilSliceOfSlices[0][0]:\", nilSliceOfSlices[0][0])                   // 10000\n\n\t// Append another slice to the nil slice of slices\n\tnilSliceOfSlices = append(nilSliceOfSlices, []int{20000, 30000})\n\tprintln(\"Length of nilSliceOfSlices after second append:\", len(nilSliceOfSlices))   // 2\n\tprintln(\"Capacity of nilSliceOfSlices after second append:\", cap(nilSliceOfSlices)) // 2 (or more)\n\tprintln(\"nilSliceOfSlices[1][1]:\", nilSliceOfSlices[1][1])                          // 30000\n\n\t// Empty slice of slices (not nil)\n\tprintln(\"--- Empty slice of slices ---\")\n\temptySliceOfSlices := make([][]int, 0)\n\tprintln(\"Empty slice of slices len:\", len(emptySliceOfSlices)) // 0\n\tprintln(\"Empty slice of slices cap:\", cap(emptySliceOfSlices)) // 0 (or more, implementation dependent)\n\n\t// Append to empty slice of slices\n\temptySliceOfSlices = append(emptySliceOfSlices, []int{40000})\n\tprintln(\"Length of emptySliceOfSlices after append:\", len(emptySliceOfSlices))   // 1\n\tprintln(\"Capacity of emptySliceOfSlices after append:\", cap(emptySliceOfSlices)) // 1 (or more)\n\tprintln(\"emptySliceOfSlices[0][0]:\", emptySliceOfSlices[0][0])                   // 40000\n}\n",
    "tsCode": "// Generated file based on slice.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// --- Original Tests ---\n\t$.println(\"--- Original Tests ---\")\n\t// Create a slice of integers with length 5 and capacity 10\n\tlet s = $.makeSlice<number>(5, 10, 'number')\n\t$.println($.len(s)) // 5\n\t$.println($.cap(s)) // 10\n\n\t// Create a slice of strings with length 3\n\tlet s2 = $.makeSlice<string>(3, undefined, 'string')\n\t$.println($.len(s2)) // 3\n\t$.println($.cap(s2)) // 3\n\n\t// Assign values\n\ts![0] = 10\n\ts![4] = 20\n\ts2![1] = \"hello\"\n\n\t$.println(s![0]) // 10\n\t$.println(s![4]) // 20\n\t$.println(s2![1]) // hello\n\n\t// --- New Tests ---\n\t$.println(\"--- New Tests ---\")\n\n\t// Create slice from array literal\n\tlet arrLit = $.arrayToSlice<number>([1, 2, 3, 4, 5])\n\tlet sliceFromLit = $.goSlice(arrLit, undefined, undefined)\n\t$.println($.len(sliceFromLit)) // 5\n\t$.println($.cap(sliceFromLit)) // 5\n\t$.println(sliceFromLit![0]) // 1\n\t$.println(sliceFromLit![4]) // 5\n\n\t// Create slice from array variable\n\tlet arrVar = $.arrayToSlice<string>([\"a\", \"b\", \"c\", \"d\"])\n\tlet sliceFromVar = $.goSlice(arrVar, undefined, undefined)\n\t$.println($.len(sliceFromVar)) // 4\n\t$.println($.cap(sliceFromVar)) // 4\n\t$.println(sliceFromVar![0]) // a\n\t$.println(sliceFromVar![3]) // d\n\n\t// Create slice with specific indices\n\tlet sliceIndices = $.goSlice(arrVar, 1, 3) // [\"b\", \"c\"]\n\t$.println($.len(sliceIndices)) // 2\n\t$.println($.cap(sliceIndices)) // 3 (cap is from start index to end of original array)\n\t$.println(sliceIndices![0]) // b\n\t$.println(sliceIndices![1]) // c\n\n\t// Create slice with 0 len/cap and append\n\t$.println(\"--- Zero len/cap append ---\")\n\tlet zeroSlice = $.makeSlice<number>(0, 0, 'number')\n\t$.println($.len(zeroSlice)) // 0\n\t$.println($.cap(zeroSlice)) // 0\n\tzeroSlice = $.append(zeroSlice, 100)\n\t$.println($.len(zeroSlice)) // 1\n\t$.println($.cap(zeroSlice)) // 1 (or more, implementation dependent)\n\t$.println(zeroSlice![0]) // 100\n\tzeroSlice = $.append(zeroSlice, 200)\n\t$.println($.len(zeroSlice)) // 2\n\t$.println($.cap(zeroSlice)) // 2 (or more)\n\t$.println(zeroSlice![1]) // 200\n\n\t// Modify slice, check original array\n\t$.println(\"--- Modify slice, check array ---\")\n\tlet modArr = $.arrayToSlice<number>([10, 20, 30])\n\tlet modSlice = $.goSlice(modArr, undefined, undefined)\n\tmodSlice![1] = 25 // Modify slice\n\t$.println(modArr![1]) // 25 (original array should be modified)\n\t$.println(modSlice![1]) // 25\n\n\t// Modify array, check slice\n\t$.println(\"--- Modify array, check slice ---\")\n\tmodArr![0] = 15 // Modify array\n\t$.println(modArr![0]) // 15\n\t$.println(modSlice![0]) // 15 (slice should reflect change)\n\n\t// Append to sub-slice within capacity\n\t$.println(\"--- Append sub-slice w/in capacity ---\")\n\tlet appendArr = $.arrayToSlice<number>([1, 2, 3, 4, 5])\n\tlet appendSlice1 = $.goSlice(appendArr, 0, 2) // len 2, cap 5; [1, 2]\n\t$.println($.len(appendSlice1)) // 2\n\t$.println($.cap(appendSlice1)) // 5\n\tlet appendSlice2 = $.append(appendSlice1, 99) // Appends within original capacity\n\t$.println($.len(appendSlice2)) // 3\n\t$.println($.cap(appendSlice2)) // 5\n\t$.println(appendSlice2![2]) // 99\n\t$.println(appendArr![2]) // 99 (original array modified)\n\n\t// Append to sub-slice exceeding capacity\n\t$.println(\"--- Append sub-slice exceed capacity ---\")\n\tlet appendSlice3 = $.goSlice(appendArr, 3, 5) // len 2, cap 2; [4, 5]\n\t$.println($.len(appendSlice3)) // 2\n\t$.println($.cap(appendSlice3)) // 2\n\tlet appendSlice4 = $.append(appendSlice3, 101) // Appends beyond original capacity\n\t$.println($.len(appendSlice4)) // 3\n\t$.println($.cap(appendSlice4)) // 4 (or more, new underlying array)\n\t$.println(appendSlice4![0]) // 4\n\t$.println(appendSlice4![1]) // 5\n\t$.println(appendSlice4![2]) // 101\n\t// Original array should NOT be modified beyond its bounds by this append\n\t$.println(appendArr![0]) // 1\n\t$.println(appendArr![1]) // 2\n\t$.println(appendArr![2]) // 99 (from previous append)\n\t$.println(appendArr![3]) // 4\n\t$.println(appendArr![4]) // 5\n\n\t// Slicing a slice\n\t$.println(\"--- Slicing a slice ---\")\n\tlet baseSlice = $.arrayToSlice<number>([0, 10, 20, 30, 40, 50])\n\tlet subSlice1 = $.goSlice(baseSlice, 1, 4) // [10, 20, 30], len 3, cap 5\n\t$.println($.len(subSlice1)) // 3\n\t$.println($.cap(subSlice1)) // 5\n\t$.println(subSlice1![0]) // 10\n\tlet subSlice2 = $.goSlice(subSlice1, 1, 3) // [20, 30], len 2, cap 4 (cap from subSlice1's start)\n\t$.println($.len(subSlice2)) // 2\n\t$.println($.cap(subSlice2)) // 4\n\t$.println(subSlice2![0]) // 20\n\t$.println(subSlice2![1]) // 30\n\tsubSlice2![0] = 22 // Modify sub-sub-slice\n\t$.println(subSlice1![1]) // 22 (subSlice1 modified)\n\t$.println(baseSlice![2]) // 22 (baseSlice modified)\n\n\t// Three-index slicing (if supported) - Check capacity\n\t$.println(\"--- Three-index slicing ---\")\n\tlet threeIndexArr = $.arrayToSlice<number>([0, 1, 2, 3, 4, 5])\n\tlet threeIndexSlice = $.goSlice(threeIndexArr, 1, 3, 4) // [1, 2], len 2, cap 3 (4-1)\n\t$.println($.len(threeIndexSlice)) // 2\n\t$.println($.cap(threeIndexSlice)) // 3\n\t$.println(threeIndexSlice![0]) // 1\n\t$.println(threeIndexSlice![1]) // 2\n\t// Appending should modify original array up to new capacity limit\n\tthreeIndexSlice = $.append(threeIndexSlice, 99)\n\t$.println($.len(threeIndexSlice)) // 3\n\t$.println($.cap(threeIndexSlice)) // 3\n\t$.println(threeIndexSlice![2]) // 99\n\t$.println(threeIndexArr![3]) // 99 (original modified)\n\t// Appending again should reallocate\n\tthreeIndexSlice = $.append(threeIndexSlice, 101)\n\t$.println($.len(threeIndexSlice)) // 4\n\t$.println($.cap(threeIndexSlice)) // 6 (or more)\n\t$.println(threeIndexSlice![3]) // 101\n\t$.println(threeIndexArr![4]) // 4 (original NOT modified by reallocating append)\n\n\t// --- Additional Tests for Full Coverage ---\n\t$.println(\"--- Additional Tests ---\")\n\n\t// Slice literal\n\tlet sliceLiteral = $.arrayToSlice<number>([10, 20, 30])\n\t$.println(\"Slice literal len:\", $.len(sliceLiteral)) // 3\n\t$.println(\"Slice literal cap:\", $.cap(sliceLiteral)) // 3\n\t$.println(\"Slice literal[1]:\", sliceLiteral![1]) // 20\n\n\t// Nil slice\n\tlet nilSlice: $.Slice<number> = null\n\t$.println(\"Nil slice len:\", $.len(nilSlice)) // 0\n\t$.println(\"Nil slice cap:\", $.cap(nilSlice)) // 0\n\tnilSlice = $.append(nilSlice, 5)\n\t$.println(\"Append to nil slice len:\", $.len(nilSlice)) // 1\n\t$.println(\"Append to nil slice cap:\", $.cap(nilSlice)) // 1 (or more)\n\t$.println(\"Append to nil slice[0]:\", nilSlice![0]) // 5\n\n\t// Out-of-bounds indexing (should panic)\n\t// Note: Testing panics in compliance tests requires specific handling in the test runner.\n\t// For now, we'll add the code but expect it to fail if panics are not caught.\n\t// The runner should ideally catch these panics and verify the error type/message.\n\n\t// println(\"--- Testing out-of-bounds panic ---\")\n\t// smallSlice := []int{1}\n\t// println(smallSlice[1]) // Index out of bounds (len 1, cap 1) - should panic\n\t// smallSlice[1] = 10     // Index out of bounds - should panic\n\t// println(smallSlice[-1]) // Negative index - should panic\n\n\t// --- Slices of Slices Tests ---\n\t$.println(\"--- Slices of Slices Tests ---\")\n\n\t// Create a slice of slices of integers\n\tlet sliceOfSlices = $.arrayToSlice<$.Slice<number>>([[ 1, 2, 3 ], [ 4, 5 ], [ 6, 7, 8, 9 ]], 2)\n\n\t$.println(\"Length of sliceOfSlices:\", $.len(sliceOfSlices)) // 3\n\t$.println(\"Capacity of sliceOfSlices:\", $.cap(sliceOfSlices)) // 3\n\n\t// Access elements\n\t$.println(\"sliceOfSlices[0][1]:\", sliceOfSlices![0]![1]) // 2\n\t$.println(\"sliceOfSlices[1][0]:\", sliceOfSlices![1]![0]) // 4\n\t$.println(\"sliceOfSlices[2][3]:\", sliceOfSlices![2]![3]) // 9\n\n\t// Append to inner slice (should modify the inner slice)\n\t$.println(\"--- Append to inner slice ---\")\n\tlet innerSlice = sliceOfSlices![1] // {4, 5}, len 2, cap 2\n\t$.println(\"Length of innerSlice:\", $.len(innerSlice)) // 2\n\t$.println(\"Capacity of innerSlice:\", $.cap(innerSlice)) // 2\n\n\tinnerSlice = $.append(innerSlice, 50) // {4, 5, 50}\n\t$.println(\"Length of innerSlice after append:\", $.len(innerSlice)) // 3\n\t$.println(\"Capacity of innerSlice after append:\", $.cap(innerSlice)) // 4 (or more)\n\t$.println(\"innerSlice[2]:\", innerSlice![2]) // 50\n\n\t// Check if the original slice of slices reflects the change (it should, as innerSlice is a view)\n\t// Note: Appending to innerSlice might reallocate its underlying array if capacity is exceeded.\n\t// If reallocated, the original sliceOfSlices will *not* see the change at that index.\n\t// This test case specifically checks the scenario where the append happens within the original capacity\n\t// or if the reallocation behavior is correctly handled by GoScript.\n\t// For this simple case, appending 50 to {4, 5} will likely cause reallocation.\n\t// Let's test appending within capacity first.\n\n\t// Create a slice of slices where inner slice has capacity for append\n\n\t// {0, 0}, len 2, cap 5\n\tlet sliceOfSlicesWithCap = $.arrayToSlice<$.Slice<number>>([[ 1, 2, 3 ], $.makeSlice<number>(2, 5, 'number'), [ 6, 7, 8, 9 ]], 2)\n\tsliceOfSlicesWithCap![1]![0] = 40\n\tsliceOfSlicesWithCap![1]![1] = 50\n\n\t$.println(\"--- Append to inner slice with capacity ---\")\n\tlet innerSliceWithCap = sliceOfSlicesWithCap![1] // {40, 50}, len 2, cap 5\n\t$.println(\"Length of innerSliceWithCap:\", $.len(innerSliceWithCap)) // 2\n\t$.println(\"Capacity of innerSliceWithCap:\", $.cap(innerSliceWithCap)) // 5\n\n\tinnerSliceWithCap = $.append(innerSliceWithCap, 60) // {40, 50, 60}\n\t$.println(\"Length of innerSliceWithCap after append:\", $.len(innerSliceWithCap)) // 3\n\t$.println(\"Capacity of innerSliceWithCap after append:\", $.cap(innerSliceWithCap)) // 5\n\t$.println(\"innerSliceWithCap[2]:\", innerSliceWithCap![2]) // 60\n\n\t// Check if the original slice of slices reflects the change (it should, as append was within capacity)\n\t$.println(\"sliceOfSlicesWithCap[1][2]:\", $.goSlice(sliceOfSlicesWithCap![1], undefined, 3)![2]) // 60\n\n\t// Append to inner slice exceeding capacity\n\t$.println(\"--- Append to inner slice exceeding capacity ---\")\n\tlet innerSliceExceedCap = sliceOfSlices![0] // {1, 2, 3}, len 3, cap 3\n\t$.println(\"Length of innerSliceExceedCap:\", $.len(innerSliceExceedCap)) // 3\n\t$.println(\"Capacity of innerSliceExceedCap:\", $.cap(innerSliceExceedCap)) // 3\n\n\tinnerSliceExceedCap = $.append(innerSliceExceedCap, 10, 20) // {1, 2, 3, 10, 20} - will reallocate\n\t$.println(\"Length of innerSliceExceedCap after append:\", $.len(innerSliceExceedCap)) // 5\n\t$.println(\"Capacity of innerSliceExceedCap after append:\", $.cap(innerSliceExceedCap)) // 6 (or more)\n\t$.println(\"innerSliceExceedCap[3]:\", innerSliceExceedCap![3]) // 10\n\t$.println(\"innerSliceExceedCap[4]:\", innerSliceExceedCap![4]) // 20\n\n\t// Check if the original slice of slices reflects the change (it should NOT, due to reallocation)\n\t// The original sliceOfSlices[0] should still be {1, 2, 3}\n\t$.println(\"Original sliceOfSlices[0] after inner append:\", sliceOfSlices![0]![0], sliceOfSlices![0]![1], sliceOfSlices![0]![2]) // 1 2 3\n\n\t// Slicing a slice of slices\n\t$.println(\"--- Slicing a slice of slices ---\")\n\tlet subSliceOfSlices = $.goSlice(sliceOfSlices, 1, 3) // {{4, 5}, {6, 7, 8, 9}}, len 2, cap 2\n\t$.println(\"Length of subSliceOfSlices:\", $.len(subSliceOfSlices)) // 2\n\t$.println(\"Capacity of subSliceOfSlices:\", $.cap(subSliceOfSlices)) // 2\n\t$.println(\"subSliceOfSlices[0][0]:\", subSliceOfSlices![0]![0]) // 4\n\t$.println(\"subSliceOfSlices[1][2]:\", subSliceOfSlices![1]![2]) // 8\n\n\t// Modify element in sub-slice of slices (should affect original)\n\t$.println(\"--- Modify element in sub-slice of slices ---\")\n\tsubSliceOfSlices![0]![1] = 55\n\t$.println(\"sliceOfSlices[1][1] after sub-slice modification:\", sliceOfSlices![1]![1]) // 55\n\n\t// Append a new slice to the slice of slices\n\t$.println(\"--- Append a new slice to slice of slices ---\")\n\tsliceOfSlices = $.append(sliceOfSlices, $.arrayToSlice<number>([100, 110]))\n\t$.println(\"Length of sliceOfSlices after append:\", $.len(sliceOfSlices)) // 4\n\t$.println(\"Capacity of sliceOfSlices after append:\", $.cap(sliceOfSlices)) // 6 (or more)\n\t$.println(\"sliceOfSlices[3][0]:\", sliceOfSlices![3]![0]) // 100\n\n\t// Append an existing slice to the slice of slices\n\t$.println(\"--- Append an existing slice to slice of slices ---\")\n\tlet existingSlice = $.arrayToSlice<number>([200, 210])\n\tsliceOfSlices = $.append(sliceOfSlices, existingSlice)\n\t$.println(\"Length of sliceOfSlices after appending existing:\", $.len(sliceOfSlices)) // 5\n\t$.println(\"Capacity of sliceOfSlices after appending existing:\", $.cap(sliceOfSlices)) // 6 (or more)\n\t$.println(\"sliceOfSlices[4][1]:\", sliceOfSlices![4]![1]) // 210\n\n\t// Modify the appended existing slice (should NOT affect the slice in sliceOfSlices if it was copied)\n\t// Go's append copies the slice header, but the underlying array is shared unless reallocation occurs.\n\t// Modifying existingSlice *after* appending it should not affect the copy in sliceOfSlices\n\t// unless they still share the underlying array and the modification is within the shared capacity.\n\t// Let's test this carefully.\n\t$.println(\"--- Modify appended existing slice ---\")\n\texistingSlice![0] = 205\n\t$.println(\"sliceOfSlices[4][0] after modifying existingSlice:\", sliceOfSlices![4]![0]) // Should still be 200 if copied or shared but not modified at index 0\n\n\t// If we modify an element in the slice within sliceOfSlices, it *should* affect the original existingSlice\n\t// if they share the underlying array.\n\t$.println(\"--- Modify slice within sliceOfSlices ---\")\n\tsliceOfSlices![4]![1] = 215\n\t$.println(\"existingSlice[1] after modifying slice within sliceOfSlices:\", existingSlice![1]) // Should be 215\n\n\t// Create a slice of slices using make\n\t$.println(\"--- Make slice of slices ---\")\n\tlet makeSliceOfSlices = $.makeSlice<$.Slice<number>>(2, 4) // len 2, cap 4\n\t$.println(\"Length of makeSliceOfSlices:\", $.len(makeSliceOfSlices)) // 2\n\t$.println(\"Capacity of makeSliceOfSlices:\", $.cap(makeSliceOfSlices)) // 4\n\n\t// Initialize inner slices\n\tmakeSliceOfSlices![0] = $.arrayToSlice<number>([1000, 2000])\n\tmakeSliceOfSlices![1] = $.makeSlice<number>(1, 3, 'number')\n\tmakeSliceOfSlices![1]![0] = 3000\n\n\t$.println(\"makeSliceOfSlices[0][1]:\", makeSliceOfSlices![0]![1]) // 2000\n\t$.println(\"makeSliceOfSlices[1][0]:\", makeSliceOfSlices![1]![0]) // 3000\n\n\t// Append a new inner slice\n\tmakeSliceOfSlices = $.append(makeSliceOfSlices, $.arrayToSlice<number>([4000, 5000]))\n\t$.println(\"Length of makeSliceOfSlices after append:\", $.len(makeSliceOfSlices)) // 3\n\t$.println(\"Capacity of makeSliceOfSlices after append:\", $.cap(makeSliceOfSlices)) // 4\n\t$.println(\"makeSliceOfSlices[2][1]:\", makeSliceOfSlices![2]![1]) // 5000\n\n\t// Append another new inner slice (should exceed capacity and reallocate outer slice)\n\tmakeSliceOfSlices = $.append(makeSliceOfSlices, $.arrayToSlice<number>([6000]))\n\t$.println(\"Length of makeSliceOfSlices after second append:\", $.len(makeSliceOfSlices)) // 4\n\t$.println(\"Capacity of makeSliceOfSlices after second append:\", $.cap(makeSliceOfSlices)) // 8 (or more)\n\t$.println(\"makeSliceOfSlices[3][0]:\", makeSliceOfSlices![3]![0]) // 6000\n\n\t// Nil slice of slices\n\t$.println(\"--- Nil slice of slices ---\")\n\tlet nilSliceOfSlices: $.Slice<$.Slice<number>> = null\n\t$.println(\"Nil slice of slices len:\", $.len(nilSliceOfSlices)) // 0\n\t$.println(\"Nil slice of slices cap:\", $.cap(nilSliceOfSlices)) // 0\n\n\t// Append to nil slice of slices\n\tnilSliceOfSlices = $.append(nilSliceOfSlices, $.arrayToSlice<number>([10000]))\n\t$.println(\"Length of nilSliceOfSlices after append:\", $.len(nilSliceOfSlices)) // 1\n\t$.println(\"Capacity of nilSliceOfSlices after append:\", $.cap(nilSliceOfSlices)) // 1 (or more)\n\t$.println(\"nilSliceOfSlices[0][0]:\", nilSliceOfSlices![0]![0]) // 10000\n\n\t// Append another slice to the nil slice of slices\n\tnilSliceOfSlices = $.append(nilSliceOfSlices, $.arrayToSlice<number>([20000, 30000]))\n\t$.println(\"Length of nilSliceOfSlices after second append:\", $.len(nilSliceOfSlices)) // 2\n\t$.println(\"Capacity of nilSliceOfSlices after second append:\", $.cap(nilSliceOfSlices)) // 2 (or more)\n\t$.println(\"nilSliceOfSlices[1][1]:\", nilSliceOfSlices![1]![1]) // 30000\n\n\t// Empty slice of slices (not nil)\n\t$.println(\"--- Empty slice of slices ---\")\n\tlet emptySliceOfSlices = $.makeSlice<$.Slice<number>>(0)\n\t$.println(\"Empty slice of slices len:\", $.len(emptySliceOfSlices)) // 0\n\t$.println(\"Empty slice of slices cap:\", $.cap(emptySliceOfSlices)) // 0 (or more, implementation dependent)\n\n\t// Append to empty slice of slices\n\temptySliceOfSlices = $.append(emptySliceOfSlices, $.arrayToSlice<number>([40000]))\n\t$.println(\"Length of emptySliceOfSlices after append:\", $.len(emptySliceOfSlices)) // 1\n\t$.println(\"Capacity of emptySliceOfSlices after append:\", $.cap(emptySliceOfSlices)) // 1 (or more)\n\t$.println(\"emptySliceOfSlices[0][0]:\", emptySliceOfSlices![0]![0]) // 40000\n}\n\n",
    "expectedOutput": "--- Original Tests ---\n5\n10\n3\n3\n10\n20\nhello\n--- New Tests ---\n5\n5\n1\n5\n4\n4\na\nd\n2\n3\nb\nc\n--- Zero len/cap append ---\n0\n0\n1\n1\n100\n2\n2\n200\n--- Modify slice, check array ---\n25\n25\n--- Modify array, check slice ---\n15\n15\n--- Append sub-slice w/in capacity ---\n2\n5\n3\n5\n99\n99\n--- Append sub-slice exceed capacity ---\n2\n2\n3\n4\n4\n5\n101\n1\n2\n99\n4\n5\n--- Slicing a slice ---\n3\n5\n10\n2\n4\n20\n30\n22\n22\n--- Three-index slicing ---\n2\n3\n1\n2\n3\n3\n99\n99\n4\n6\n101\n4\n--- Additional Tests ---\nSlice literal len: 3\nSlice literal cap: 3\nSlice literal[1]: 20\nNil slice len: 0\nNil slice cap: 0\nAppend to nil slice len: 1\nAppend to nil slice cap: 1\nAppend to nil slice[0]: 5\n--- Slices of Slices Tests ---\nLength of sliceOfSlices: 3\nCapacity of sliceOfSlices: 3\nsliceOfSlices[0][1]: 2\nsliceOfSlices[1][0]: 4\nsliceOfSlices[2][3]: 9\n--- Append to inner slice ---\nLength of innerSlice: 2\nCapacity of innerSlice: 2\nLength of innerSlice after append: 3\nCapacity of innerSlice after append: 4\ninnerSlice[2]: 50\n--- Append to inner slice with capacity ---\nLength of innerSliceWithCap: 2\nCapacity of innerSliceWithCap: 5\nLength of innerSliceWithCap after append: 3\nCapacity of innerSliceWithCap after append: 5\ninnerSliceWithCap[2]: 60\nsliceOfSlicesWithCap[1][2]: 60\n--- Append to inner slice exceeding capacity ---\nLength of innerSliceExceedCap: 3\nCapacity of innerSliceExceedCap: 3\nLength of innerSliceExceedCap after append: 5\nCapacity of innerSliceExceedCap after append: 6\ninnerSliceExceedCap[3]: 10\ninnerSliceExceedCap[4]: 20\nOriginal sliceOfSlices[0] after inner append: 1 2 3\n--- Slicing a slice of slices ---\nLength of subSliceOfSlices: 2\nCapacity of subSliceOfSlices: 2\nsubSliceOfSlices[0][0]: 4\nsubSliceOfSlices[1][2]: 8\n--- Modify element in sub-slice of slices ---\nsliceOfSlices[1][1] after sub-slice modification: 55\n--- Append a new slice to slice of slices ---\nLength of sliceOfSlices after append: 4\nCapacity of sliceOfSlices after append: 6\nsliceOfSlices[3][0]: 100\n--- Append an existing slice to slice of slices ---\nLength of sliceOfSlices after appending existing: 5\nCapacity of sliceOfSlices after appending existing: 6\nsliceOfSlices[4][1]: 210\n--- Modify appended existing slice ---\nsliceOfSlices[4][0] after modifying existingSlice: 205\n--- Modify slice within sliceOfSlices ---\nexistingSlice[1] after modifying slice within sliceOfSlices: 215\n--- Make slice of slices ---\nLength of makeSliceOfSlices: 2\nCapacity of makeSliceOfSlices: 4\nmakeSliceOfSlices[0][1]: 2000\nmakeSliceOfSlices[1][0]: 3000\nLength of makeSliceOfSlices after append: 3\nCapacity of makeSliceOfSlices after append: 4\nmakeSliceOfSlices[2][1]: 5000\nLength of makeSliceOfSlices after second append: 4\nCapacity of makeSliceOfSlices after second append: 4\nmakeSliceOfSlices[3][0]: 6000\n--- Nil slice of slices ---\nNil slice of slices len: 0\nNil slice of slices cap: 0\nLength of nilSliceOfSlices after append: 1\nCapacity of nilSliceOfSlices after append: 1\nnilSliceOfSlices[0][0]: 10000\nLength of nilSliceOfSlices after second append: 2\nCapacity of nilSliceOfSlices after second append: 2\nnilSliceOfSlices[1][1]: 30000\n--- Empty slice of slices ---\nEmpty slice of slices len: 0\nEmpty slice of slices cap: 0\nLength of emptySliceOfSlices after append: 1\nCapacity of emptySliceOfSlices after append: 1\nemptySliceOfSlices[0][0]: 40000"
  },
  {
    "name": "map_support",
    "title": "Maps",
    "description": "Map operations",
    "goCode": "package main\n\nfunc main() {\n\t// Create map using make\n\tscores := make(map[string]int)\n\tprintln(\"Empty map created: Expected: true, Actual:\", len(scores) == 0)\n\n\t// Add key-value pairs\n\tscores[\"Alice\"] = 90\n\tscores[\"Bob\"] = 85\n\tscores[\"Charlie\"] = 92\n\n\t// Map size\n\tprintln(\"Map size after adding 3 items: Expected: 3, Actual:\", len(scores))\n\n\t// Access values\n\tprintln(\"Alice's score: Expected: 90, Actual:\", scores[\"Alice\"])\n\tprintln(\"Bob's score: Expected: 85, Actual:\", scores[\"Bob\"])\n\n\t// Modify a value\n\tscores[\"Bob\"] = 88\n\tprintln(\"Bob's updated score: Expected: 88, Actual:\", scores[\"Bob\"])\n\n\t// Check if key exists (comma-ok idiom)\n\tvalue, exists := scores[\"David\"]\n\tprintln(\"Does David exist in map? Expected: false, Actual:\", exists)\n\tprintln(\"Value for non-existent key: Expected: 0, Actual:\", value)\n\n\t// Delete a key\n\tdelete(scores, \"Charlie\")\n\t_, exists = scores[\"Charlie\"]\n\tprintln(\"After delete, does Charlie exist? Expected: false, Actual:\", exists)\n\n\t// Create map with literal syntax\n\tcolors := map[string]string{\n\t\t\"red\":   \"#ff0000\",\n\t\t\"green\": \"#00ff00\",\n\t\t\"blue\":  \"#0000ff\",\n\t}\n\tprintln(\"Map literal size: Expected: 3, Actual:\", len(colors))\n\tprintln(\"Color code for red: Expected: #ff0000, Actual:\", colors[\"red\"])\n\n\t// Iterate over a map with range\n\tprintln(\"Iterating over scores map:\")\n\n\t// Create a new map with string keys and string values for testing iteration\n\tstringMap := map[string]string{\n\t\t\"Alice\":   \"A+\",\n\t\t\"Bob\":     \"B+\",\n\t\t\"Charlie\": \"A\",\n\t}\n\n\t// Note: Map iteration is not ordered in Go, so we will collect the results and sort them for consistent test output.\n\tvar scoreResults []string\n\tfor name, grade := range stringMap {\n\t\t// Using string concatenation to build the output string\n\t\tresult := \"  - Name: \" + name + \" Grade: \" + grade\n\t\tscoreResults = append(scoreResults, result)\n\t}\n\n\t// Inline bubble sort for string slice\n\t// (avoid importing sort package yet)\n\tn := len(scoreResults)\n\tfor i := 0; i < n-1; i++ {\n\t\tfor j := 0; j < n-i-1; j++ {\n\t\t\tif scoreResults[j] > scoreResults[j+1] {\n\t\t\t\tscoreResults[j], scoreResults[j+1] = scoreResults[j+1], scoreResults[j]\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, result := range scoreResults {\n\t\tprintln(result)\n\t}\n}\n",
    "tsCode": "// Generated file based on map_support.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\t// Create map using make\n\tlet scores = $.makeMap<string, number>()\n\t$.println(\"Empty map created: Expected: true, Actual:\", $.len(scores) == 0)\n\n\t// Add key-value pairs\n\t$.mapSet(scores, \"Alice\", 90)\n\t$.mapSet(scores, \"Bob\", 85)\n\t$.mapSet(scores, \"Charlie\", 92)\n\n\t// Map size\n\t$.println(\"Map size after adding 3 items: Expected: 3, Actual:\", $.len(scores))\n\n\t// Access values\n\t$.println(\"Alice's score: Expected: 90, Actual:\", $.mapGet(scores, \"Alice\", 0)[0])\n\t$.println(\"Bob's score: Expected: 85, Actual:\", $.mapGet(scores, \"Bob\", 0)[0])\n\n\t// Modify a value\n\t$.mapSet(scores, \"Bob\", 88)\n\t$.println(\"Bob's updated score: Expected: 88, Actual:\", $.mapGet(scores, \"Bob\", 0)[0])\n\n\t// Check if key exists (comma-ok idiom)\n\tlet [value, exists] = $.mapGet(scores, \"David\", 0)\n\t$.println(\"Does David exist in map? Expected: false, Actual:\", exists)\n\t$.println(\"Value for non-existent key: Expected: 0, Actual:\", value)\n\n\t// Delete a key\n\t$.deleteMapEntry(scores, \"Charlie\")\n\t;[, exists] = $.mapGet(scores, \"Charlie\", 0)\n\t$.println(\"After delete, does Charlie exist? Expected: false, Actual:\", exists)\n\n\t// Create map with literal syntax\n\tlet colors = new Map([[\"red\", \"#ff0000\"], [\"green\", \"#00ff00\"], [\"blue\", \"#0000ff\"]])\n\t$.println(\"Map literal size: Expected: 3, Actual:\", $.len(colors))\n\t$.println(\"Color code for red: Expected: #ff0000, Actual:\", $.mapGet(colors, \"red\", \"\")[0])\n\n\t// Iterate over a map with range\n\t$.println(\"Iterating over scores map:\")\n\n\t// Create a new map with string keys and string values for testing iteration\n\tlet stringMap = new Map([[\"Alice\", \"A+\"], [\"Bob\", \"B+\"], [\"Charlie\", \"A\"]])\n\n\t// Note: Map iteration is not ordered in Go, so we will collect the results and sort them for consistent test output.\n\tlet scoreResults: $.Slice<string> = null\n\n\t// Using string concatenation to build the output string\n\tfor (const [name, grade] of stringMap?.entries() ?? []) {\n\t\t{\n\t\t\t// Using string concatenation to build the output string\n\t\t\tlet result = \"  - Name: \" + name + \" Grade: \" + grade\n\t\t\tscoreResults = $.append(scoreResults, result)\n\t\t}\n\t}\n\n\t// Inline bubble sort for string slice\n\t// (avoid importing sort package yet)\n\tlet n = $.len(scoreResults)\n\tfor (let i = 0; i < n - 1; i++) {\n\t\tfor (let j = 0; j < n - i - 1; j++) {\n\t\t\tif (scoreResults![j] > scoreResults![j + 1]) {\n\t\t\t\t;[scoreResults![j], scoreResults![j + 1]] = [scoreResults![j + 1], scoreResults![j]]\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (let _i = 0; _i < $.len(scoreResults); _i++) {\n\t\tlet result = scoreResults![_i]\n\t\t{\n\t\t\t$.println(result)\n\t\t}\n\t}\n}\n\n",
    "expectedOutput": "Empty map created: Expected: true, Actual: true\nMap size after adding 3 items: Expected: 3, Actual: 3\nAlice's score: Expected: 90, Actual: 90\nBob's score: Expected: 85, Actual: 85\nBob's updated score: Expected: 88, Actual: 88\nDoes David exist in map? Expected: false, Actual: false\nValue for non-existent key: Expected: 0, Actual: 0\nAfter delete, does Charlie exist? Expected: false, Actual: false\nMap literal size: Expected: 3, Actual: 3\nColor code for red: Expected: #ff0000, Actual: #ff0000\nIterating over scores map:\n  - Name: Alice Grade: A+\n  - Name: Bob Grade: B+\n  - Name: Charlie Grade: A"
  },
  {
    "name": "pointers",
    "title": "Pointers",
    "description": "Pointer semantics in GoScript",
    "goCode": "package main\n\n/* not currently working correctly */\n/* @ts-ignore */\n/* eslint-disable-file */\n\ntype MyStruct struct {\n\tVal int\n}\n\nfunc main() {\n\ts1 := MyStruct{Val: 1} // p1 takes the address of s1, so s1 is varrefed\n\ts2 := MyStruct{Val: 2} // p2 takes the address of s2, so s2 is varrefed\n\n\tp1 := &s1 // *MyStruct, points to s1, pp1 takes the address of p1, so p1 is varrefed\n\tp2 := &s1 // *MyStruct, points to s1, pp2 takes the address of p2, so p2 is varrefed\n\tp3 := &s2 // *MyStruct, points to s2, pp3 takes the address of p3, so p3 is varrefed\n\n\tp4 := &s1 // *MyStruct, points to s1, nothing takes the address of p4, so p4 is not varrefed\n\t_ = p4\n\n\tpp1 := &p1 // **MyStruct, points to p1\n\tpp2 := &p2 // **MyStruct, points to p2\n\tpp3 := &p3 // **MyStruct, points to p3\n\n\tppp1 := &pp1 // ***MyStruct, points to pp1, not varrefed as nothing takes address of ppp1\n\n\tprintln(\"--- Initial Values ---\")\n\tprintln(\"s1.Val:\", s1.Val)   // 1\n\tprintln(\"s2.Val:\", s2.Val)   // 2\n\tprintln(\"p1==p2:\", p1 == p2) // true\n\tprintln(\"p1==p3:\", p1 == p3) // false\n\n\t// --- Pointer Comparisons ---\n\tprintln(\"\\n--- Pointer Comparisons ---\")\n\tprintln(\"pp1==pp2:\", pp1 == pp2)                                   // false\n\tprintln(\"pp1==pp3:\", pp1 == pp3)                                   // false\n\tprintln(\"*pp1==*pp2:\", *pp1 == *pp2)                               // true\n\tprintln(\"*pp1==*pp3:\", *pp1 == *pp3)                               // false\n\tprintln(\"(**pp1).Val == (**pp2).Val:\", (**pp1).Val == (**pp2).Val) // true\n\tprintln(\"(**pp1).Val == (**pp3).Val:\", (**pp1).Val == (**pp3).Val) // false\n\n\t// Triple pointer comparisons\n\tprintln(\"ppp1==ppp1:\", ppp1 == ppp1)                         // true\n\tprintln(\"*ppp1==pp1:\", *ppp1 == pp1)                         // true\n\tprintln(\"**ppp1==p1:\", **ppp1 == p1)                         // true\n\tprintln(\"(***ppp1).Val == s1.Val:\", (***ppp1).Val == s1.Val) // true\n\n\t// --- Modifications through Pointers ---\n\tprintln(\"\\n--- Modifications ---\")\n\t*p1 = MyStruct{Val: 10} // Modify s1 via p1\n\tprintln(\"After *p1 = {Val: 10}:\")\n\tprintln(\"  s1.Val:\", s1.Val)               // 10\n\tprintln(\"  (*p2).Val:\", (*p2).Val)         // 10\n\tprintln(\"  (**pp1).Val:\", (**pp1).Val)     // 10\n\tprintln(\"  (***ppp1).Val:\", (***ppp1).Val) // 10\n\tprintln(\"  s2.Val:\", s2.Val)               // 2 (unmodified)\n\n\t**pp3 = MyStruct{Val: 20} // Modify s2 via pp3 -> p3\n\tprintln(\"After **pp3 = {Val: 20}:\")\n\tprintln(\"  s2.Val:\", s2.Val)       // 20\n\tprintln(\"  (*p3).Val:\", (*p3).Val) // 20\n\tprintln(\"  s1.Val:\", s1.Val)       // 10 (unmodified)\n\n\t// --- Nil Pointers ---\n\tprintln(\"\\n--- Nil Pointers ---\")\n\tvar np *MyStruct = nil\n\tvar npp **MyStruct = nil\n\tvar nppp ***MyStruct = nil\n\n\tprintln(\"np == nil:\", np == nil)     // true\n\tprintln(\"npp == nil:\", npp == nil)   // true\n\tprintln(\"nppp == nil:\", nppp == nil) // true\n\n\tnpp = &np // npp now points to np (which is nil)\n\tprintln(\"After npp = &np:\")\n\tprintln(\"  npp == nil:\", npp == nil)   // false\n\tprintln(\"  *npp == nil:\", *npp == nil) // true\n}\n",
    "tsCode": "// Generated file based on pointers.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport class MyStruct {\n\tpublic get Val(): number {\n\t\treturn this._fields.Val.value\n\t}\n\tpublic set Val(value: number) {\n\t\tthis._fields.Val.value = value\n\t}\n\n\tpublic _fields: {\n\t\tVal: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Val?: number}>) {\n\t\tthis._fields = {\n\t\t\tVal: $.varRef(init?.Val ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tVal: $.varRef(this._fields.Val.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [],\n\t  MyStruct,\n\t  {\"Val\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet s1 = $.varRef($.markAsStructValue(new MyStruct({Val: 1}))) // p1 takes the address of s1, so s1 is varrefed\n\tlet s2 = $.varRef($.markAsStructValue(new MyStruct({Val: 2}))) // p2 takes the address of s2, so s2 is varrefed\n\n\tlet p1 = $.varRef(s1) // *MyStruct, points to s1, pp1 takes the address of p1, so p1 is varrefed\n\tlet p2 = $.varRef(s1) // *MyStruct, points to s1, pp2 takes the address of p2, so p2 is varrefed\n\tlet p3 = $.varRef(s2) // *MyStruct, points to s2, pp3 takes the address of p3, so p3 is varrefed\n\n\tlet p4 = s1 // *MyStruct, points to s1, nothing takes the address of p4, so p4 is not varrefed\n\t/* _ = */ p4!.value\n\n\tlet pp1 = $.varRef(p1) // **MyStruct, points to p1\n\tlet pp2 = p2 // **MyStruct, points to p2\n\tlet pp3 = p3 // **MyStruct, points to p3\n\n\tlet ppp1 = pp1 // ***MyStruct, points to pp1, not varrefed as nothing takes address of ppp1\n\n\t$.println(\"--- Initial Values ---\")\n\t$.println(\"s1.Val:\", s1!.value.Val) // 1\n\t$.println(\"s2.Val:\", s2!.value.Val) // 2\n\t$.println(\"p1==p2:\", (p1!.value === p2!.value)) // true\n\t$.println(\"p1==p3:\", (p1!.value === p3!.value)) // false\n\n\t// --- Pointer Comparisons ---\n\t$.println(\"\\n--- Pointer Comparisons ---\")\n\t$.println(\"pp1==pp2:\", (pp1!.value === pp2)) // false\n\t$.println(\"pp1==pp3:\", (pp1!.value === pp3)) // false\n\t$.println(\"*pp1==*pp2:\", (pp1!.value!.value === pp2!.value)) // true\n\t$.println(\"*pp1==*pp3:\", (pp1!.value!.value === pp3!.value)) // false\n\t$.println(\"(**pp1).Val == (**pp2).Val:\", pp1!.value!.value!!.value.Val == pp2!.value!!.value.Val) // true\n\t$.println(\"(**pp1).Val == (**pp3).Val:\", pp1!.value!.value!!.value.Val == pp3!.value!!.value.Val) // false\n\n\t// Triple pointer comparisons\n\t$.println(\"ppp1==ppp1:\", (ppp1 === ppp1)) // true\n\t$.println(\"*ppp1==pp1:\", (ppp1!.value === pp1!.value)) // true\n\t$.println(\"**ppp1==p1:\", (ppp1!.value!.value === p1!.value)) // true\n\t$.println(\"(***ppp1).Val == s1.Val:\", ppp1!.value!.value!!.value.Val == s1!.value.Val) // true\n\n\t// --- Modifications through Pointers ---\n\t$.println(\"\\n--- Modifications ---\")\n\tp1!.value!.value = $.markAsStructValue(new MyStruct({Val: 10})) // Modify s1 via p1\n\t$.println(\"After *p1 = {Val: 10}:\")\n\t$.println(\"  s1.Val:\", s1!.value.Val) // 10\n\t$.println(\"  (*p2).Val:\", p2!.value!!.value.Val) // 10\n\t$.println(\"  (**pp1).Val:\", pp1!.value!.value!!.value.Val) // 10\n\t$.println(\"  (***ppp1).Val:\", ppp1!.value!.value!!.value.Val) // 10\n\t$.println(\"  s2.Val:\", s2!.value.Val) // 2 (unmodified)\n\n\tpp3!.value!.value = $.markAsStructValue(new MyStruct({Val: 20})) // Modify s2 via pp3 -> p3\n\t$.println(\"After **pp3 = {Val: 20}:\")\n\t$.println(\"  s2.Val:\", s2!.value.Val) // 20\n\t$.println(\"  (*p3).Val:\", p3!.value!!.value.Val) // 20\n\t$.println(\"  s1.Val:\", s1!.value.Val) // 10 (unmodified)\n\n\t// --- Nil Pointers ---\n\t$.println(\"\\n--- Nil Pointers ---\")\n\tlet np: $.VarRef<MyStruct | null> = $.varRef(null)\n\tlet npp: $.VarRef<MyStruct | null> | null = null\n\tlet nppp: $.VarRef<$.VarRef<MyStruct | null> | null> | null = null\n\n\t$.println(\"np == nil:\", np!.value == null) // true\n\t$.println(\"npp == nil:\", npp == null) // true\n\t$.println(\"nppp == nil:\", nppp == null) // true\n\n\tnpp = np // npp now points to np (which is nil)\n\t$.println(\"After npp = &np:\")\n\t$.println(\"  npp == nil:\", npp == null) // false\n\t$.println(\"  *npp == nil:\", npp!.value == null) // true\n}\n\n",
    "expectedOutput": "--- Initial Values ---\ns1.Val: 1\ns2.Val: 2\np1==p2: true\np1==p3: false\n\n--- Pointer Comparisons ---\npp1==pp2: false\npp1==pp3: false\n*pp1==*pp2: true\n*pp1==*pp3: false\n(**pp1).Val == (**pp2).Val: true\n(**pp1).Val == (**pp3).Val: false\nppp1==ppp1: true\n*ppp1==pp1: true\n**ppp1==p1: true\n(***ppp1).Val == s1.Val: true\n\n--- Modifications ---\nAfter *p1 = {Val: 10}:\n  s1.Val: 10\n  (*p2).Val: 10\n  (**pp1).Val: 10\n  (***ppp1).Val: 10\n  s2.Val: 2\nAfter **pp3 = {Val: 20}:\n  s2.Val: 20\n  (*p3).Val: 20\n  s1.Val: 10\n\n--- Nil Pointers ---\nnp == nil: true\nnpp == nil: true\nnppp == nil: true\nAfter npp = &np:\n  npp == nil: false\n  *npp == nil: true"
  },
  {
    "name": "channel_basic",
    "title": "Channels",
    "description": "Channel operations",
    "goCode": "package main\n\nfunc main() {\n\tmessages := make(chan string)\n\n\tgo func() {\n\t\tmessages <- \"ping\"\n\t}()\n\n\tmsg := <-messages\n\tprintln(msg)\n}\n",
    "tsCode": "// Generated file based on channel_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet messages = $.makeChannel<string>(0, \"\", 'both')\n\n\tqueueMicrotask(async () => {\n\t\tawait $.chanSend(messages, \"ping\")\n\t})\n\n\tlet msg = await $.chanRecv(messages)\n\t$.println(msg)\n}\n\n",
    "expectedOutput": "ping"
  },
  {
    "name": "goroutines",
    "title": "Goroutines",
    "description": "Concurrent execution with goroutines",
    "goCode": "// Package main tests goroutine handling with named functions\npackage main\n\n// Message struct with priority and text for deterministic ordering\ntype Message struct {\n\tpriority int\n\ttext     string\n}\n\n// Channel to collect messages from all goroutines\nvar messages = make(chan Message)\n\n// Total number of messages we expect to receive\nconst totalMessages = 8\n\n// A worker function that will be called as a goroutine\nfunc worker(id int) {\n\t// Send worker starting message\n\tmessages <- Message{\n\t\tpriority: 10 + id,\n\t\ttext:     \"Worker \" + string(rune('0'+id)) + \" starting\",\n\t}\n\n\t// Send worker done message\n\tmessages <- Message{\n\t\tpriority: 20 + id,\n\t\ttext:     \"Worker \" + string(rune('0'+id)) + \" done\",\n\t}\n}\n\n// Another worker function to test multiple different goroutines\nfunc anotherWorker(name string) {\n\tmessages <- Message{\n\t\tpriority: 40,\n\t\ttext:     \"Another worker: \" + name,\n\t}\n}\n\nfunc main() {\n\t// Create a slice to collect all messages\n\tallMessages := make([]Message, 0, totalMessages+3) // +3 for main thread messages\n\n\t// Add initial message\n\tallMessages = append(allMessages, Message{\n\t\tpriority: 0,\n\t\ttext:     \"Main: Starting workers\",\n\t})\n\n\t// Start 3 worker goroutines\n\tfor i := range 3 {\n\t\tgo worker(i) // This will trigger a past error with *ast.Ident\n\t}\n\n\t// Start another worker goroutine\n\tgo anotherWorker(\"test\")\n\n\t// Start an anonymous function worker\n\tgo func() {\n\t\tmessages <- Message{\n\t\t\tpriority: 50,\n\t\t\ttext:     \"Anonymous function worker\",\n\t\t}\n\t}()\n\n\t// Add status message\n\tallMessages = append(allMessages, Message{\n\t\tpriority: 1,\n\t\ttext:     \"Main: Workers started\",\n\t})\n\n\t// Collect all messages from goroutines\n\tfor i := 0; i < totalMessages; i++ {\n\t\tallMessages = append(allMessages, <-messages)\n\t}\n\n\t// Add final message\n\tallMessages = append(allMessages, Message{\n\t\tpriority: 100,\n\t\ttext:     \"Main: All workers completed\",\n\t})\n\n\t// Sort messages by priority for deterministic order\n\tfor i := range allMessages {\n\t\tfor j := i + 1; j < len(allMessages); j++ {\n\t\t\tif allMessages[i].priority > allMessages[j].priority {\n\t\t\t\tallMessages[i], allMessages[j] = allMessages[j], allMessages[i]\n\t\t\t}\n\t\t}\n\t}\n\n\t// Print all messages in deterministic order\n\tfor _, msg := range allMessages {\n\t\tprintln(msg.priority, msg.text)\n\t}\n\tprintln(\"done\")\n}\n",
    "tsCode": "// Generated file based on goroutines.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport let totalMessages: number = 8\n\nexport class Message {\n\tpublic get priority(): number {\n\t\treturn this._fields.priority.value\n\t}\n\tpublic set priority(value: number) {\n\t\tthis._fields.priority.value = value\n\t}\n\n\tpublic get text(): string {\n\t\treturn this._fields.text.value\n\t}\n\tpublic set text(value: string) {\n\t\tthis._fields.text.value = value\n\t}\n\n\tpublic _fields: {\n\t\tpriority: $.VarRef<number>;\n\t\ttext: $.VarRef<string>;\n\t}\n\n\tconstructor(init?: Partial<{priority?: number, text?: string}>) {\n\t\tthis._fields = {\n\t\t\tpriority: $.varRef(init?.priority ?? 0),\n\t\t\ttext: $.varRef(init?.text ?? \"\")\n\t\t}\n\t}\n\n\tpublic clone(): Message {\n\t\tconst cloned = new Message()\n\t\tcloned._fields = {\n\t\t\tpriority: $.varRef(this._fields.priority.value),\n\t\t\ttext: $.varRef(this._fields.text.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.Message',\n\t  new Message(),\n\t  [],\n\t  Message,\n\t  {\"priority\": { kind: $.TypeKind.Basic, name: \"int\" }, \"text\": { kind: $.TypeKind.Basic, name: \"string\" }}\n\t);\n}\n\nexport let messages: $.Channel<Message> | null = $.makeChannel<Message>(0, new Message(), 'both')\n\n// A worker function that will be called as a goroutine\nexport async function worker(id: number): Promise<void> {\n\t// Send worker starting message\n\tawait $.chanSend(messages, $.markAsStructValue(new Message({priority: 10 + id, text: \"Worker \" + $.runeOrStringToString(48 + id) + \" starting\"})))\n\n\t// Send worker done message\n\tawait $.chanSend(messages, $.markAsStructValue(new Message({priority: 20 + id, text: \"Worker \" + $.runeOrStringToString(48 + id) + \" done\"})))\n}\n\n// Another worker function to test multiple different goroutines\nexport async function anotherWorker(name: string): Promise<void> {\n\tawait $.chanSend(messages, $.markAsStructValue(new Message({priority: 40, text: \"Another worker: \" + name})))\n}\n\nexport async function main(): Promise<void> {\n\t// Create a slice to collect all messages\n\tlet allMessages = $.makeSlice<Message>(0, 8 + 3) // +3 for main thread messages\n\n\t// Add initial message\n\tallMessages = $.append(allMessages, $.markAsStructValue(new Message({priority: 0, text: \"Main: Starting workers\"})))\n\n\t// Start 3 worker goroutines\n\n\t// This will trigger a past error with *ast.Ident\n\tfor (let i = 0; i < 3; i++) {{\n\t\tqueueMicrotask(async () => {\n\t\t\tawait worker(i)\n\t\t})\n\t}\n}\n\n// Start another worker goroutine\nqueueMicrotask(async () => {\n\tawait anotherWorker(\"test\")\n})\n\n// Start an anonymous function worker\nqueueMicrotask(async () => {\n\tawait $.chanSend(messages, $.markAsStructValue(new Message({priority: 50, text: \"Anonymous function worker\"})))\n})\n\n// Add status message\nallMessages = $.append(allMessages, $.markAsStructValue(new Message({priority: 1, text: \"Main: Workers started\"})))\n\n// Collect all messages from goroutines\nfor (let i = 0; i < 8; i++) {\n\tallMessages = $.append(allMessages, await $.chanRecv(messages))\n}\n\n// Add final message\nallMessages = $.append(allMessages, $.markAsStructValue(new Message({priority: 100, text: \"Main: All workers completed\"})))\n\n// Sort messages by priority for deterministic order\nfor (let i = 0; i < $.len(allMessages); i++) {\n\t{\n\t\tfor (let j = i + 1; j < $.len(allMessages); j++) {\n\t\t\tif (allMessages![i].priority > allMessages![j].priority) {\n\t\t\t\t;[allMessages![i], allMessages![j]] = [allMessages![j], allMessages![i]]\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Print all messages in deterministic order\nfor (let _i = 0; _i < $.len(allMessages); _i++) {\n\tlet msg = allMessages![_i]\n\t{\n\t\t$.println(msg.priority, msg.text)\n\t}\n}\n$.println(\"done\")\n}\n\n",
    "expectedOutput": "0 Main: Starting workers\n1 Main: Workers started\n10 Worker 0 starting\n11 Worker 1 starting\n12 Worker 2 starting\n20 Worker 0 done\n21 Worker 1 done\n22 Worker 2 done\n40 Another worker: test\n50 Anonymous function worker\n100 Main: All workers completed\ndone"
  },
  {
    "name": "defer_statement",
    "title": "Defer",
    "description": "Defer statements",
    "goCode": "package main\n\nfunc main() {\n\tdefer println(\"deferred\")\n\tprintln(\"main\")\n}\n",
    "tsCode": "// Generated file based on defer_statement.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tusing __defer = new $.DisposableStack();\n\t__defer.defer(() => {\n\t\t$.println(\"deferred\")\n\t});\n\t$.println(\"main\")\n}\n\n",
    "expectedOutput": "main\ndeferred"
  },
  {
    "name": "func_literal",
    "title": "Function Literals",
    "description": "Anonymous functions and closures",
    "goCode": "package main\n\nfunc main() {\n\tgreet := func(name string) string {\n\t\treturn \"Hello, \" + name\n\t}\n\n\tmessage := greet(\"world\")\n\tprintln(message)\n}\n",
    "tsCode": "// Generated file based on func_literal.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport async function main(): Promise<void> {\n\tlet greet = (name: string): string => {\n\t\treturn \"Hello, \" + name\n\t}\n\n\tlet message = greet!(\"world\")\n\t$.println(message)\n}\n\n",
    "expectedOutput": "Hello, world"
  },
  {
    "name": "interface_type_assertion",
    "title": "Type Assertion",
    "description": "Type assertions",
    "goCode": "package main\n\ntype MyInterface interface {\n\tMethod1() int\n}\n\n/* MyStruct is a sample struct */\ntype MyStruct struct {\n\tValue int\n}\n\nfunc (m MyStruct) Method1() int {\n\treturn m.Value\n}\n\nfunc main() {\n\tvar i MyInterface\n\ts := MyStruct{Value: 10}\n\ti = s\n\n\t_, ok := i.(MyStruct)\n\tif ok {\n\t\tprintln(\"Type assertion successful\")\n\t} else {\n\t\tprintln(\"Type assertion failed\")\n\t}\n\n\t// try a second time since this generates something different when using = and not :=\n\t_, ok = i.(*MyStruct)\n\tif ok {\n\t\tprintln(\"Type assertion successful\")\n\t} else {\n\t\t// expected\n\t\tprintln(\"Type assertion failed\")\n\t}\n\n\t// assign result to a variable\n\tval, ok2 := i.(MyStruct)\n\tif !ok2 {\n\t\tprintln(\"type assertion failed\")\n\t} else {\n\t\tprintln(\"type assertion success\", val.Value)\n\t}\n}\n",
    "tsCode": "// Generated file based on interface_type_assertion.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport type MyInterface = null | {\n\tMethod1(): number\n}\n\n$.registerInterfaceType(\n  'main.MyInterface',\n  null, // Zero value for interface is null\n  [{ name: \"Method1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }]\n);\n\nexport class MyStruct {\n\tpublic get Value(): number {\n\t\treturn this._fields.Value.value\n\t}\n\tpublic set Value(value: number) {\n\t\tthis._fields.Value.value = value\n\t}\n\n\tpublic _fields: {\n\t\tValue: $.VarRef<number>;\n\t}\n\n\tconstructor(init?: Partial<{Value?: number}>) {\n\t\tthis._fields = {\n\t\t\tValue: $.varRef(init?.Value ?? 0)\n\t\t}\n\t}\n\n\tpublic clone(): MyStruct {\n\t\tconst cloned = new MyStruct()\n\t\tcloned._fields = {\n\t\t\tValue: $.varRef(this._fields.Value.value)\n\t\t}\n\t\treturn cloned\n\t}\n\n\tpublic Method1(): number {\n\t\tconst m = this\n\t\treturn m.Value\n\t}\n\n\t// Register this type with the runtime type system\n\tstatic __typeInfo = $.registerStructType(\n\t  'main.MyStruct',\n\t  new MyStruct(),\n\t  [{ name: \"Method1\", args: [], returns: [{ type: { kind: $.TypeKind.Basic, name: \"int\" } }] }],\n\t  MyStruct,\n\t  {\"Value\": { kind: $.TypeKind.Basic, name: \"int\" }}\n\t);\n}\n\nexport async function main(): Promise<void> {\n\tlet i: MyInterface = null\n\tlet s = $.markAsStructValue(new MyStruct({Value: 10}))\n\ti = $.markAsStructValue(s.clone())\n\n\tlet { ok: ok } = $.typeAssert<MyStruct>(i, 'main.MyStruct')\n\tif (ok) {\n\t\t$.println(\"Type assertion successful\")\n\t} else {\n\t\t$.println(\"Type assertion failed\")\n\t}\n\n\t// try a second time since this generates something different when using = and not :=\n\t({ ok: ok } = $.typeAssert<MyStruct | null>(i, {kind: $.TypeKind.Pointer, elemType: 'main.MyStruct'}))\n\n\t// expected\n\tif (ok) {\n\t\t$.println(\"Type assertion successful\")\n\t} else {\n\t\t// expected\n\t\t$.println(\"Type assertion failed\")\n\t}\n\n\t// assign result to a variable\n\tlet { value: val, ok: ok2 } = $.typeAssert<MyStruct>(i, 'main.MyStruct')\n\tif (!ok2) {\n\t\t$.println(\"type assertion failed\")\n\t} else {\n\t\t$.println(\"type assertion success\", val.Value)\n\t}\n}\n\n",
    "expectedOutput": "Type assertion successful\nType assertion failed\ntype assertion success 10"
  },
  {
    "name": "generics_basic",
    "title": "Generics",
    "description": "Generic types and functions",
    "goCode": "package main\n\nfunc printVal[T any](val T) {\n\tprintln(val)\n}\n\nfunc main() {\n\tprintVal(10)\n\tprintVal(\"hello\")\n\tprintVal(true)\n}\n",
    "tsCode": "// Generated file based on generics_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\nexport function printVal<T extends any>(val: T): void {\n\t$.println(val)\n}\n\nexport async function main(): Promise<void> {\n\tprintVal(10)\n\tprintVal(\"hello\")\n\tprintVal(true)\n}\n\n",
    "expectedOutput": "10\nhello\ntrue\n"
  },
  {
    "name": "async_basic",
    "title": "Async/Await",
    "description": "Async function translation",
    "goCode": "package main\n\n// This function receives from a channel, making it async.\nfunc receiveFromChan(ch chan int) int {\n\tval := <-ch // This operation makes the function async\n\treturn val\n}\n\n// This function calls an async function, making it async too.\nfunc caller(ch chan int) int {\n\t// We expect this call to be awaited in TypeScript\n\tresult := receiveFromChan(ch)\n\treturn result + 1\n}\n\nfunc main() {\n\t// Create a buffered channel\n\tmyChan := make(chan int, 1)\n\tmyChan <- 10 // Send a value\n\n\t// Call the async caller function\n\tfinalResult := caller(myChan)\n\tprintln(finalResult) // Expected output: 11\n\n\tclose(myChan)\n}\n",
    "tsCode": "// Generated file based on async_basic.go\n// Updated when compliance tests are re-run, DO NOT EDIT!\n\nimport * as $ from \"@goscript/builtin/index.js\"\n\n// This function receives from a channel, making it async.\nexport async function receiveFromChan(ch: $.Channel<number> | null): Promise<number> {\n\tlet val = await $.chanRecv(ch) // This operation makes the function async\n\treturn val\n}\n\n// This function calls an async function, making it async too.\nexport async function caller(ch: $.Channel<number> | null): Promise<number> {\n\t// We expect this call to be awaited in TypeScript\n\tlet result = await receiveFromChan(ch)\n\treturn result + 1\n}\n\nexport async function main(): Promise<void> {\n\t// Create a buffered channel\n\tlet myChan = $.makeChannel<number>(1, 0, 'both')\n\tawait $.chanSend(myChan, 10)\n\n\t// Call the async caller function\n\tlet finalResult = await caller(myChan)\n\t$.println(finalResult) // Expected output: 11\n\n\tmyChan.close()\n}\n\n",
    "expectedOutput": "11"
  }
]